[
    {
        "id": "799d902a165e50be",
        "type": "subflow",
        "name": "Telegram API receiver",
        "category": "Telegram Bot API",
        "in": [],
        "out": [
            {
                "x": 840,
                "y": 40,
                "wires": [
                    {
                        "id": "85c287a9917d09e6",
                        "port": 0
                    },
                    {
                        "id": "d868daa626a6f515",
                        "port": 0
                    }
                ]
            },
            {
                "x": 840,
                "y": 100,
                "wires": [
                    {
                        "id": "e5df7a9578d68238",
                        "port": 0
                    },
                    {
                        "id": "f2185d81a99762d2",
                        "port": 0
                    }
                ]
            },
            {
                "x": 840,
                "y": 220,
                "wires": [
                    {
                        "id": "4bebee7279e15eae",
                        "port": 0
                    }
                ]
            }
        ],
        "env": [
            {
                "name": "url",
                "type": "str",
                "value": "https://api.telegram.org",
                "ui": {
                    "icon": "font-awesome/fa-link",
                    "label": {
                        "en-US": "Url:"
                    },
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "token",
                "type": "str",
                "value": "",
                "ui": {
                    "icon": "font-awesome/fa-user-secret",
                    "label": {
                        "en-US": "Token:"
                    },
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "stop_service",
                "type": "bool",
                "value": "true",
                "ui": {
                    "icon": "font-awesome/fa-stop-circle-o",
                    "label": {
                        "en-US": "Stop service"
                    },
                    "type": "checkbox"
                }
            },
            {
                "name": "send_action",
                "type": "bool",
                "value": "false",
                "ui": {
                    "icon": "font-awesome/fa-send",
                    "label": {
                        "en-US": "Send chat action"
                    },
                    "type": "checkbox"
                }
            },
            {
                "name": "original_message",
                "type": "bool",
                "value": "true",
                "ui": {
                    "icon": "font-awesome/fa-paperclip",
                    "label": {
                        "en-US": "Attach original message"
                    },
                    "type": "checkbox"
                }
            },
            {
                "name": "content_filter_list",
                "type": "json",
                "value": "[\"text\",\"location\",\"contact\"]",
                "ui": {
                    "icon": "font-awesome/fa-filter",
                    "label": {
                        "en-US": "Content filter:"
                    },
                    "type": "input",
                    "opts": {
                        "types": [
                            "json"
                        ]
                    }
                }
            },
            {
                "name": "content_filter",
                "type": "bool",
                "value": "false",
                "ui": {
                    "icon": "font-awesome/fa-filter",
                    "label": {
                        "en-US": "Enable content filter"
                    },
                    "type": "checkbox"
                }
            },
            {
                "name": "expiration_minutes",
                "type": "num",
                "value": "5",
                "ui": {
                    "icon": "font-awesome/fa-clock-o",
                    "label": {
                        "en-US": "Expiration minutes:"
                    },
                    "type": "input",
                    "opts": {
                        "types": [
                            "num"
                        ]
                    }
                }
            },
            {
                "name": "expiration",
                "type": "bool",
                "value": "false",
                "ui": {
                    "icon": "font-awesome/fa-clock-o",
                    "label": {
                        "en-US": "Enable expiration message"
                    },
                    "type": "checkbox"
                }
            }
        ],
        "meta": {
            "module": "node-red-telegram-bot-api-receiver",
            "version": "2.0.0",
            "author": "Bruno Leonardi <b.leonardi78@gmail.com>",
            "desc": "Riceve i messaggi da Telegram",
            "keywords": "telegram, bot, api, messaging, messages, message",
            "license": "MIT"
        },
        "color": "#3FADB5",
        "outputLabels": [
            "Connection status",
            "Message accepted",
            "Message rejected"
        ],
        "icon": "font-awesome/fa-cloud-download",
        "status": {
            "x": 510,
            "y": 230,
            "wires": [
                {
                    "id": "a3187931500e6642",
                    "port": 0
                }
            ]
        }
    },
    {
        "id": "5b2c6438b32488b0",
        "type": "http request",
        "z": "799d902a165e50be",
        "name": "Telegram server",
        "method": "use",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "authType": "",
        "senderr": false,
        "x": 360,
        "y": 160,
        "wires": [
            [
                "8640ec936c216e76",
                "1fe6ce616ba331fd"
            ]
        ]
    },
    {
        "id": "7ecfe4abf0357a04",
        "type": "status",
        "z": "799d902a165e50be",
        "name": "",
        "scope": [
            "fb219cf60130f353",
            "8640ec936c216e76"
        ],
        "x": 295,
        "y": 230,
        "wires": [
            [
                "a3187931500e6642"
            ]
        ],
        "l": false
    },
    {
        "id": "e5d1b95fdc03c93c",
        "type": "catch",
        "z": "799d902a165e50be",
        "name": "",
        "scope": [
            "5b2c6438b32488b0",
            "8640ec936c216e76",
            "f2185d81a99762d2",
            "dabb0bbe4e7c6777",
            "fb219cf60130f353"
        ],
        "uncaught": false,
        "x": 65,
        "y": 280,
        "wires": [
            [
                "e28aee50621cee34",
                "1fe6ce616ba331fd"
            ]
        ],
        "l": false
    },
    {
        "id": "8640ec936c216e76",
        "type": "function",
        "z": "799d902a165e50be",
        "name": "Response",
        "func": "/**\n * Telegram Bot Api Javascript for Node-RED\n */\nconst TelegramBotApi = global.get('TelegramBotApi.class')\nconst Bot = new TelegramBotApi(msg)\n\n/**\n * Tools Class Collections Javascript for Node-RED\n */\nconst Tools = global.get('Tools.class')\nconst js = new Tools(msg)\n\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n\n/**\n * ////////////////////////////////////////////////////\n * Telegram Bot API receiver\n * Subflow per Node-Red\n * node-telegram-bot-api-receiver\n * ////////////////////////////////////////////////////\n * Author: Bruno Leonardi <b.leonardi78@gmail.com>\n * ////////////////////////////////////////////////////\n */\n\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n\n//tipo non gestito\nconst UNMANAGED = Bot.UNMANAGED\nvar unmanaged = false\n//tipo sconosciuto\nconst UNKNOWN = Bot.UNKNOWN\nvar unknown = false\n\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n\n//Risposta del server\nvar Response = RED.util.cloneMessage(msg)\n//codice stato risposta\nvar status = Response.statusCode || 0\n//messaggio di errore\nvar error_message = null\n//id di aggiornamento\nvar update_id = 1\n//array dei nuovi messaggi\nvar Updates = []\n//array dei nuovi messaggi accettati\nvar Messages_accepted = []\n//array dei nuovi messaggi rifiutati\nvar Messages_rejected = []\n//nuovo messaggio\nvar Message = {}\n//scadenza nuovo messaggio\nvar message_expiration = { minutes: 0 }\n//contenuto del messaggio\nvar content = null\n//tipo di contenuto del messaggio\nvar content_type = UNKNOWN\n//filtro contenuto messaggio\nvar content_filter = env.get(\"content_filter\")\n//lista filtro contenuto messaggio\nvar content_filter_list = env.get(\"content_filter_list\")\n//tipo di messaggio ufficiale\nvar message_type = UNKNOWN\n//solo messaggi pi√π recenti\nconst expiration = env.get(\"expiration\")\n//minuti per messaggi recenti\nconst expiration_minutes = parseInt(env.get('expiration_minutes'))\n//risposta dal server\nvar payload_ok = false\n\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n\nconst METHOD = Bot.METHOD\nconst ACTION = Bot.CHAT_ACTION\nconst CONTENT_TYPE = Bot.CONTENT_TYPE\nconst MESSAGE_TYPE = Bot.MESSAGE_TYPE\n\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n\n//configurazione informazioni global telegram\nvar settings = {\n    bot: global.get('telegram.receiver.bot'),\n    url: global.get(\"telegram.receiver.url\"),\n    token: env.get(\"token\"),\n    method: flow.get(\"method\"),\n    update_id: global.get(\"telegram.receiver.update_id\"),\n    status: null,\n    last_error: global.get(\"telegram.receiver.last_error\") || null,\n    last_date: global.get('telegram.receiver.last_date' || null)\n}\n\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n\n/**\n * Definisce il messaggio e restituisce il tipo\n * @param {object} update Messaggio di update\n */\nfunction SetMessage(update) {\n    //recupera id di reply_to_message\n    let reply_to_message_id = js.JSGet('reply_to_message.message_id', update)\n\n    //imposta la data del messaggio\n    let message_date = js.JSGet('date.*.>', update)\n\n    //tempo trascorso da quando l'utente ha inviato il messaggio\n    var date_expiration = js.UnixToUTC(message_date)\n    message_expiration = js.GetTimeElapsed(date_expiration)\n\n    //assegna il messaggio\n    Message = {}\n\n    //allego il messaggio originale\n    if (env.get(\"original_message\")) Message.original = RED.util.cloneMessage(update)\n\n    //messaggio inoltrato\n    Message.forwarded = false\n\n    //contiene i dati della risposta\n    Message.reply_to_request = null\n\n    //informazioni utente\n    if (js.JSGet('forward_from.*.$boolean', update)) {\n        Message.forwarded = true\n        Message.user_id = js.JSGet('forward_from.id', update)\n        Message.user = js.JSGet('forward_from', update)\n    } else if (js.JSGet('via_bot.*.$boolean', update)) {\n        Message.user_id = js.JSGet('via_bot.id', update)\n        Message.user = js.JSGet('via_bot', update)\n    } else {\n        Message.user_id = js.JSGet('from.id', update)\n        Message.user = js.JSGet('from', update)\n    }\n\n    //informazioni chat\n    if (js.JSGet('forward_from_chat.*.$boolean', update)) {\n        Message.forwarded = true\n        Message.chat_id = js.JSGet('forward_from_chat.id', update)\n        Message.chat = js.JSGet('forward_from_chat', update)\n    } else if (js.JSGet('sender_chat.*.$boolean', update)) {\n        Message.chat_id = js.JSGet('sender_chat.id', update)\n        Message.chat = js.JSGet('sender_chat', update)\n    } else {\n        Message.chat_id = js.JSGet('chat.id', update)\n        Message.chat = js.JSGet('chat', update)\n    }\n\n    //informazioni global\n    if (Bot.GetGlobalPending(Message.chat_id)) {\n        date_expiration = Bot.GetGlobalDate(Message.chat_id)\n        date_expiration = js.UnixToUTC(date_expiration)\n        //reset global chat se trascorso...\n        if (js.GetTimeElapsed(date_expiration).hours > 1) {\n            Bot.ResetGlobalChat(Message.chat_id)\n        } else {\n            Message.reply_to_request = Bot.GetGlobalChat(Message.chat_id)[Message.chat_id] || null\n        }\n    }\n\n    //prepara il messaggio\n    Message.message_id = js.JSGet('message_id', update)\n    if (reply_to_message_id) Message.message_reply_id = reply_to_message_id\n    Message.message_date = message_date\n\n    //scadenza messaggio\n    if (expiration) {\n        Message.message_expired = (message_expiration.minutes > expiration_minutes)\n        //verifico se c'√® una pendenza e confronto la sua data\n        if (!Message.message_expired && Bot.GetGlobalPending(Message.chat_id)) {\n            let data_pending = Bot.GetGlobalData(Message.chat_id)\n            if (data_pending) {\n                data_pending = js.UnixToUTC(data_pending)\n                message_expiration = js.GetTimeElapsed(data_pending)\n                Message.message_expired = (message_expiration.minutes > expiration_minutes)\n            }\n        }\n    } else {\n        Message.message_expired = false\n    }\n\n    //definisci il tipo di messaggio e il contenuto\n    if (update.message) {\n        if (update.message.reply_to_message) {\n            //definisci il contenuto\n            content_type = Bot.GetContentType(update.message)\n            content = Bot.GetContent(update.message)\n\n            //definisci il messaggio\n            message_type = MESSAGE_TYPE.reply_to_message\n            Message.message_type = message_type\n            Message.content_type = content_type\n            Message.content_filter = content_filter\n            if (content_type == CONTENT_TYPE.text) {\n                content = js.TextReplaceApostrophe(content)\n                Message.content_emoji = js.ContainsEmoji(content)\n                Message.content_only_emoji = js.ContainsOnlyEmoji(content)\n            }\n            Message.content = content\n            if (update.message.caption) Message.caption = update.message.caption\n            return message_type\n        } else if (update.message.pinned_message) {\n            //definisci il contenuto\n            content_type = Bot.GetContentType(update.message.pinned_message)\n            content = Bot.GetContent(update.message.pinned_message)\n\n            //definisci il messaggio\n            message_type = MESSAGE_TYPE.pinned_message\n            Message.message_type = message_type\n            Message.content_type = content_type\n            Message.content_filter = content_filter\n            if (content_type == CONTENT_TYPE.text) {\n                content = js.TextReplaceApostrophe(content)\n                Message.content_emoji = js.ContainsEmoji(content)\n                Message.content_only_emoji = js.ContainsOnlyEmoji(content)\n            }\n            Message.content = content\n            if (update.message.pinned_message.caption) Message.caption = update.message.pinned_message.caption\n            return message_type\n        } else {\n            //definisci il contenuto\n            content_type = Bot.GetContentType(update.message)\n            content = Bot.GetContent(update.message)\n\n            //definisci il messaggio\n            message_type = MESSAGE_TYPE.message\n            Message.message_type = message_type\n            Message.content_type = content_type\n            Message.content_filter = content_filter\n            if (content_type == CONTENT_TYPE.text) {\n                content = js.TextReplaceApostrophe(content)\n                Message.content_emoji = js.ContainsEmoji(content)\n                Message.content_only_emoji = js.ContainsOnlyEmoji(content)\n            }\n            Message.content = content\n            if (update.message.caption) Message.caption = update.message.caption\n            return message_type\n        }\n    } else if (update.edited_message) {\n        if (update.edited_message.text) {\n            //definisci il contenuto\n            content_type = CONTENT_TYPE.text\n            content = update.edited_message.text\n        } else if (update.edited_message.caption) {\n            //definisci il contenuto\n            content_type = CONTENT_TYPE.text\n            content = update.edited_message.caption\n        } else {\n            //definisci il contenuto\n            content_type = Bot.GetContentType(update.edited_message)\n            content = Bot.GetContent(update.edited_message)\n        }\n\n        //definisci il messaggio\n        message_type = MESSAGE_TYPE.edited_message\n        Message.message_type = message_type\n        Message.content_type = content_type\n        Message.content_filter = content_filter\n        if (content_type == CONTENT_TYPE.text) {\n            content = js.TextReplaceApostrophe(content)\n            Message.content_emoji = js.ContainsEmoji(content)\n            Message.content_only_emoji = js.ContainsOnlyEmoji(content)\n        }\n        Message.content = content\n        if (update.edited_message.caption) Message.caption = update.edited_message.caption\n        return message_type\n    } else if (update.channel_post) {\n        //come update.message\n        if (update.channel_post.reply_to_message) {\n            //definisci il contenuto\n            content_type = Bot.GetContentType(update.channel_post)\n            content = Bot.GetContent(update.channel_post)\n\n            //definisci il messaggio\n            message_type = MESSAGE_TYPE.reply_to_message\n            Message.message_type = message_type\n            Message.content_type = content_type\n            Message.content_filter = content_filter\n            if (content_type == CONTENT_TYPE.text) {\n                content = js.TextReplaceApostrophe(content)\n                Message.content_emoji = js.ContainsEmoji(content)\n                Message.content_only_emoji = js.ContainsOnlyEmoji(content)\n            }\n            Message.content = content\n            if (update.channel_post.caption) Message.caption = update.channel_post.caption\n            return message_type\n        } else if (update.channel_post.pinned_message) {\n            //definisci il contenuto\n            content_type = Bot.GetContentType(update.channel_post.pinned_message)\n            content = Bot.GetContent(update.channel_post.pinned_message)\n\n            //definisci il messaggio\n            message_type = MESSAGE_TYPE.pinned_message\n            Message.message_type = message_type\n            Message.content_type = content_type\n            Message.content_filter = content_filter\n            if (content_type == CONTENT_TYPE.text) {\n                content = js.TextReplaceApostrophe(content)\n                Message.content_emoji = js.ContainsEmoji(content)\n                Message.content_only_emoji = js.ContainsOnlyEmoji(content)\n            }\n            Message.content = content\n            if (update.channel_post.pinned_message.caption) Message.caption = update.channel_post.pinned_message.caption\n            return message_type\n        } else {\n            //definisci il contenuto\n            content_type = Bot.GetContentType(update.channel_post)\n            content = Bot.GetContent(update.channel_post)\n\n            //definisci il messaggio\n            message_type = MESSAGE_TYPE.message\n            Message.message_type = message_type\n            Message.content_type = content_type\n            Message.content_filter = content_filter\n            if (content_type == CONTENT_TYPE.text) {\n                content = js.TextReplaceApostrophe(content)\n                Message.content_emoji = js.ContainsEmoji(content)\n                Message.content_only_emoji = js.ContainsOnlyEmoji(content)\n            }\n            Message.content = content\n            if (update.channel_post.caption) Message.caption = update.channel_post.caption\n            return message_type\n        }\n    } else if (update.edited_channel_post) {\n        //come update.edited_message\n        if (update.edited_channel_post.text) {\n            //definisci il contenuto\n            content_type = CONTENT_TYPE.text\n            content = update.edited_channel_post.text\n        } else if (update.edited_channel_post.caption) {\n            //definisci il contenuto\n            content_type = CONTENT_TYPE.text\n            content = update.edited_channel_post.caption\n        } else {\n            //definisci il contenuto\n            content_type = Bot.GetContentType(update.edited_channel_post)\n            content = Bot.GetContent(update.edited_channel_post)\n        }\n\n        //definisci il messaggio\n        message_type = MESSAGE_TYPE.edited_channel_post\n        Message.message_type = message_type\n        Message.content_type = content_type\n        Message.content_filter = content_filter\n        if (content_type == CONTENT_TYPE.text) {\n            content = js.TextReplaceApostrophe(content)\n            Message.content_emoji = js.ContainsEmoji(content)\n            Message.content_only_emoji = js.ContainsOnlyEmoji(content)\n        }\n        Message.content = content\n        if (update.edited_channel_post.caption) Message.caption = update.edited_channel_post.caption\n        return message_type\n    } else if (update.inline_query) {\n        //definisci il messaggio\n        Message = RED.util.cloneMessage(update)\n        unmanaged = true\n        message_type = MESSAGE_TYPE.inline_query\n        Message.message_type = message_type\n        return message_type\n    } else if (update.chosen_inline_result) {\n        //definisci il messaggio\n        Message = RED.util.cloneMessage(update)\n        unmanaged = true\n        message_type = MESSAGE_TYPE.chosen_inline_result\n        Message.message_type = message_type\n        return message_type\n    } else if (update.callback_query) {\n        //definisci il contenuto\n        content_type = CONTENT_TYPE.text\n        content = update.callback_query.data\n\n        //definisci il messaggio\n        message_type = MESSAGE_TYPE.callback_query\n        Message.message_type = message_type\n        Message.callback_id = update.callback_query.id\n        Message.content_type = content_type\n        Message.content_filter = content_filter\n        if (content_type == CONTENT_TYPE.text) {\n            content = js.TextReplaceApostrophe(content)\n            Message.content_emoji = js.ContainsEmoji(content)\n            Message.content_only_emoji = js.ContainsOnlyEmoji(content)\n        }\n        Message.content = content\n        return message_type\n    } else if (update.shipping_query) {\n        //definisci il messaggio\n        Message = RED.util.cloneMessage(update)\n        unmanaged = true\n        message_type = MESSAGE_TYPE.shipping_query\n        Message.message_type = message_type\n        return message_type\n    } else if (update.pre_checkout_query) {\n        //definisci il messaggio\n        Message = RED.util.cloneMessage(update)\n        unmanaged = true\n        message_type = MESSAGE_TYPE.pre_checkout_query\n        Message.message_type = message_type\n        return message_type\n    } else if (update.poll) {\n        //definisci il messaggio\n        Message = RED.util.cloneMessage(update)\n        unmanaged = true\n        message_type = MESSAGE_TYPE.poll\n        Message.message_type = message_type\n        return message_type\n    } else if (update.poll_answer) {\n        //definisci il messaggio\n        Message = RED.util.cloneMessage(update)\n        unmanaged = true\n        message_type = MESSAGE_TYPE.poll_answer\n        Message.message_type = message_type\n        return message_type\n    } else if (update.my_chat_member) {\n        if (update.my_chat_member.new_chat_member) {\n            //definisci il contenuto\n            content_type = CONTENT_TYPE.text\n            content = update.my_chat_member.new_chat_member.status\n\n            //definisci il messaggio\n            message_type = MESSAGE_TYPE.my_chat_member\n            Message.message_type = message_type\n            Message.content_type = content_type\n            Message.content_filter = content_filter\n            if (content_type == CONTENT_TYPE.text) {\n                content = js.TextReplaceApostrophe(content)\n                Message.content_emoji = js.ContainsEmoji(content)\n                Message.content_only_emoji = js.ContainsOnlyEmoji(content)\n            }\n            Message.content = content\n            return message_type\n        } else {\n            //definisci il messaggio\n            Message = RED.util.cloneMessage(update)\n            unmanaged = true\n            message_type = MESSAGE_TYPE.my_chat_member\n            Message.message_type = message_type\n            return message_type\n        }\n    } else if (update.chat_member) {\n        //definisci il messaggio\n        Message = RED.util.cloneMessage(update)\n        unmanaged = true\n        message_type = MESSAGE_TYPE.chat_member\n        Message.message_type = message_type\n        return message_type\n    } else if (update.chat_join_request) {\n        //definisci il messaggio\n        Message = RED.util.cloneMessage(update)\n        unmanaged = true\n        message_type = MESSAGE_TYPE.chat_join_request\n        Message.message_type = message_type\n        return message_type\n    } else {\n        //definisci il messaggio\n        Message = RED.util.cloneMessage(update)\n        unknown = true\n        message_type = UNKNOWN\n        Message.message_type = message_type\n        return message_type\n    }\n}\n\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n\n//verifico se esiste il payload\nif (Response.payload) {\n    try {\n        //lo converto in oggetto\n        Response = (typeof Response.payload === 'string') ? JSON.parse(Response.payload) : Response.payload\n    } catch (error) {\n        status = 0\n        Response = {\n            ok: false,\n            error_code: 0,\n            description: \"Error JSONParse convertion\"\n        }\n    }\n\n    //controllo se √® una risposta di telegram\n    //payload: \"{\"ok\":true,\"result\":[]}\"\n    if (Response.ok === undefined) {\n        status = 0\n        Response = {\n            ok: false,\n            error_code: 0,\n            description: \"It is not a Telegram message\"\n        }\n    } else {\n        payload_ok = Response.ok\n    }\n} else {\n    status = 0\n    Response = {\n        ok: false,\n        error_code: 0,\n        description: \"Payload message not exists\"\n    }\n}\n\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n\n//verifico lo status, il loop si arresta per qualsiasi errore\nif (status == 200) {\n    //payload: \"{\"ok\":true,\"result\":[]}\"\n    if (Response.result) Updates = Response.result\n} else {\n    //https://core.telegram.org/api/errors\n    error_message = Response.description || \"Unknown error\"\n    error_message = `${status} | ${error_message}`\n    error_message = new Error(error_message)\n}\n\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n\n//processo il messaggio di update\nif (!error_message) {\n    //in base al metodo...\n    if (settings.method == METHOD.getMe) {\n        //informazioni sul bot\n        settings.bot = Response.result\n    } else {\n        if (payload_ok && Updates.length == 0) {\n            //ok ma senza messaggi\n            Message = {}\n            Messages_accepted = []\n            Messages_rejected = []\n        } else if (payload_ok && Updates.length > 0) {\n            try {\n                //verifico tutti i messaggi\n                for (let i = 0; i < Updates.length; i++) {\n                    //imposta il messaggio\n                    message_type = SetMessage(Updates[i])\n\n                    //se il tipo messaggio √® gestito\n                    if (!unknown && !unmanaged) {\n                        //filtri impostati per tipo di contenuto del messaggio\n                        if (content_filter) {\n                            content_filter_list = (Array.isArray(content_filter_list)) ? content_filter_list : []\n                            content_filter = (content_filter_list.length > 0)\n                        } else {\n                            content_filter_list = []\n                        }\n\n                        //rimuovo il messaggio originale\n                        delete Message[MESSAGE_TYPE.message]\n                        delete Message[message_type]\n\n                        //filtro tipo di contenuto del messaggio\n                        if (!content_filter || (content_filter && content_filter_list.includes(content_type))) {\n                            Messages_accepted.push(Message)\n                        } else {\n                            Messages_rejected.push(Message)\n                        }\n                    } else {\n                        Messages_rejected.push(Message)\n                    }\n                }\n            } catch (error) {\n                error_message = error\n            }\n        } else {\n            error_message = \"Error match, ok is \" + payload_ok + \" and result at \" + Updates.length\n            error_message = new Error(error_message)\n        }\n    }\n}\n\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n\n//aggiorno le impostazioni\nsettings.status = (status == 200) ? \"Connected\" : \"Disconnected\"\nsettings.last_error = error_message || settings.last_error\nsettings.last_date = (error_message) ? new Date() : settings.last_date\nglobal.set(\"telegram.receiver\", settings)\n\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n\n//aggiorno lo stato e invio eventuali nuovi messaggi\nif (error_message) {\n    node.status({ fill: \"red\", shape: \"dot\", text: error_message.message })\n    node.error(error_message, msg)\n} else {\n    //messaggi accettati\n    if (Messages_accepted.length > 0) {\n        for (let i = 0; i < Messages_accepted.length; i++) {\n            node.send([null, { telegram: Messages_accepted[i] }, null])\n        }\n\n        if (Messages_accepted.length === 1) {\n            node.status({ fill: \"blue\", shape: \"dot\", text: \"New message accepted\" })\n        } else {\n            node.status({ fill: \"blue\", shape: \"dot\", text: Messages_accepted.length + \" new messages accepted\" })\n        }\n\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n\n    //messaggi respinti\n    if (Messages_rejected.length > 0) {\n        for (let i = 0; i < Messages_rejected.length; i++) {\n            node.send([null, null, { telegram: Messages_rejected[i] }])\n        }\n\n        if (Messages_rejected.length === 1) {\n            node.status({ fill: \"yellow\", shape: \"dot\", text: \"New message rejected\" })\n        } else {\n            node.status({ fill: \"yellow\", shape: \"dot\", text: Messages_rejected.length + \" new messages rejected\" })\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n\n    //memorizzo l'ultimo update_id\n    if (Updates.length > 0) {\n        //imposto update_id per confermare la lettura al server\n        update_id += (Updates[Updates.length - 1].update_id)\n        global.set(\"telegram.receiver.update_id\", update_id)\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n\n    //invio la richiesta update\n    var bot_name = global.get(\"telegram.receiver.bot.first_name\") || 'Bot'\n\n    if (Messages_accepted.length == 0 && Messages_rejected.length == 0) {\n        content_filter = content_filter ? ' + filter' : ''\n        node.status({ fill: \"blue\", shape: \"dot\", text: bot_name + \" is connected\" + content_filter })\n    }\n}\n\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n\n//nuova richiesta\nreturn [{ payload: \"new_request\" }, null, null]",
        "outputs": 3,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 550,
        "y": 160,
        "wires": [
            [
                "18e7f2955c050555"
            ],
            [
                "8a32a3bce6dbb797"
            ],
            [
                "4bebee7279e15eae"
            ]
        ],
        "inputLabels": [
            "Http response"
        ],
        "outputLabels": [
            "New request",
            "Message accepted",
            "Message rejected"
        ]
    },
    {
        "id": "90630512b101cdf9",
        "type": "inject",
        "z": "799d902a165e50be",
        "name": "Start request",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "5",
        "topic": "",
        "x": 65,
        "y": 160,
        "wires": [
            [
                "fb219cf60130f353"
            ]
        ],
        "l": false
    },
    {
        "id": "a3187931500e6642",
        "type": "delay",
        "z": "799d902a165e50be",
        "name": "Rate limit",
        "pauseType": "rate",
        "timeout": "5",
        "timeoutUnits": "minutes",
        "rate": "2",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 425,
        "y": 230,
        "wires": [
            []
        ],
        "l": false
    },
    {
        "id": "e28aee50621cee34",
        "type": "function",
        "z": "799d902a165e50be",
        "name": "Node error",
        "func": "node.error(msg, msg)",
        "outputs": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 200,
        "y": 280,
        "wires": []
    },
    {
        "id": "f2185d81a99762d2",
        "type": "function",
        "z": "799d902a165e50be",
        "name": "sendChatAction",
        "func": "/**\n * Telegram Bot Api Javascript for Node-RED\n */\nconst TelegramBotApi = global.get('TelegramBotApi.class')\nconst Bot = new TelegramBotApi(msg)\n\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n\nif (msg.telegram && env.get(\"send_action\")) {\n    msg.original_message = RED.util.cloneMessage(msg)\n\n    try {\n        var url = global.get('telegram.url_base')\n        var chat_id = msg.telegram.chat_id\n        var action = Bot.GetAction(msg.telegram.content_type)\n        if (!chat_id) return [msg, null]\n        msg.method = 'POST'\n        msg.url = `${url}sendChatAction?chat_id=${chat_id}&action=${action}`\n        return [null, msg]\n    } catch (error) {\n        node.error(error, msg)\n        return [msg.original_message, null]\n    }\n} else {\n    return [msg, null]\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 765,
        "y": 160,
        "wires": [
            [],
            [
                "dabb0bbe4e7c6777"
            ]
        ],
        "icon": "font-awesome/fa-send",
        "l": false
    },
    {
        "id": "dabb0bbe4e7c6777",
        "type": "http request",
        "z": "799d902a165e50be",
        "name": "Chat action",
        "method": "use",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "authType": "",
        "senderr": false,
        "x": 835,
        "y": 160,
        "wires": [
            [
                "e5df7a9578d68238"
            ]
        ],
        "l": false
    },
    {
        "id": "18e7f2955c050555",
        "type": "trigger",
        "z": "799d902a165e50be",
        "name": "Wait for...",
        "op1": "",
        "op2": "",
        "op1type": "nul",
        "op2type": "pay",
        "duration": "500",
        "extend": false,
        "overrideDelay": false,
        "units": "ms",
        "reset": "",
        "bytopic": "all",
        "topic": "topic",
        "outputs": 1,
        "x": 190,
        "y": 90,
        "wires": [
            [
                "fb219cf60130f353",
                "85c287a9917d09e6",
                "b539f91be403db6c"
            ]
        ]
    },
    {
        "id": "fb219cf60130f353",
        "type": "function",
        "z": "799d902a165e50be",
        "name": "Request",
        "func": "/**\n * ////////////////////////////////////////////////////\n * Telegram Bot API receiver\n * Subflow per Node-Red\n * node-telegram-bot-api-receiver\n * Date: 20/07/2022\n * ////////////////////////////////////////////////////\n * Author: Bruno Leonardi <b.leonardi78@gmail.com>\n * ////////////////////////////////////////////////////\n */\n\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n\n//arresta il servizio\nif (env.get('stop_service')) {\n    node.status({ fill: \"yellow\", shape: \"dot\", text: \"The service is stopped!\" })\n    return null\n}\n\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n\n//configurazione bot telegram\n//var bot = env.get(\"bot\").trim().replace(/\\s/g, '_') || 'bot'\nvar settings = {\n    bot: global.get('telegram.receiver.bot'),\n    url: \"https://api.telegram.org/\",\n    token: '',\n    method: flow.get(\"method\"),\n    update_id: -1,\n    status: global.get('telegram.receiver.status'),\n    last_error: global.get('telegram.receiver.last_error') || null,\n    last_date: global.get('telegram.receiver.last_date') || null\n}\n\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n\n//imposto l'ultimo id di aggiornamento dei messaggi\nvar update_id = global.get('telegram.receiver.update_id')\n\n//imposto url in base al metodo\nvar url = env.get(\"url\").trim()\nurl = (!url.endsWith('/')) ? url + '/' : url\n\n//imposto il token\nvar token = env.get(\"token\").trim()\n\n//verifico i campi\nif (token.length < 10) {\n    node.status({ fill: \"yellow\", shape: \"dot\", text: \"Check the inserted TOKEN\" })\n    return null\n} else if (!url.includes('http') || url.length < 10) {\n    node.status({ fill: \"yellow\", shape: \"dot\", text: \"Check the inserted URL API\" })\n    return null\n}\n\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n\n//imposto url base completo di token\nglobal.set('telegram.url_base', `${url}bot${token}/`)\n\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n\n//imposto il metodo\nvar method = flow.get(\"method\") || null\n\nif (!method || global.get('telegram.receiver.bot') === undefined) {\n    //richiedo le informazioni bot ad ogni startup\n    method = 'getMe'\n    url = `${url}bot${token}/${method}`\n} else if (method == 'getMe') {\n    //richiedo tutti messaggi\n    method = 'getUpdates'\n    url = `${url}bot${token}/${method}`\n} else {\n    //richiedo gli ultimi messaggi\n    if (update_id === undefined) update_id = -1\n    url = `${url}bot${token}/${method}?offset=${update_id}`\n}\n\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n\n//aggiorno le impostazioni\nsettings.url = url\nsettings.token = token\nsettings.method = method\nsettings.update_id = update_id\nglobal.set('telegram.receiver', settings)\nflow.set(\"method\", method)\n\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n\n//nome del bot\nvar bot_name = global.get('telegram.receiver.bot.first_name')\n\nif (!bot_name) {\n    node.status({ fill: \"blue\", shape: \"dot\", text: \"Request information about the bot...\" })\n} else {\n    let content_filter = (env.get(\"content_filter\")) ? ' + filter' : ''\n    node.status({ fill: \"blue\", shape: \"ring\", text: bot_name + \" is connected\" + content_filter })\n}\n\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n\n//invio la richiesta\nreturn { method: 'GET', url: url }",
        "outputs": 1,
        "noerr": 0,
        "initialize": "/**\n * ////////////////////////////////////////////////////\n * Telegram Bot API receiver\n * Subflow per Node-Red\n * node-telegram-bot-api-receiver\n * ////////////////////////////////////////////////////\n * Author: Bruno Leonardi <b.leonardi78@gmail.com>\n * ////////////////////////////////////////////////////\n */\n\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n\n//status\nnode.status({ fill: \"blue\", shape: \"ring\", text: \"Initialized\" })\n\n//reset del metodo\nflow.set(\"method\", null)\n\n//reset update_id\nglobal.set('telegram.receiver.update_id', -1)",
        "finalize": "",
        "libs": [],
        "x": 190,
        "y": 160,
        "wires": [
            [
                "5b2c6438b32488b0"
            ]
        ],
        "inputLabels": [
            "Input"
        ],
        "outputLabels": [
            "Http request"
        ]
    },
    {
        "id": "85c287a9917d09e6",
        "type": "trigger",
        "z": "799d902a165e50be",
        "name": "Disconnected",
        "op1": "",
        "op2": "disconnected",
        "op1type": "nul",
        "op2type": "str",
        "duration": "10",
        "extend": true,
        "overrideDelay": false,
        "units": "s",
        "reset": "",
        "bytopic": "all",
        "topic": "topic",
        "outputs": 1,
        "x": 530,
        "y": 40,
        "wires": [
            []
        ]
    },
    {
        "id": "de5da420710151e8",
        "type": "inject",
        "z": "799d902a165e50be",
        "name": "Startup status",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "",
        "x": 235,
        "y": 40,
        "wires": [
            [
                "85c287a9917d09e6"
            ]
        ],
        "l": false
    },
    {
        "id": "d868daa626a6f515",
        "type": "trigger",
        "z": "799d902a165e50be",
        "name": "Connected",
        "op1": "",
        "op2": "connected",
        "op1type": "nul",
        "op2type": "str",
        "duration": "1",
        "extend": false,
        "overrideDelay": false,
        "units": "ms",
        "reset": "",
        "bytopic": "all",
        "topic": "topic",
        "outputs": 1,
        "x": 540,
        "y": 90,
        "wires": [
            []
        ]
    },
    {
        "id": "b539f91be403db6c",
        "type": "delay",
        "z": "799d902a165e50be",
        "name": "",
        "pauseType": "rate",
        "timeout": "5",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": true,
        "allowrate": false,
        "outputs": 1,
        "x": 425,
        "y": 90,
        "wires": [
            [
                "d868daa626a6f515"
            ]
        ],
        "l": false
    },
    {
        "id": "1fe6ce616ba331fd",
        "type": "trigger",
        "z": "799d902a165e50be",
        "name": "Watchdog",
        "op1": "",
        "op2": "new_request",
        "op1type": "nul",
        "op2type": "str",
        "duration": "1",
        "extend": true,
        "overrideDelay": false,
        "units": "min",
        "reset": "",
        "bytopic": "all",
        "topic": "topic",
        "outputs": 1,
        "x": 190,
        "y": 230,
        "wires": [
            [
                "fb219cf60130f353"
            ]
        ]
    },
    {
        "id": "bbd6fcd41909a8ca",
        "type": "function",
        "z": "799d902a165e50be",
        "name": "Class Telegram Bot Api",
        "func": "//On Start",
        "outputs": 0,
        "noerr": 0,
        "initialize": "/**\n * Telegram Bot Api Javascript for Node-RED\n * Bruno Leonardi - b.leonardi78@gmail.com\n * Non tutti i metodi sono definiti!!!\n * Mancante Inline mode https://core.telegram.org/bots/api#inline-mode\n * Mancante Payments https://core.telegram.org/bots/api#payments\n * Mancante Telegram Passport https://core.telegram.org/bots/api#telegram-passport\n * Mancante Games https://core.telegram.org/bots/api#games\n */\nclass TelegramBotApi {\n    /**\n     * @param {{}} message Messaggio di Node-RED\n     */\n    constructor(message) {\n        this.message = message\n        this.url_base = global.get('telegram.url_base') || null\n        if (!this.url_base) node.error('Global variable \"telegram.url_base\" not found!')\n    }\n\n    /**\n     * Struttura variabile globale chat\n     */\n    chat = {\n        date: Date.now(),\n        pending: false,\n        type: 'unknown',\n        keycode: null,\n        message_id: null,\n        data: null\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //VARIABILI GLOBAL\n\n    /**\n     * Rirpistina i valori di default\n     * @param {string | number} chat_id ID della chat\n     * @return {boolean} Esito della scrittura\n     */\n    InitializeGlobalChat(chat_id) {\n        if (!chat_id) return false\n        try {\n            let path = `telegram.chat.${chat_id}`\n            if (global.get(path) === undefined) global.set(path, this.chat)\n            return true\n        } catch (error) {\n            node.error(error, msg)\n            return false\n        }\n    }\n\n    /**\n     * Rirpistina i valori di default\n     * @param {string | number} chat_id ID della chat\n     * @return {boolean} Esito della scrittura\n     */\n    ResetGlobalChat(chat_id) {\n        if (!chat_id) return false\n        try {\n            let path = `telegram.chat.${chat_id}`\n            global.set(path, this.chat)\n            return true\n        } catch (error) {\n            node.error(error, msg)\n            return false\n        }\n    }\n\n    /**\n     * Restituisce tutte le informazioni della chat\n     * @param {string | number} chat_id ID della chat\n     * @return {{}} Oggetto chat\n     */\n    GetGlobalChat(chat_id) {\n        if (!chat_id) return this.chat\n        try {\n            let path = `telegram.chat.${chat_id}`\n            return global.get(path) || this.chat\n        } catch (error) {\n            node.error(error, msg)\n            return this.chat\n        }\n    }\n\n    /**\n     * Memorizza tutte le informazioni della chat\n     * @param {string | number} chat_id ID della chat\n     * @param {{}} chat Oggetto chat\n     * @return {boolean} Esito della scrittura\n     */\n    SetGlobalChat(chat_id, chat) {\n        if (!chat_id || !chat) return false\n        try {\n            let path = `telegram.chat.${chat_id}`\n            global.set(path, chat)\n            return true\n        } catch (error) {\n            node.error(error, msg)\n            return false\n        }\n    }\n\n    /**\n     * Restituisce l'id dell'ultimo messaggio inviato\n     * @param {string | number} chat_id ID della chat\n     * @param {any} returnValue Valore di ritorno in caso di variabile undefined o errore\n     * @return {number | any} ID messaggio\n     */\n    GetGlobalMessageId(chat_id, returnValue = null) {\n        if (!chat_id) return returnValue\n        try {\n            let path = `telegram.chat.${chat_id}.message_id`\n            return global.get(path) || returnValue\n        } catch (error) {\n            node.error(error, msg)\n            return returnValue\n        }\n    }\n\n    /**\n     * Memorizza l'id dell'ultimo messaggio inviato\n     * @param {string | number} chat_id ID della chat\n     * @param {string | number | null} value Valore da assegnare\n     * @return {boolean} Esito della scrittura\n     */\n    SetGlobalMessageId(chat_id, value = null) {\n        if (!chat_id) return false\n        try {\n            this.InitializeGlobalChat(chat_id)\n            let path = `telegram.chat.${chat_id}.message_id`\n            global.set(path, value)\n            return true\n        } catch (error) {\n            node.error(error, msg)\n            return false\n        }\n    }\n\n    /**\n     * Restituisce la data in formato Unix dell'ultimo messaggio inviato\n     * @param {string | number} chat_id ID della chat\n     * @param {any} returnValue Valore di ritorno in caso di variabile undefined o errore\n     * @return {number | any} Data formato Unix\n     */\n    GetGlobalDate(chat_id, returnValue = null) {\n        if (!chat_id) return returnValue\n        try {\n            let path = `telegram.chat.${chat_id}.date`\n            return global.get(path) || returnValue\n        } catch (error) {\n            node.error(error, msg)\n            return returnValue\n        }\n    }\n\n    /**\n     * Memorizza la data in formato Unix dell'ultimo messaggio inviato\n     * @param {string | number} chat_id ID della chat\n     * @param {number} value Valore da assegnare, default data attuale\n     * @return {boolean} Esito della scrittura\n     */\n    SetGlobalDate(chat_id, value = Date.now()) {\n        if (!chat_id) return false\n        try {\n            this.InitializeGlobalChat(chat_id)\n            let path = `telegram.chat.${chat_id}.date`\n            global.set(path, value)\n            return true\n        } catch (error) {\n            node.error(error, msg)\n            return false\n        }\n    }\n\n    /**\n     * Restituisce la pendenza\n     * @param {string | number} chat_id ID della chat\n     * @param {any} returnValue Valore di ritorno in caso di variabile undefined o errore\n     * @return {boolean | any} Pendenza\n     */\n    GetGlobalPending(chat_id, returnValue = false) {\n        if (!chat_id) return returnValue\n        try {\n            let path = `telegram.chat.${chat_id}.pending`\n            return global.get(path) || returnValue\n        } catch (error) {\n            node.error(error, msg)\n            return returnValue\n        }\n    }\n\n    /**\n     * Memorizza la pendenza\n     * @param {string | number} chat_id ID della chat\n     * @param {boolean} value Valore da assegnare, default false\n     * @return {boolean} Esito della scrittura\n     */\n    SetGlobalPending(chat_id, value = false) {\n        if (!chat_id) return false\n        try {\n            this.InitializeGlobalChat(chat_id)\n            let path = `telegram.chat.${chat_id}.pending`\n            global.set(path, value)\n            return true\n        } catch (error) {\n            node.error(error, msg)\n            return false\n        }\n    }\n\n    /**\n     * Restituisce il codice tastiera\n     * @param {string | number} chat_id ID della chat\n     * @param {any} returnValue Valore di ritorno in caso di variabile undefined o errore\n     * @return {string | any} Codice tastiera\n     */\n    GetGlobalKeycode(chat_id, returnValue = null) {\n        if (!chat_id) return returnValue\n        try {\n            let path = `telegram.chat.${chat_id}.keycode`\n            return global.get(path) || returnValue\n        } catch (error) {\n            node.error(error, msg)\n            return returnValue\n        }\n    }\n\n    /**\n     * Memorizza il codice tastiera\n     * @param {string | number} chat_id ID della chat\n     * @param {string | number | null} value Valore da assegnare, default null\n     * @return {boolean} Esito della scrittura\n     */\n    SetGlobalKeycode(chat_id, value = null) {\n        if (!chat_id) return false\n        try {\n            this.InitializeGlobalChat(chat_id)\n            let path = `telegram.chat.${chat_id}.keycode`\n            global.set(path, value)\n            return true\n        } catch (error) {\n            node.error(error, msg)\n            return false\n        }\n    }\n\n    /**\n     * Restituisce il tipo messaggio\n     * @param {string | number} chat_id ID della chat\n     * @param {any} returnValue Valore di ritorno in caso di variabile undefined o errore\n     * @return {string | any} Tipo messaggio\n     */\n    GetGlobalType(chat_id, returnValue = null) {\n        if (!chat_id) return returnValue\n        try {\n            let path = `telegram.chat.${chat_id}.type`\n            return global.get(path) || returnValue\n        } catch (error) {\n            node.error(error, msg)\n            return returnValue\n        }\n    }\n\n    /**\n     * Memorizza il tipo di messaggio\n     * @param {string | number} chat_id ID della chat\n     * @param {string} value Valore da assegnare, default message\n     * @return {boolean} Esito della scrittura\n     */\n    SetGlobalType(chat_id, value = 'message') {\n        if (!chat_id) return false\n        try {\n            this.InitializeGlobalChat(chat_id)\n            let path = `telegram.chat.${chat_id}.type`\n            global.set(path, value)\n            return true\n        } catch (error) {\n            node.error(error, msg)\n            return false\n        }\n    }\n\n    /**\n     * Restituisce i dati del messaggio\n     * @param {string | number} chat_id ID della chat\n     * @param {any} returnValue Valore di ritorno in caso di variabile undefined o errore\n     * @return {string | {} | any} Dati del messaggio\n     */\n    GetGlobalData(chat_id, returnValue = null) {\n        if (!chat_id) return returnValue\n        try {\n            let path = `telegram.chat.${chat_id}.data`\n            return global.get(path) || returnValue\n        } catch (error) {\n            node.error(error, msg)\n            return returnValue\n        }\n    }\n\n    /**\n     * Memorizza i dati del messaggio\n     * @param {string | number} chat_id ID della chat\n     * @param {string | {} | [] | null} value Valore da assegnare, default null\n     * @return {boolean} Esito della scrittura\n     */\n    SetGlobalData(chat_id, value = null) {\n        if (!chat_id) return false\n        try {\n            this.InitializeGlobalChat(chat_id)\n            let path = `telegram.chat.${chat_id}.data`\n            global.set(path, value)\n            return true\n        } catch (error) {\n            node.error(error, msg)\n            return false\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //VARIABILI PERSONALIZZATE\n\n    /**\n     * Non gestito\n     */\n    UNMANAGED = 'unmanaged'\n\n    /**\n     * Sconosciuto\n     */\n    UNKNOWN = 'unknown'\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //JSON UTILITY\n\n    /**\n     * Converte JSON String >> Object\n     * @param {string} string JSON String\n     */\n    JSO(string) {\n        try {\n            if (!string || typeof string !== 'string') return string\n            return JSON.parse(string)\n        } catch (error) {\n            return string\n        }\n    }\n\n    /**\n     * Converte JSON Object >> String\n     * @param {object} object JSON Object\n     */\n    JSS(object) {\n        try {\n            if (!object || typeof object === 'string') return object\n            return JSON.stringify(object)\n        } catch (error) {\n            return object\n        }\n    }\n\n    /**\n     * Ricerca le chievi in un oggetto JSON e restituisce il valore o le propriet√†\n     * @param {string | string []} args args = 'key' || 'key.subkey.{what}' || 'key.*.{what}' || ['key', 'subkey', '{what}'] || ['key', '*', '{what}']\n     * @param {string | string []} args {what} = $type || $keys || $first_key || $last_key || $root || $boolean || $object || $...> (ultimo risultato)\n     * @param {NodeMessage | {} | []} object Oggetto sul quale effettuare la ricerca\n     */\n    JSGet(args, object = this.message) {\n        //creo una copia di object\n        object = RED.util.cloneMessage(object)\n\n        //definisci le chiavi\n        if (!args || (typeof args === 'string' && !args.trim())) {\n            return null\n        } else if (typeof args === 'string') {\n            //crea una array di chiavi\n            args = args.split('.')\n        } else if (!Array.isArray(args)) {\n            return null\n        }\n\n        //chiave primaria\n        var key = args[0]\n        if (!key) return null\n        if (typeof key !== 'string') return null\n        if (key == '') return null\n\n        //chiave secondaria\n        var subKey = (args.length == 2) ? args[1] : null\n        if (subKey && (subKey == '*' || subKey == '')) subKey = null\n\n        //risultato richiesto\n        var what = (args.length == 3) ? args[2] : ''\n\n        //definisci l'oggetto, deve essere un JSON\n        if (object && typeof object === 'object' && Array.isArray(object) && object.length > 0) {\n            //se √® una array lo converto\n            Object.assign({}, object)\n        } else if (typeof object === 'string') {\n            //se √® un JSON string lo converto\n            try {\n                object = JSON.parse(object)\n            } catch (error) {\n                return null\n            }\n        }\n\n        //se non √® un JSON restituisco null\n        if (!object || (Object.keys(object).length == 0 && object.constructor === Object)) {\n            return null\n        }\n\n        //risultati della ricerca\n        var result = null\n\n        //ricerca in profondit√† la chiave nell'oggetto\n        var searchDeep = function SearchDeep(/** @type {{ [x: string]: any; hasOwnProperty: (arg0: string) => any; }} */ object, /** @type {string} */ rootKeys) {\n            //percorso della chiave\n            var root = function GetRootKey(/** @type {string} */ addKey) {\n                return rootKeys ? `${rootKeys}.${addKey}` : addKey\n            }\n\n            //chiave trovata\n            if (object && object.hasOwnProperty(key)) {\n                //se vuota assegna key\n                if (!rootKeys) rootKeys = key\n\n                if (subKey && object[key].hasOwnProperty(subKey)) {\n                    result = {\n                        value: object[key][subKey],\n                        type: typeof object[key][subKey],\n                        keys: rootKeys.split('.').length,\n                        first_key: rootKeys.split('.')[0],\n                        last_key: (rootKeys.split('.').length > 0) ? rootKeys.split('.')[rootKeys.split('.').length - 1] : rootKeys.split('.')[0],\n                        root: rootKeys\n                    }\n                } else if (!subKey) {\n                    result = {\n                        value: object[key],\n                        type: typeof object[key],\n                        keys: rootKeys.split('.').length,\n                        first_key: rootKeys.split('.')[0],\n                        last_key: (rootKeys.split('.').length > 0) ? rootKeys.split('.')[rootKeys.split('.').length - 1] : rootKeys.split('.')[0],\n                        root: rootKeys\n                    }\n                }\n            }\n\n            //ricerca della chiave\n            if (!result || what.endsWith('>')) {\n                for (let k in object) {\n                    if (object.hasOwnProperty(k) && typeof object[k] === 'object') {\n                        searchDeep(object[k], root(k))\n                    }\n                }\n            }\n        }\n\n        //inizia la ricerca\n        searchDeep(object)\n\n        //restituisci il risultato\n        switch (what.replace('>', '')) {\n            case \"$type\":\n                return (!result ? null : result.type)\n            case \"$keys\":\n                return (!result ? null : result.keys)\n            case \"$first_key\":\n                return (!result ? null : result.first_key)\n            case \"$last_key\":\n                return (!result ? null : result.last_key)\n            case \"$root\":\n                return (!result ? null : result.root)\n            case \"$boolean\":\n                return !!result\n            case \"$object\":\n                return (!result ? null : result)\n            default:\n                return (!result ? null : result.value)\n        }\n    }\n\n    /**\n     * Determina se il contenuto del messaggio √® superiore al limite massimo di 4096\n     * @param {string} content Contenuto del messaggio da valutare\n     * @param {number} limit Limite massimo per invio del messaggio, default 3072\n     */\n    IsOverSize(content, limit = 3072) {\n        limit = (limit > 4096) ? 4096 : limit\n        return (Buffer.from(content).length > limit)\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //TELEGRAM METHODS\n\n    /**\n     * Metodo per la ricezione e l'invio di messaggi\n     * https://core.telegram.org/bots/api#available-methods\n     */\n    METHOD = {\n        //GET\n        getMe: \"getMe\",\n        getUpdates: \"getUpdates\",\n        //POST\n        sendMessage: \"sendMessage\",\n        forwardMessage: \"forwardMessage\",\n        copyMessage: \"copyMessage\",\n        sendPhoto: \"sendPhoto\",\n        sendAudio: \"sendAudio\",\n        sendDocument: \"sendDocument\",\n        sendVideo: \"sendVideo\",\n        sendAnimation: \"sendAnimation\",\n        sendVoice: \"sendVoice\",\n        sendVideoNote: \"sendVideoNote\",\n        sendLocation: \"sendLocation\",\n        sendVenue: \"sendVenue\",\n        sendContact: \"sendContact\",\n        sendPoll: 'sendPoll',\n        sendDice: \"sendDice\",\n        sendChatAction: \"sendChatAction\",\n        getUserProfilePhotos: 'getUserProfilePhotos',\n        getFile: 'getFile',\n        banChatMember: 'banChatMember',\n        unbanChatMember: 'unbanChatMember',\n        restrictChatMember: 'restrictChatMember',\n        promoteChatMember: 'promoteChatMember',\n        setChatAdministratorCustomTitle: 'setChatAdministratorCustomTitle',\n        banChatSenderChat: 'banChatSenderChat',\n        unbanChatSenderChat: 'unbanChatSenderChat',\n        setChatPermissions: 'setChatPermissions',\n        exportChatInviteLink: 'exportChatInviteLink',\n        createChatInviteLink: 'createChatInviteLink',\n        editChatInviteLink: 'editChatInviteLink',\n        revokeChatInviteLink: 'revokeChatInviteLink',\n        approveChatJoinRequest: 'approveChatJoinRequest',\n        declineChatJoinRequest: 'declineChatJoinRequest',\n        setChatPhoto: 'setChatPhoto',\n        deleteChatPhoto: 'deleteChatPhoto',\n        setChatTitle: 'setChatTitle',\n        setChatDescription: 'setChatDescription',\n        pinChatMessage: 'pinChatMessage',\n        unpinChatMessage: 'unpinChatMessage',\n        unpinAllChatMessages: 'unpinAllChatMessages',\n        leaveChat: 'leaveChat',\n        getChat: 'getChat',\n        getChatAdministrators: 'getChatAdministrators',\n        getChatMemberCount: 'getChatMemberCount',\n        getChatMember: 'getChatMember',\n        setChatStickerSet: 'setChatStickerSet',\n        deleteChatStickerSet: 'deleteChatStickerSet',\n        answerCallbackQuery: 'answerCallbackQuery',\n        setMyCommands: 'setMyCommands',\n        deleteMyCommands: 'deleteMyCommands',\n        getMyCommands: 'getMyCommands',\n        setChatMenuButton: 'setChatMenuButton',\n        getChatMenuButton: 'getChatMenuButton',\n        setMyDefaultAdministratorRights: 'setMyDefaultAdministratorRights',\n        getMyDefaultAdministratorRights: 'getMyDefaultAdministratorRights',\n        sendSticker: 'sendSticker',\n        getStickerSet: 'getStickerSet',\n        uploadStickerFile: 'uploadStickerFile',\n        editMessageText: 'editMessageText',\n        editMessageCaption: 'editMessageCaption',\n        editMessageMedia: 'editMessageMedia',\n        editMessageReplyMarkup: 'editMessageReplyMarkup',\n        stopPoll: 'stopPoll',\n        deleteMessage: 'deleteMessage'\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //TELEGRAM UPDATE MESSAGE\n\n    /**\n     * Tipologia messaggio di update\n     * https://core.telegram.org/bots/api#update\n     */\n    MESSAGE_TYPE = {\n        message: 'message',\n        edited_message: 'edited_message',\n        channel_post: 'channel_post',\n        edited_channel_post: 'edited_channel_post',\n        inline_query: 'inline_query',\n        chosen_inline_result: 'chosen_inline_result',\n        callback_query: 'callback_query',\n        shipping_query: 'shipping_query',\n        pre_checkout_query: 'pre_checkout_query',\n        poll: 'poll',\n        poll_answer: 'poll_answer',\n        my_chat_member: 'my_chat_member',\n        chat_member: 'chat_member',\n        chat_join_request: 'chat_join_request',\n        //si trovano dentro message\n        reply_to_message: 'reply_to_message',\n        pinned_message: 'pinned_message'\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //TELEGRAM CONTENT TYPE\n\n    /**\n     * Tipologia contenuto del messaggio di update\n     * https://core.telegram.org/bots/api#message\n     */\n    CONTENT_TYPE = {\n        text: 'text',\n        animation: 'animation',\n        audio: 'audio',\n        document: 'document',\n        photo: 'photo',\n        sticker: 'sticker',\n        video: 'video',\n        video_note: 'video_note',\n        voice: 'voice',\n        contact: 'contact',\n        dice: 'dice',\n        game: 'game',\n        poll: 'poll',\n        venue: 'venue',\n        location: 'location',\n        new_chat_members: 'new_chat_members',\n        left_chat_member: 'left_chat_member',\n        new_chat_title: 'new_chat_title',\n        new_chat_photo: 'new_chat_photo',\n        delete_chat_photo: 'delete_chat_photo',\n        group_chat_created: 'group_chat_created',\n        supergroup_chat_created: 'supergroup_chat_created',\n        channel_chat_created: 'channel_chat_created',\n        message_auto_delete_timer_changed: 'message_auto_delete_timer_changed',\n        migrate_to_chat_id: 'migrate_to_chat_id',\n        migrate_from_chat_id: 'migrate_from_chat_id',\n        pinned_message: 'pinned_message',\n        invoice: 'invoice',\n        successful_payment: 'successful_payment',\n        connected_website: 'connected_website',\n        passport_data: 'passport_data',\n        proximity_alert_triggered: 'proximity_alert_triggered',\n        video_chat_scheduled: 'video_chat_scheduled',\n        video_chat_started: 'video_chat_started',\n        video_chat_ended: 'video_chat_ended',\n        video_chat_participants_invited: 'video_chat_participants_invited',\n        web_app_data: 'web_app_data',\n        chat_invite_link: 'chat_invite_link',\n        chat_member_updated: 'chat_member_updated'\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //TELEGRAM CHAT ACTION\n\n    /**\n     * Tipologia di azione in chat\n     * https://core.telegram.org/bots/api#sendchataction\n     */\n    CHAT_ACTION = {\n        typing: 'typing',\n        find_location: 'find_location',\n        upload_photo: 'upload_photo',\n        upload_document: 'upload_document',\n        upload_video_note: 'upload_video_note',\n        record_audio: 'record_audio',\n        record_video: 'record_video',\n        record_video_note: 'record_video_note'\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //TELEGRAM BOT COMMANDS\n\n    /**\n     * Bot Command Scope con {{template}}\n     * https://core.telegram.org/bots/api#botcommandscope\n     */\n    BOT_COMMAND_SCOPE = {\n        default: this.JSS({ type: 'default' }),\n        all_private_chats: this.JSS({ type: 'all_private_chats' }),\n        all_group_chats: this.JSS({ type: 'all_group_chats' }),\n        all_chat_administrators: this.JSS({ type: 'all_chat_administrators' }),\n        chat: this.JSS({ type: 'chat', chat_id: '{{chat_id}}' }),\n        chat_administrators: this.JSS({ type: 'chat_administrators', chat_id: '{{chat_id}}' }),\n        chat_member: this.JSS({ type: 'chat_member', chat_id: '{{chat_id}}', user_id: '{{user_id}}' })\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //ReplyKeyboardMarkup\n\n    /**\n     * Struttura ReplyKeyboardMarkup\n     * https://core.telegram.org/bots/api#replykeyboardmarkup\n     */\n    ReplyKeyboardMarkup = {\n        keyboard: [[{ text: 'Pulsante 1' }, { text: 'Pulsante 2' }]],\n        is_persistent: false,\n        resize_keyboard: true,\n        one_time_keyboard: false,\n        input_field_placeholder: 'Seleziona un pulsante',\n        selective: true\n    }\n\n    /**\n     * Struttura KeyboardButton\n     * https://core.telegram.org/bots/api#keyboardbutton\n     */\n    KeyboardButton = [\n        {\n            text: 'Pulsante 1',\n            request_contact: false,\n            request_location: false\n            //request_poll\n            //web_app\n        }\n    ]\n\n    /**\n     * Struttura ReplyKeyboardRemove\n     * https://core.telegram.org/bots/api#replykeyboardremove\n     */\n    ReplyKeyboardRemove = [\n        {\n            remove_keyboard: true,\n            selective: true\n        }\n    ]\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //FUNCTION\n\n    /**\n     * Restituisce l'url completa per l'invio del messaggio\n     */\n    GetUrl() {\n        if (!this.message) return null\n        const message = this.message.forward || this.message.telegram || null\n        if (!message) return null\n        message.method = message.method || this.GetMethod() || null\n        if (!message.method) return null\n        let options = message.options || {}\n\n        if (message.method == this.METHOD.answerCallbackQuery) {\n            return this.answerCallbackQuery(message.callback_query_id, options)\n        } else if (message.method == this.METHOD.approveChatJoinRequest) {\n            return this.approveChatJoinRequest(message.chat_id, message.user_id)\n        } else if (message.method == this.METHOD.banChatMember) {\n            return this.banChatMember(message.chat_id, message.user_id, options)\n        } else if (message.method == this.METHOD.banChatSenderChat) {\n            return this.banChatSenderChat(message.chat_id, message.sender_chat_id || message.chat_id)\n        } else if (message.method == this.METHOD.copyMessage) {\n            return this.copyMessage(message.chat_id, message.from_chat_id || message.chat_id, message.message_id, options)\n        } else if (message.method == this.METHOD.createChatInviteLink) {\n            return this.createChatInviteLink(message.chat_id, options)\n        } else if (message.method == this.METHOD.declineChatJoinRequest) {\n            return this.declineChatJoinRequest(message.chat_id, message.user_id)\n        } else if (message.method == this.METHOD.deleteChatPhoto) {\n            return this.deleteChatPhoto(message.chat_id)\n        } else if (message.method == this.METHOD.deleteChatStickerSet) {\n            return this.deleteChatStickerSet(message.chat_id)\n        } else if (message.method == this.METHOD.deleteMessage) {\n            return this.deleteMessage(message.chat_id, message.message_id)\n        } else if (message.method == this.METHOD.deleteMyCommands) {\n            return this.deleteMyCommands(options)\n        } else if (message.method == this.METHOD.editChatInviteLink) {\n            return this.editChatInviteLink(message.chat_id, message.invite_link, options)\n        } else if (message.method == this.METHOD.editMessageCaption) {\n            return this.editMessageCaption(message.caption || message.content, options)\n        } else if (message.method == this.METHOD.editMessageMedia) {\n            return this.editMessageMedia(message.media || message.content, options)\n        } else if (message.method == this.METHOD.editMessageReplyMarkup) {\n            return this.editMessageReplyMarkup(message.media || message.content, options)\n        } else if (message.method == this.METHOD.editMessageText) {\n            return this.editMessageText(message.text || message.content, options)\n        } else if (message.method == this.METHOD.exportChatInviteLink) {\n            return this.exportChatInviteLink(message.chat_id)\n        } else if (message.method == this.METHOD.forwardMessage) {\n            return this.forwardMessage(message.chat_id, message.from_chat_id || message.chat_id, message.message_id, options)\n        } else if (message.method == this.METHOD.getChat) {\n            return this.getChat(message.chat_id)\n        } else if (message.method == this.METHOD.getChatAdministrators) {\n            return this.getChatAdministrators(message.chat_id)\n        } else if (message.method == this.METHOD.getChatMember) {\n            return this.getChatMember(message.chat_id, message.user_id)\n        } else if (message.method == this.METHOD.getChatMemberCount) {\n            return this.getChatMemberCount(message.chat_id)\n        } else if (message.method == this.METHOD.getChatMenuButton) {\n            return this.getChatMenuButton(options)\n        } else if (message.method == this.METHOD.getFile) {\n            return this.getFile(message.file_id || message.content)\n        } else if (message.method == this.METHOD.getMyCommands) {\n            return this.getMyCommands(options)\n        } else if (message.method == this.METHOD.getMyDefaultAdministratorRights) {\n            return this.getMyDefaultAdministratorRights(options)\n        } else if (message.method == this.METHOD.getStickerSet) {\n            return this.getStickerSet(message.name)\n        } else if (message.method == this.METHOD.getUserProfilePhotos) {\n            return this.getUserProfilePhotos(message.user_id, options)\n        } else if (message.method == this.METHOD.leaveChat) {\n            return this.leaveChat(message.chat_id)\n        } else if (message.method == this.METHOD.pinChatMessage) {\n            return this.pinChatMessage(message.chat_id, message.message_id, options)\n        } else if (message.method == this.METHOD.promoteChatMember) {\n            return this.promoteChatMember(message.chat_id, message.user_id, options)\n        } else if (message.method == this.METHOD.restrictChatMember) {\n            return this.restrictChatMember(message.chat_id, message.user_id, message.permissions, options)\n        } else if (message.method == this.METHOD.revokeChatInviteLink) {\n            return this.revokeChatInviteLink(message.chat_id, message.invite_link)\n        } else if (message.method == this.METHOD.sendAnimation) {\n            return this.sendAnimation(message.chat_id, message.animation || message.content, options)\n        } else if (message.method == this.METHOD.sendAudio) {\n            return this.sendAudio(message.chat_id, message.audio || message.content, options)\n        } else if (message.method == this.METHOD.sendChatAction) {\n            return this.sendChatAction(message.chat_id, message.action || this.GetAction(message.content_type) || this.CHAT_ACTION.typing)\n        } else if (message.method == this.METHOD.sendContact) {\n            return this.sendContact(message.chat_id, message.phone_number, message.first_name || message.user.first_name, options)\n        } else if (message.method == this.METHOD.sendDice) {\n            return this.sendDice(message.chat_id, options)\n        } else if (message.method == this.METHOD.sendDocument) {\n            return this.sendDocument(message.chat_id, message.document || message.content, options)\n        } else if (message.method == this.METHOD.sendLocation) {\n            return this.sendLocation(message.chat_id, message.latitude, message.longitude, options)\n        } else if (message.method == this.METHOD.sendMessage) {\n            return this.sendMessage(message.chat_id, message.text || message.content, options)\n        } else if (message.method == this.METHOD.sendPhoto) {\n            return this.sendPhoto(message.chat_id, message.photo || message.content, options)\n        } else if (message.method == this.METHOD.sendPoll) {\n            return this.sendPoll(message.chat_id, message.question, message.pool_options, options)\n        } else if (message.method == this.METHOD.sendSticker) {\n            return this.sendSticker(message.chat_id, message.sticker || message.content, options)\n        } else if (message.method == this.METHOD.sendVenue) {\n            return this.sendVenue(message.chat_id, message.latitude, message.longitude, message.title, message.address, options)\n        } else if (message.method == this.METHOD.sendVideo) {\n            return this.sendVideo(message.chat_id, message.video || message.content, options)\n        } else if (message.method == this.METHOD.sendDocument) {\n            return this.sendDocument(message.chat_id, message.document || message.content, options)\n        } else if (message.method == this.METHOD.sendVideoNote) {\n            return this.sendVideoNote(message.chat_id, message.video_note || message.content, options)\n        } else if (message.method == this.METHOD.sendVoice) {\n            return this.sendVoice(message.chat_id, message.voice || message.content, options)\n        } else if (message.method == this.METHOD.setChatAdministratorCustomTitle) {\n            return this.setChatAdministratorCustomTitle(message.chat_id, message.user_id, message.custom_title)\n        } else if (message.method == this.METHOD.setChatDescription) {\n            return this.setChatDescription(message.chat_id, message.description)\n        } else if (message.method == this.METHOD.setChatMenuButton) {\n            return this.setChatMenuButton(options)\n        } else if (message.method == this.METHOD.setChatPermissions) {\n            return this.setChatPermissions(message.chat_id, message.permissions)\n        } else if (message.method == this.METHOD.setChatPhoto) {\n            return this.setChatPhoto(message.chat_id, message.photo)\n        } else if (message.method == this.METHOD.setChatStickerSet) {\n            return this.setChatStickerSet(message.chat_id, message.sticker_set_name)\n        } else if (message.method == this.METHOD.setChatTitle) {\n            return this.setChatTitle(message.chat_id, message.title)\n        } else if (message.method == this.METHOD.setMyCommands) {\n            return this.setMyCommands(message.commands, options)\n        } else if (message.method == this.METHOD.setMyDefaultAdministratorRights) {\n            return this.setMyDefaultAdministratorRights(options)\n        } else if (message.method == this.METHOD.stopPoll) {\n            return this.stopPoll(message.chat_id, message.message_id, options)\n        } else if (message.method == this.METHOD.unbanChatMember) {\n            return this.unbanChatMember(message.chat_id, message.user_id, options)\n        } else if (message.method == this.METHOD.unbanChatSenderChat) {\n            return this.unbanChatSenderChat(message.chat_id, message.sender_chat_id)\n        } else if (message.method == this.METHOD.unpinAllChatMessages) {\n            return this.unpinAllChatMessages(message.chat_id)\n        } else if (message.method == this.METHOD.unpinChatMessage) {\n            return this.unpinChatMessage(message.chat_id, message.message_id)\n        } else if (message.method == this.METHOD.uploadStickerFile) {\n            return this.uploadStickerFile(message.user_id, message.png_sticker)\n        } else {\n            return null\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //FUNCTION\n\n    /**\n     * Restituisce il metodo in base al tipo di messaggio o url\n     * @param {string} url Url da valutare\n     * @return {string} Metodo di Telegram\n     */\n    GetMethod(url = null) {\n        //in base all'url se impostata\n        if (url) {\n            var re\n            var methods = Object.values(this.METHOD)\n            for (let i = 0; i < methods.length; i++) {\n                re = new RegExp(`\\/${methods[i]}\\?`, 'i')\n                if (re.test(url)) return methods[i]\n            }\n            return this.UNKNOWN\n        }\n\n        //in base al messaggio\n        let message = this.message\n        if (!message) return null\n\n        if (message.telegram) {\n            //in base al tipo di contenuto (msg.telegram.content_type)\n            if (message.telegram.content_type == this.CONTENT_TYPE.animation) return this.METHOD.sendAnimation\n            if (message.telegram.content_type == this.CONTENT_TYPE.audio) return this.METHOD.sendAudio\n            if (message.telegram.content_type == this.CONTENT_TYPE.contact) return this.METHOD.sendContact\n            if (message.telegram.content_type == this.CONTENT_TYPE.dice) return this.METHOD.sendDice\n            if (message.telegram.content_type == this.CONTENT_TYPE.document) return this.METHOD.sendDocument\n            if (message.telegram.content_type == this.CONTENT_TYPE.location) return this.METHOD.sendLocation\n            if (message.telegram.content_type == this.CONTENT_TYPE.photo) return this.METHOD.sendPhoto\n            if (message.telegram.content_type == this.CONTENT_TYPE.sticker) return this.METHOD.sendSticker\n            if (message.telegram.content_type == this.CONTENT_TYPE.text) return this.METHOD.sendMessage\n            if (message.telegram.content_type == this.CONTENT_TYPE.venue) return this.METHOD.sendVenue\n            if (message.telegram.content_type == this.CONTENT_TYPE.video) return this.METHOD.sendVideo\n            if (message.telegram.content_type == this.CONTENT_TYPE.video_note) return this.METHOD.sendVideoNote\n            if (message.telegram.content_type == this.CONTENT_TYPE.voice) return this.METHOD.sendVoice\n            //in base al tipo di messaggio (msg.telegram.message_type)\n            if (message.telegram.message_type == this.MESSAGE_TYPE.callback_query) return this.METHOD.answerCallbackQuery\n            if (message.telegram.message_type == this.MESSAGE_TYPE.channel_post) return null\n            if (message.telegram.message_type == this.MESSAGE_TYPE.chat_join_request) return null\n            if (message.telegram.message_type == this.MESSAGE_TYPE.chat_member) return null\n            if (message.telegram.message_type == this.MESSAGE_TYPE.chosen_inline_result) return null\n            if (message.telegram.message_type == this.MESSAGE_TYPE.edited_channel_post) return this.METHOD.sendMessage\n            if (message.telegram.message_type == this.MESSAGE_TYPE.edited_message) return this.METHOD.sendMessage\n            if (message.telegram.message_type == this.MESSAGE_TYPE.inline_query) return null\n            if (message.telegram.message_type == this.MESSAGE_TYPE.message) return this.METHOD.sendMessage\n            if (message.telegram.message_type == this.MESSAGE_TYPE.my_chat_member) return null\n            if (message.telegram.message_type == this.MESSAGE_TYPE.pinned_message) return this.METHOD.sendMessage\n            if (message.telegram.message_type == this.MESSAGE_TYPE.poll) return null\n            if (message.telegram.message_type == this.MESSAGE_TYPE.poll_answer) return null\n            if (message.telegram.message_type == this.MESSAGE_TYPE.pre_checkout_query) return null\n            if (message.telegram.message_type == this.MESSAGE_TYPE.reply_to_message) return this.METHOD.sendMessage\n            if (message.telegram.message_type == this.MESSAGE_TYPE.shipping_query) return null\n        } else {\n            //in base al tipo di messaggio (msg.update)\n            if (message.callback_query == this.MESSAGE_TYPE.callback_query) return this.METHOD.answerCallbackQuery\n            if (message.channel_post == this.MESSAGE_TYPE.channel_post) return null\n            if (message.chat_join_request == this.MESSAGE_TYPE.chat_join_request) return null\n            if (message.chat_member == this.MESSAGE_TYPE.chat_member) return null\n            if (message.chosen_inline_result == this.MESSAGE_TYPE.chosen_inline_result) return null\n            if (message.edited_channel_post == this.MESSAGE_TYPE.edited_channel_post) return this.METHOD.sendMessage\n            if (message.edited_message == this.MESSAGE_TYPE.edited_message) return this.METHOD.sendMessage\n            if (message.inline_query == this.MESSAGE_TYPE.inline_query) return null\n            if (message.message == this.MESSAGE_TYPE.message) return this.METHOD.sendMessage\n            if (message.my_chat_member == this.MESSAGE_TYPE.my_chat_member) return null\n            if (message.pinned_message == this.MESSAGE_TYPE.pinned_message) return this.METHOD.sendMessage\n            if (message.poll == this.MESSAGE_TYPE.poll) return null\n            if (message.poll_answer == this.MESSAGE_TYPE.poll_answer) return null\n            if (message.pre_checkout_query == this.MESSAGE_TYPE.pre_checkout_query) return null\n            if (message.reply_to_message == this.MESSAGE_TYPE.reply_to_message) return this.METHOD.sendMessage\n            if (message.shipping_query == this.MESSAGE_TYPE.shipping_query) return null\n        }\n        return null\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //FUNCTION\n\n    /**\n     * Stabilisce il contenuto dal messaggio\n     * @param {{}} message Messaggio di Node-RED (msg)\n     * @return {string} Contenuto messaggio\n     */\n    GetContent(message = this.message) {\n        let content = null\n        let content_type = this.GetContentType(message)\n        if (content_type != this.UNKNOWN) {\n            if (content_type == this.CONTENT_TYPE.text) {\n                content = this.JSGet(content_type, message)\n            } else {\n                content = this.JSGet('file_id', message)\n            }\n            if (!content) content = this.JSGet(content_type, message)\n        }\n        return content || this.UNKNOWN\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //FUNCTION\n\n    /**\n     * Stabilisce il tipo di contenuto dal messaggio\n     * @param {{}} message Messaggio di Node-RED (msg)\n     * @return {string} Tipologia contenuto messaggio\n     */\n    GetContentType(message = this.message) {\n        if (!message) return this.UNKNOWN\n        if (message.content_type) return message.content_type\n        if (message.telegram && message.telegram.content_type) return message.telegram.content_type\n        for (let content_type in this.CONTENT_TYPE) {\n            if (message.hasOwnProperty(content_type)) return content_type\n        }\n        return this.UNKNOWN\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //FUNCTION\n\n    /**\n     * Stabilisce l'azione dal messaggio\n     * @param {string | {}} object Tipologia contenuto o messaggio di Node-RED (msg)\n     * @return {string} Tipologia di azione\n     */\n    GetAction(object = null) {\n        if (object === null || object === undefined) {\n            return this.CHAT_ACTION.typing\n        } else if (typeof object === 'object') {\n            object = this.GetContentType(object)\n        } else if (typeof object === 'string') {\n            if (object.startsWith('http')) {\n                object = this.GetMethod(object)\n            } else {\n                for (let content_type in this.CONTENT_TYPE) {\n                    if (object == content_type) {\n                        object = content_type\n                        break\n                    }\n                }\n            }\n        } else {\n            return this.CHAT_ACTION.typing\n        }\n\n        switch (object) {\n            case this.CONTENT_TYPE.text:\n                return this.CHAT_ACTION.typing\n            case this.METHOD.sendMessage:\n                return this.CHAT_ACTION.typing\n            case this.CONTENT_TYPE.document:\n                return this.CHAT_ACTION.upload_document\n            case this.METHOD.sendDocument:\n                return this.CHAT_ACTION.upload_document\n            case this.CONTENT_TYPE.photo:\n                return this.CHAT_ACTION.upload_photo\n            case this.CONTENT_TYPE.animation:\n                return this.CHAT_ACTION.upload_photo\n            case this.METHOD.sendPhoto:\n                return this.CHAT_ACTION.upload_photo\n            case this.METHOD.sendAnimation:\n                return this.CHAT_ACTION.upload_photo\n            case this.CONTENT_TYPE.video_note:\n                return this.CHAT_ACTION.upload_video_note\n            case this.METHOD.sendVideoNote:\n                return this.CHAT_ACTION.upload_video_note\n            case this.CONTENT_TYPE.audio:\n                return this.CHAT_ACTION.record_audio\n            case this.CONTENT_TYPE.voice:\n                return this.CHAT_ACTION.record_audio\n            case this.METHOD.sendAudio:\n                return this.CHAT_ACTION.record_audio\n            case this.METHOD.sendVoice:\n                return this.CHAT_ACTION.record_audio\n            case this.CONTENT_TYPE.video:\n                return this.CHAT_ACTION.record_video\n            case this.METHOD.sendVideo:\n                return this.CHAT_ACTION.record_video\n            case this.CONTENT_TYPE.location:\n                return this.CHAT_ACTION.find_location\n            case this.CONTENT_TYPE.venue:\n                return this.CHAT_ACTION.find_location\n            case this.METHOD.sendLocation:\n                return this.CHAT_ACTION.find_location\n            case this.METHOD.sendVenue:\n                return this.CHAT_ACTION.find_location\n            default:\n                return this.CHAT_ACTION.typing\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //FUNCTION\n\n    /**\n    * Stabilisce l'id della chat da una stringa\n    * @param {string} string Stringa da valutare\n    * @param {any} returnValue Valore di ritorno in caso di null\n    */\n    GetChatId(string, returnValue = null) {\n        if (!string) return returnValue\n        if (typeof string !== 'string') string = string.toString()\n        let match = string.match(/chat_id=(.*?)&/i)\n        return (match && match.length > 0) ? match[1] : returnValue\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //FUNCTION\n\n    /**\n    * Stabilisce l'id del messaggio da una stringa\n    * @param {string} string Stringa da valutare\n    * @param {any} returnValue Valore di ritorno in caso di null\n    */\n    GetMessageId(string, returnValue = null) {\n        if (!string) return returnValue\n        if (typeof string !== 'string') string = string.toString()\n        let match = string.match(/message_id=(.*?)$/i)\n        return (match && match.length > 0) ? match[1] : returnValue\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //FUNCTION\n\n    /**\n     * Restituisce una Array contenente i pulsanti della tastiera\n     * @param {any[]} keyboard Tastiera da valutare\n     */\n    GetKeyboardButtons(keyboard) {\n        if (typeof keyboard === 'string') return []\n        let buttons = []\n\n        for (let i = 0; i < keyboard.length; i++) {\n            let button = Object.values(keyboard[i])\n            for (let i = 0; i < button.length; i++) {\n                if (button[i].callback_data) {\n                    buttons.push(button[i].callback_data)\n                } else if (button[i].text) {\n                    buttons.push(button[i].text)\n                } else {\n                    if (typeof button[i] !== 'object') buttons.push(button[i])\n                }\n            }\n        }\n\n        return buttons\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //FUNCTION\n\n    /**\n     * Verifica se la risposta √® corretta\n     * @param {string} answer Risposta\n     * @param {string | []} answers Risposte\n     */\n    AnswerIsCorrect(answer, answers) {\n        if (answer === null || answer === undefined || (typeof answer === 'string' && answer.trim() == '')) return false\n        if (answers === null || answers === undefined || answers.length == 0) return false\n        if (typeof answer === 'string' && Array.isArray(answers)) {\n            return answers.includes(answer)\n        } else if (typeof answer === 'string' && typeof answers === 'string') {\n            return (answer.trim() == answers.trim())\n        } else {\n            return (answer == answers)\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //TELEGRAM METHODS FUNCTION\n\n    /**\n     * https://core.telegram.org/bots/api#sendmessage\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string} text Contenuto da inviare\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    sendMessage(chat_id, text, options = {}) {\n        let url = `${this.url_base}sendMessage?chat_id=${chat_id}&text=${text}`\n        if (options.message_thread_id) url += `&message_thread_id=${options.message_thread_id}`\n        if (options.parse_mode) url += `&parse_mode=${options.parse_mode}`\n        if (options.entities) url += `&entities=${this.JSS(options.entities)}`\n        if (options.disable_web_page_preview) url += `&disable_web_page_preview=${options.disable_web_page_preview}`\n        if (options.disable_notification) url += `&disable_notification=${options.disable_notification}`\n        if (options.protect_content) url += `&protect_content=${options.protect_content}`\n        if (options.reply_to_message_id) url += `&reply_to_message_id=${options.reply_to_message_id}`\n        if (options.allow_sending_without_reply) url += `&allow_sending_without_reply=${options.allow_sending_without_reply}`\n        if (options.reply_markup) url += `&reply_markup=${this.JSS(options.reply_markup)}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#forwardmessage\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string | number} from_chat_id Identificativo chat di provenienza\n     * @param {string | number} message_id Identificativo messaggio\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    forwardMessage(chat_id, from_chat_id, message_id, options = {}) {\n        let url = `${this.url_base}forwardMessage?chat_id=${chat_id}&from_chat_id=${from_chat_id}&message_id=${message_id}`\n        if (options.message_thread_id) url += `&message_thread_id=${options.message_thread_id}`\n        if (options.disable_notification) url += `&disable_notification=${options.disable_notification}`\n        if (options.protect_content) url += `&protect_content=${options.protect_content}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#copymessage\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string | number} from_chat_id Identificativo chat di provenienza\n     * @param {string | number} message_id Identificativo messaggio\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    copyMessage(chat_id, from_chat_id, message_id, options = {}) {\n        let url = `${this.url_base}copyMessage?chat_id=${chat_id}&from_chat_id=${from_chat_id}&message_id=${message_id}`\n        if (options.message_thread_id) url += `&message_thread_id=${options.message_thread_id}`\n        if (options.caption) url += `&caption=${options.caption}`\n        if (options.parse_mode) url += `&parse_mode=${options.parse_mode}`\n        if (options.caption_entities) url += `&caption_entities=${this.JSS(options.caption_entities)}`\n        if (options.disable_notification) url += `&disable_notification=${options.disable_notification}`\n        if (options.protect_content) url += `&protect_content=${options.protect_content}`\n        if (options.reply_to_message_id) url += `&reply_to_message_id=${options.reply_to_message_id}`\n        if (options.allow_sending_without_reply) url += `&allow_sending_without_reply=${options.allow_sending_without_reply}`\n        if (options.reply_markup) url += `&reply_markup=${this.JSS(options.reply_markup)}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#sendphoto\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string} photo Contenuto da inviare\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    sendPhoto(chat_id, photo, options = {}) {\n        let url = `${this.url_base}sendPhoto?chat_id=${chat_id}&photo=${photo}`\n        if (options.message_thread_id) url += `&message_thread_id=${options.message_thread_id}`\n        if (options.caption) url += `&caption=${options.caption}`\n        if (options.parse_mode) url += `&parse_mode=${options.parse_mode}`\n        if (options.caption_entities) url += `&caption_entities=${this.JSS(options.caption_entities)}`\n        if (options.has_spoiler) url += `&has_spoiler=${options.has_spoiler}`\n        if (options.disable_notification) url += `&disable_notification=${options.disable_notification}`\n        if (options.protect_content) url += `&protect_content=${options.protect_content}`\n        if (options.reply_to_message_id) url += `&reply_to_message_id=${options.reply_to_message_id}`\n        if (options.allow_sending_without_reply) url += `&allow_sending_without_reply=${options.allow_sending_without_reply}`\n        if (options.reply_markup) url += `&reply_markup=${this.JSS(options.reply_markup)}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#sendaudio\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string} audio Contenuto da inviare\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    sendAudio(chat_id, audio, options = {}) {\n        let url = `${this.url_base}sendAudio?chat_id=${chat_id}&audio=${audio}`\n        if (options.message_thread_id) url += `&message_thread_id=${options.message_thread_id}`\n        if (options.caption) url += `&caption=${options.caption}`\n        if (options.parse_mode) url += `&parse_mode=${options.parse_mode}`\n        if (options.caption_entities) url += `&caption_entities=${this.JSS(options.caption_entities)}`\n        if (options.duration) url += `&duration=${options.duration}`\n        if (options.performer) url += `&performer=${options.performer}`\n        if (options.title) url += `&title=${options.title}`\n        if (options.thumb) url += `&thumb=${options.thumb}`\n        if (options.disable_notification) url += `&disable_notification=${options.disable_notification}`\n        if (options.protect_content) url += `&protect_content=${options.protect_content}`\n        if (options.reply_to_message_id) url += `&reply_to_message_id=${options.reply_to_message_id}`\n        if (options.allow_sending_without_reply) url += `&allow_sending_without_reply=${options.allow_sending_without_reply}`\n        if (options.reply_markup) url += `&reply_markup=${this.JSS(options.reply_markup)}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#senddocument\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string} document Contenuto da inviare\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    sendDocument(chat_id, document, options = {}) {\n        let url = `${this.url_base}sendDocument?chat_id=${chat_id}&document=${document}`\n        if (options.message_thread_id) url += `&message_thread_id=${options.message_thread_id}`\n        if (options.thumb) url += `&thumb=${options.thumb}`\n        if (options.caption) url += `&caption=${options.caption}`\n        if (options.parse_mode) url += `&parse_mode=${options.parse_mode}`\n        if (options.caption_entities) url += `&caption_entities=${this.JSS(options.caption_entities)}`\n        if (options.disable_content_type_detection) url += `&disable_content_type_detection=${options.disable_content_type_detection}`\n        if (options.disable_notification) url += `&disable_notification=${options.disable_notification}`\n        if (options.protect_content) url += `&protect_content=${options.protect_content}`\n        if (options.reply_to_message_id) url += `&reply_to_message_id=${options.reply_to_message_id}`\n        if (options.allow_sending_without_reply) url += `&allow_sending_without_reply=${options.allow_sending_without_reply}`\n        if (options.reply_markup) url += `&reply_markup=${this.JSS(options.reply_markup)}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#sendvideo\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string} video Contenuto da inviare\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    sendVideo(chat_id, video, options = {}) {\n        let url = `${this.url_base}sendDocument?chat_id=${chat_id}&video=${video}`\n        if (options.message_thread_id) url += `&message_thread_id=${options.message_thread_id}`\n        if (options.duration) url += `&duration=${options.duration}`\n        if (options.width) url += `&width=${options.width}`\n        if (options.height) url += `&height=${options.height}`\n        if (options.thumb) url += `&thumb=${options.thumb}`\n        if (options.caption) url += `&caption=${options.caption}`\n        if (options.parse_mode) url += `&parse_mode=${options.parse_mode}`\n        if (options.caption_entities) url += `&caption_entities=${this.JSS(options.caption_entities)}`\n        if (options.has_spoiler) url += `&has_spoiler=${options.has_spoiler}`\n        if (options.supports_streaming) url += `&supports_streaming=${options.supports_streaming}`\n        if (options.disable_notification) url += `&disable_notification=${options.disable_notification}`\n        if (options.protect_content) url += `&protect_content=${options.protect_content}`\n        if (options.reply_to_message_id) url += `&reply_to_message_id=${options.reply_to_message_id}`\n        if (options.allow_sending_without_reply) url += `&allow_sending_without_reply=${options.allow_sending_without_reply}`\n        if (options.reply_markup) url += `&reply_markup=${this.JSS(options.reply_markup)}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#sendanimation\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string} animation Contenuto da inviare\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    sendAnimation(chat_id, animation, options = {}) {\n        let url = `${this.url_base}sendAnimation?chat_id=${chat_id}&animation=${animation}`\n        if (options.message_thread_id) url += `&message_thread_id=${options.message_thread_id}`\n        if (options.duration) url += `&duration=${options.duration}`\n        if (options.width) url += `&width=${options.width}`\n        if (options.height) url += `&height=${options.height}`\n        if (options.thumb) url += `&thumb=${options.thumb}`\n        if (options.caption) url += `&caption=${options.caption}`\n        if (options.parse_mode) url += `&parse_mode=${options.parse_mode}`\n        if (options.caption_entities) url += `&caption_entities=${this.JSS(options.caption_entities)}`\n        if (options.has_spoiler) url += `&has_spoiler=${options.has_spoiler}`\n        if (options.disable_notification) url += `&disable_notification=${options.disable_notification}`\n        if (options.protect_content) url += `&protect_content=${options.protect_content}`\n        if (options.reply_to_message_id) url += `&reply_to_message_id=${options.reply_to_message_id}`\n        if (options.allow_sending_without_reply) url += `&allow_sending_without_reply=${options.allow_sending_without_reply}`\n        if (options.reply_markup) url += `&reply_markup=${this.JSS(options.reply_markup)}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#sendvoice\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string} voice Contenuto da inviare\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    sendVoice(chat_id, voice, options = {}) {\n        let url = `${this.url_base}sendVoice?chat_id=${chat_id}&voice=${voice}`\n        if (options.message_thread_id) url += `&message_thread_id=${options.message_thread_id}`\n        if (options.caption) url += `&caption=${options.caption}`\n        if (options.parse_mode) url += `&parse_mode=${options.parse_mode}`\n        if (options.caption_entities) url += `&caption_entities=${this.JSS(options.caption_entities)}`\n        if (options.duration) url += `&duration=${options.duration}`\n        if (options.disable_notification) url += `&disable_notification=${options.disable_notification}`\n        if (options.protect_content) url += `&protect_content=${options.protect_content}`\n        if (options.reply_to_message_id) url += `&reply_to_message_id=${options.reply_to_message_id}`\n        if (options.allow_sending_without_reply) url += `&allow_sending_without_reply=${options.allow_sending_without_reply}`\n        if (options.reply_markup) url += `&reply_markup=${this.JSS(options.reply_markup)}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#sendvideonote\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string} video_note Contenuto da inviare\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    sendVideoNote(chat_id, video_note, options = {}) {\n        let url = `${this.url_base}sendVideoNote?chat_id=${chat_id}&video_note=${video_note}`\n        if (options.message_thread_id) url += `&message_thread_id=${options.message_thread_id}`\n        if (options.duration) url += `&duration=${options.duration}`\n        if (options.length) url += `&length=${options.length}`\n        if (options.thumb) url += `&thumb=${options.thumb}`\n        if (options.disable_notification) url += `&disable_notification=${options.disable_notification}`\n        if (options.protect_content) url += `&protect_content=${options.protect_content}`\n        if (options.reply_to_message_id) url += `&reply_to_message_id=${options.reply_to_message_id}`\n        if (options.allow_sending_without_reply) url += `&allow_sending_without_reply=${options.allow_sending_without_reply}`\n        if (options.reply_markup) url += `&reply_markup=${this.JSS(options.reply_markup)}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#sendmediagroup\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string} media Contenuto da inviare\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    sendMediaGroup(chat_id, media, options = {}) {\n        let url = `${this.url_base}sendMediaGroup?chat_id=${chat_id}&media=${media}`\n        if (options.message_thread_id) url += `&message_thread_id=${options.message_thread_id}`\n        if (options.disable_notification) url += `&disable_notification=${options.disable_notification}`\n        if (options.protect_content) url += `&protect_content=${options.protect_content}`\n        if (options.reply_to_message_id) url += `&reply_to_message_id=${options.reply_to_message_id}`\n        if (options.allow_sending_without_reply) url += `&allow_sending_without_reply=${options.allow_sending_without_reply}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#sendlocation\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string} latitude Coordinata del luogo\n     * @param {string} longitude Coordinata del luogo\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    sendLocation(chat_id, latitude, longitude, options = {}) {\n        let url = `${this.url_base}sendLocation?chat_id=${chat_id}&latitude=${latitude}&longitude=${longitude}`\n        if (options.message_thread_id) url += `&message_thread_id=${options.message_thread_id}`\n        if (options.horizontal_accuracy) url += `&horizontal_accuracy=${options.horizontal_accuracy}`\n        if (options.live_period) url += `&live_period=${options.live_period}`\n        if (options.heading) url += `&heading=${options.heading}`\n        if (options.proximity_alert_radius) url += `&proximity_alert_radius=${options.proximity_alert_radius}`\n        if (options.disable_notification) url += `&disable_notification=${options.disable_notification}`\n        if (options.protect_content) url += `&protect_content=${options.protect_content}`\n        if (options.reply_to_message_id) url += `&reply_to_message_id=${options.reply_to_message_id}`\n        if (options.allow_sending_without_reply) url += `&allow_sending_without_reply=${options.allow_sending_without_reply}`\n        if (options.reply_markup) url += `&reply_markup=${this.JSS(options.reply_markup)}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#editmessagelivelocation\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    editMessageLiveLocation(options = {}) {\n        let url = `${this.url_base}editMessageLiveLocation`\n\n        if (options.chat_id && options.message_id) {\n            url += `?chat_id=${options.chat_id}&message_id=${options.message_id}`\n        } else if (options.inline_message_id) {\n            url += `?inline_message_id=${options.inline_message_id}`\n        } else {\n            let chat_id = this.JSGet('chat_id') || this.JSGet('chat.id')\n            let message_id = this.JSGet('message_id') || this.JSGet('message.id')\n            if (!chat_id || !message_id) return ''\n            url += `?chat_id=${chat_id}&message_id=${message_id}`\n        }\n\n        if (options.latitude) url += `&latitude=${options.latitude}`\n        if (options.longitude) url += `&longitude=${options.longitude}`\n        if (options.horizontal_accuracy) url += `&horizontal_accuracy=${options.horizontal_accuracy}`\n        if (options.heading) url += `&heading=${options.heading}`\n        if (options.proximity_alert_radius) url += `&proximity_alert_radius=${options.proximity_alert_radius}`\n        if (options.reply_markup) url += `&reply_markup=${this.JSS(options.reply_markup)}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#stopmessagelivelocation\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    stopMessageLiveLocation(options = {}) {\n        let url = `${this.url_base}stopMessageLiveLocation?`\n\n        if (options.chat_id && options.message_id) {\n            url += `?chat_id=${options.chat_id}&message_id=${options.message_id}`\n        } else if (options.inline_message_id) {\n            url += `?inline_message_id=${options.inline_message_id}`\n        } else {\n            let chat_id = this.JSGet('chat_id') || this.JSGet('chat.id')\n            let message_id = this.JSGet('message_id') || this.JSGet('message.id')\n            if (!chat_id || !message_id) return ''\n            url += `?chat_id=${chat_id}&message_id=${message_id}`\n        }\n\n        if (options.reply_markup) url += `&reply_markup=${this.JSS(options.reply_markup)}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#sendvenue\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string} latitude Coordinata del luogo\n     * @param {string} longitude Coordinata del luogo\n     * @param {string} title Titolo del luogo\n     * @param {string} address Indirizzo del luogo\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    sendVenue(chat_id, latitude, longitude, title, address, options = {}) {\n        let url = `${this.url_base}sendVenue?chat_id=${chat_id}&latitude=${latitude}&longitude=${longitude}&title=${title}&address=${address}`\n        if (options.message_thread_id) url += `&message_thread_id=${options.message_thread_id}`\n        if (options.foursquare_id) url += `&foursquare_id=${options.foursquare_id}`\n        if (options.foursquare_type) url += `&foursquare_type=${options.foursquare_type}`\n        if (options.google_place_id) url += `&google_place_id=${options.google_place_id}`\n        if (options.google_place_type) url += `&google_place_type=${options.google_place_type}`\n        if (options.disable_notification) url += `&disable_notification=${options.disable_notification}`\n        if (options.protect_content) url += `&protect_content=${options.protect_content}`\n        if (options.reply_to_message_id) url += `&reply_to_message_id=${options.reply_to_message_id}`\n        if (options.allow_sending_without_reply) url += `&allow_sending_without_reply=${options.allow_sending_without_reply}`\n        if (options.reply_markup) url += `&reply_markup=${this.JSS(options.reply_markup)}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#sendcontact\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string} phone_number Contatto telefonico\n     * @param {string} first_name Nome del contatto\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    sendContact(chat_id, phone_number, first_name, options = {}) {\n        let url = `${this.url_base}sendContact?chat_id=${chat_id}&phone_number=${phone_number}&first_name=${first_name}`\n        if (options.message_thread_id) url += `&message_thread_id=${options.message_thread_id}`\n        if (options.last_name) url += `&last_name=${options.last_name}`\n        if (options.vcard) url += `&vcard=${options.vcard}`\n        if (options.disable_notification) url += `&disable_notification=${options.disable_notification}`\n        if (options.protect_content) url += `&protect_content=${options.protect_content}`\n        if (options.reply_to_message_id) url += `&reply_to_message_id=${options.reply_to_message_id}`\n        if (options.allow_sending_without_reply) url += `&allow_sending_without_reply=${options.allow_sending_without_reply}`\n        if (options.reply_markup) url += `&reply_markup=${this.JSS(options.reply_markup)}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#sendpoll\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string} question Domanda del sondaggio\n     * @param {string | string []} pool_options Opzioni del sondaggio\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    sendPoll(chat_id, question, pool_options, options = {}) {\n        let url = `${this.url_base}sendPoll?chat_id=${chat_id}&question=${question}&options=${this.JSS(pool_options)}`\n        if (options.message_thread_id) url += `&message_thread_id=${options.message_thread_id}`\n        if (options.is_anonymous) url += `&is_anonymous=${options.is_anonymous}`\n        if (options.type) url += `&type=${options.type}`\n        if (options.allows_multiple_answers) url += `&allows_multiple_answers=${options.allows_multiple_answers}`\n        if (options.correct_option_id) url += `&correct_option_id=${options.correct_option_id}`\n        if (options.explanation) url += `&explanation=${options.explanation}`\n        if (options.explanation_parse_mode) url += `&explanation_parse_mode=${options.explanation_parse_mode}`\n        if (options.explanation_entities) url += `&explanation_entities=${this.JSS(options.explanation_entities)}`\n        if (options.open_period) url += `&open_period=${options.open_period}`\n        if (options.close_date) url += `&close_date=${options.close_date}`\n        if (options.is_closed) url += `&is_closed=${options.is_closed}`\n        if (options.disable_notification) url += `&disable_notification=${options.disable_notification}`\n        if (options.protect_content) url += `&protect_content=${options.protect_content}`\n        if (options.reply_to_message_id) url += `&reply_to_message_id=${options.reply_to_message_id}`\n        if (options.allow_sending_without_reply) url += `&allow_sending_without_reply=${options.allow_sending_without_reply}`\n        if (options.reply_markup) url += `&reply_markup=${this.JSS(options.reply_markup)}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#senddice\n     * @param {string | number} chat_id Identificativo chat\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    sendDice(chat_id, options = {}) {\n        let url = `${this.url_base}sendDice?chat_id=${chat_id}`\n        if (options.message_thread_id) url += `&message_thread_id=${options.message_thread_id}`\n        if (options.emoji) url += `&emoji=${options.emoji}`\n        if (options.disable_notification) url += `&disable_notification=${options.disable_notification}`\n        if (options.protect_content) url += `&protect_content=${options.protect_content}`\n        if (options.reply_to_message_id) url += `&reply_to_message_id=${options.reply_to_message_id}`\n        if (options.allow_sending_without_reply) url += `&allow_sending_without_reply=${options.allow_sending_without_reply}`\n        if (options.reply_markup) url += `&reply_markup=${this.JSS(options.reply_markup)}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#sendchataction\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string} action Tipo di azione, default CHAT_ACTION.typing\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    sendChatAction(chat_id, action = this.CHAT_ACTION.typing, options = {}) {\n        let url = `${this.url_base}sendChatAction?chat_id=${chat_id}&action=${action || this.CHAT_ACTION.typing}`\n        if (options.message_thread_id) url += `&message_thread_id=${options.message_thread_id}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#getuserprofilephotos\n     * @param {string | number} user_id Identificativo utente\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    getUserProfilePhotos(user_id, options = {}) {\n        let url = `${this.url_base}getUserProfilePhotos?user_id=${user_id}`\n        if (options.offset) url += `&offset=${options.offset}`\n        if (options.limit) url += `&limit=${options.limit}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#getfile\n     * @param {string} file_id Identificativo file\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    getFile(file_id) {\n        return `${this.url_base}getFile?file_id=${file_id}`\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#banchatmember\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string | number} user_id Identificativo utente\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    banChatMember(chat_id, user_id, options = {}) {\n        let url = `${this.url_base}banChatMember?chat_id=${chat_id}&user_id=${user_id}`\n        if (options.until_date) url += `&until_date=${options.until_date}`\n        if (options.revoke_messages) url += `&revoke_messages=${options.revoke_messages}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#unbanchatmember\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string | number} user_id Identificativo utente\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    unbanChatMember(chat_id, user_id, options = {}) {\n        let url = `${this.url_base}unbanChatMember?chat_id=${chat_id}&user_id=${user_id}`\n        if (options.only_if_banned) url += `&only_if_banned=${options.only_if_banned}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#restrictchatmember\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string | number} user_id Identificativo utente\n     * @param {string | string []} permissions Permessi utente, https://core.telegram.org/bots/api#chatpermissions\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    restrictChatMember(chat_id, user_id, permissions, options = {}) {\n        let url = `${this.url_base}restrictChatMember?chat_id=${chat_id}&user_id=${user_id}&permissions=${this.JSS(permissions)}`\n        if (options.until_date) url += `&until_date=${options.until_date}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#promotechatmember\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string | number} user_id Identificativo utente\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    promoteChatMember(chat_id, user_id, options = {}) {\n        let url = `${this.url_base}promoteChatMember?chat_id=${chat_id}&user_id=${user_id}`\n        if (options.is_anonymous) url += `&is_anonymous=${options.is_anonymous}`\n        if (options.can_manage_chat) url += `&can_manage_chat=${options.can_manage_chat}`\n        if (options.can_post_messages) url += `&can_post_messages=${options.can_post_messages}`\n        if (options.can_edit_messages) url += `&can_edit_messages=${options.can_edit_messages}`\n        if (options.can_delete_messages) url += `&can_delete_messages=${options.can_delete_messages}`\n        if (options.can_manage_video_chats) url += `&can_manage_video_chats=${options.can_manage_video_chats}`\n        if (options.can_restrict_members) url += `&can_restrict_members=${options.can_restrict_members}`\n        if (options.can_promote_members) url += `&can_promote_members=${options.can_promote_members}`\n        if (options.can_change_info) url += `&can_change_info=${options.can_change_info}`\n        if (options.can_invite_users) url += `&can_invite_users=${options.can_invite_users}`\n        if (options.can_pin_messages) url += `&can_pin_messages=${options.can_pin_messages}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#setchatadministratorcustomtitle\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string | number} user_id Identificativo utente\n     * @param {string} custom_title Nuovo titolo per l'amministratore (0-16 caratteri)\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    setChatAdministratorCustomTitle(chat_id, user_id, custom_title) {\n        return `${this.url_base}setChatAdministratorCustomTitle?chat_id=${chat_id}&user_id=${user_id}&custom_title=${custom_title}`\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#banchatsenderchat\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string | number} sender_chat_id Identificativo chat\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    banChatSenderChat(chat_id, sender_chat_id) {\n        return `${this.url_base}banChatSenderChat?chat_id=${chat_id}&sender_chat_id=${sender_chat_id}`\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#unbanchatsenderchat\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string | number} sender_chat_id Identificativo chat\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    unbanChatSenderChat(chat_id, sender_chat_id) {\n        return `${this.url_base}unbanChatSenderChat?chat_id=${chat_id}&sender_chat_id=${sender_chat_id}`\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#setchatpermissions\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string | string []} permissions Permessi utente, https://core.telegram.org/bots/api#chatpermissions\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    setChatPermissions(chat_id, permissions) {\n        return `${this.url_base}setChatPermissions?chat_id=${chat_id}&permissions=${this.JSS(permissions)}`\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#exportchatinvitelink\n     * @param {string | number} chat_id Identificativo chat\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    exportChatInviteLink(chat_id) {\n        return `${this.url_base}exportChatInviteLink?chat_id=${chat_id}`\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#createchatinvitelink\n     * @param {string | number} chat_id Identificativo chat\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    createChatInviteLink(chat_id, options = {}) {\n        let url = `${this.url_base}createChatInviteLink?chat_id=${chat_id}`\n        if (options.name) url += `&name=${options.name}`\n        if (options.expire_date) url += `&expire_date=${options.expire_date}`\n        if (options.member_limit) url += `&member_limit=${options.member_limit}`\n        if (options.creates_join_request) url += `&creates_join_request=${options.creates_join_request}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#editchatinvitelink\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string} invite_link Link invito\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    editChatInviteLink(chat_id, invite_link, options = {}) {\n        let url = `${this.url_base}editChatInviteLink?chat_id=${chat_id}&invite_link=${invite_link}`\n        if (options.name) url += `&name=${options.name}`\n        if (options.expire_date) url += `&expire_date=${options.expire_date}`\n        if (options.member_limit) url += `&member_limit=${options.member_limit}`\n        if (options.creates_join_request) url += `&creates_join_request=${options.creates_join_request}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#revokechatinvitelink\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string} invite_link Link invito\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    revokeChatInviteLink(chat_id, invite_link) {\n        return `${this.url_base}revokeChatInviteLink?chat_id=${chat_id}&invite_link=${invite_link}`\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#approvechatjoinrequest\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string | number} user_id Identificativo utente\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    approveChatJoinRequest(chat_id, user_id) {\n        return `${this.url_base}approveChatJoinRequest?chat_id=${chat_id}&user_id=${user_id}`\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#declinechatjoinrequest\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string | number} user_id Identificativo utente\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    declineChatJoinRequest(chat_id, user_id) {\n        return `${this.url_base}declineChatJoinRequest?chat_id=${chat_id}&user_id=${user_id}`\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#setchatphoto\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string} photo Foto, https://core.telegram.org/bots/api#inputfile\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    setChatPhoto(chat_id, photo) {\n        return `${this.url_base}setChatPhoto?chat_id=${chat_id}&photo=${photo}`\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#deletechatphoto\n     * @param {string | number} chat_id Identificativo chat\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    deleteChatPhoto(chat_id) {\n        return `${this.url_base}deleteChatPhoto?chat_id=${chat_id}`\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#setchattitle\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string} title Titolo (1-255 caratteri)\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    setChatTitle(chat_id, title) {\n        return `${this.url_base}setChatTitle?chat_id=${chat_id}&title=${title}`\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#setchatdescription\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string} description Titolo (1-255 caratteri)\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    setChatDescription(chat_id, description) {\n        return `${this.url_base}setChatDescription?chat_id=${chat_id}&description=${description}`\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#pinchatmessage\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string | number} message_id Identificativo messaggio\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    pinChatMessage(chat_id, message_id, options = {}) {\n        let url = `${this.url_base}pinChatMessage?chat_id=${chat_id}&message_id=${message_id}`\n        if (options.disable_notification) url += `&disable_notification=${options.disable_notification}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#unpinchatmessage\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string | number} message_id Identificativo messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    unpinChatMessage(chat_id, message_id) {\n        return `${this.url_base}unpinChatMessage?chat_id=${chat_id}&message_id=${message_id}`\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#unpinallchatmessages\n     * @param {string | number} chat_id Identificativo chat\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    unpinAllChatMessages(chat_id) {\n        return `${this.url_base}unpinAllChatMessages?chat_id=${chat_id}`\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#leavechat\n     * @param {string | number} chat_id Identificativo chat\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    leaveChat(chat_id) {\n        return `${this.url_base}leaveChat?chat_id=${chat_id}`\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#getchat\n     * @param {string | number} chat_id Identificativo chat\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    getChat(chat_id) {\n        return `${this.url_base}getChat?chat_id=${chat_id}`\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#getchatadministrators\n     * @param {string | number} chat_id Identificativo chat\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    getChatAdministrators(chat_id) {\n        return `${this.url_base}getChatAdministrators?chat_id=${chat_id}`\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#getchatmembercount\n     * @param {string | number} chat_id Identificativo chat\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    getChatMemberCount(chat_id) {\n        return `${this.url_base}getChatMemberCount?chat_id=${chat_id}`\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#getchatmember\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string | number} user_id Identificativo utente\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    getChatMember(chat_id, user_id) {\n        return `${this.url_base}getChatMember?chat_id=${chat_id}&user_id=${user_id}`\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#setchatstickerset\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string | number} sticker_set_name Nome set di sticker\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    setChatStickerSet(chat_id, sticker_set_name) {\n        return `${this.url_base}setChatStickerSet?chat_id=${chat_id}&sticker_set_name=${sticker_set_name}`\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#deletechatstickerset\n     * @param {string | number} chat_id Identificativo chat\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    deleteChatStickerSet(chat_id) {\n        return `${this.url_base}deleteChatStickerSet?chat_id=${chat_id}`\n    }\n\n    //getForumTopicIconStickers\n\n    //createForumTopic\n\n    //editForumTopic\n\n    //closeForumTopic\n\n    //reopenForumTopic\n\n    //deleteForumTopic\n\n    //unpinAllForumTopicMessages\n\n    //editGeneralForumTopic\n\n    //closeGeneralForumTopic\n\n    //reopenGeneralForumTopic\n\n    //hideGeneralForumTopic\n\n    //unhideGeneralForumTopic\n\n    /**\n     * https://core.telegram.org/bots/api#answercallbackquery\n     * @param {string | number} callback_query_id Identificativo callback\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    answerCallbackQuery(callback_query_id, options = {}) {\n        let url = `${this.url_base}answerCallbackQuery?callback_query_id=${callback_query_id}`\n        if (options.text) url += `&text=${options.text}`\n        if (options.show_alert) url += `&show_alert=${options.show_alert}`\n        if (options.cache_time) url += `&cache_time=${options.cache_time}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#setmycommands\n     * @param {string | string []} commands Comandi\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    setMyCommands(commands, options = {}) {\n        let url = `${this.url_base}setMyCommands?commands=${this.JSS(commands)}`\n        if (options.scope) url += `&scope=${this.JSS(options.scope)}`\n        if (options.language_code) url += `&language_code=${options.language_code}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#deletemycommands\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    deleteMyCommands(options = {}) {\n        let url = `${this.url_base}deleteMyCommands`\n        if (options.scope) url += `?scope=${this.JSS(options.scope)}`\n        if (options.language_code) {\n            url += (options.scope) ? '&' : '?'\n            url += `language_code=${options.language_code}`\n        }\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#getmycommands\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    getMyCommands(options = {}) {\n        let url = `${this.url_base}getMyCommands`\n        if (options.scope) url += `?scope=${this.JSS(options.scope)}`\n        if (options.language_code) {\n            url += (options.scope) ? '&' : '?'\n            url += `language_code=${options.language_code}`\n        }\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#setchatmenubutton\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    setChatMenuButton(options = {}) {\n        let url = `${this.url_base}setChatMenuButton`\n        if (options.chat_id) url += `?chat_id=${options.chat_id}`\n        if (options.menu_button) {\n            url += (options.chat_id) ? '&' : '?'\n            url += `menu_button=${options.menu_button}`\n        }\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#getchatmenubutton\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    getChatMenuButton(options = {}) {\n        let url = `${this.url_base}getChatMenuButton`\n        if (options.chat_id) url += `?chat_id=${options.chat_id}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#setmydefaultadministratorrights\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    setMyDefaultAdministratorRights(options = {}) {\n        let url = `${this.url_base}setMyDefaultAdministratorRights`\n        if (options.rights) url += `?rights=${this.JSS(options.rights)}`\n        if (options.for_channels) {\n            url += (options.rights) ? '&' : '?'\n            url += `for_channels=${options.for_channels}`\n        }\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#getmydefaultadministratorrights\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    getMyDefaultAdministratorRights(options = {}) {\n        let url = `${this.url_base}getMyDefaultAdministratorRights`\n        if (options.for_channels) url += `?for_channels=${options.for_channels}`\n        return url\n    }\n\n    //////////////////////////////////////////////////////////////////////////\n    //Updating messages\n    //https://core.telegram.org/bots/api#updating-messages\n    //////////////////////////////////////////////////////////////////////////\n\n    /**\n     * https://core.telegram.org/bots/api#editmessagetext\n     * @param {string} text Nuovo testo\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    editMessageText(text, options = {}) {\n        let url = `${this.url_base}editMessageText`\n\n        if (options.chat_id && options.message_id) {\n            url += `?chat_id=${options.chat_id}&message_id=${options.message_id}`\n        } else if (options.inline_message_id) {\n            url += `?inline_message_id=${options.inline_message_id}`\n        } else {\n            let chat_id = this.JSGet('chat_id') || this.JSGet('chat.id')\n            let message_id = this.JSGet('message_id') || this.JSGet('message.id')\n            if (!chat_id || !message_id) return ''\n            url += `?chat_id=${chat_id}&message_id=${message_id}`\n        }\n\n        url += `&text=${text}`\n        if (options.parse_mode) url += `&parse_mode=${options.parse_mode}`\n        if (options.entities) url += `&entities=${this.JSS(options.entities)}`\n        if (options.disable_web_page_preview) url += `&disable_web_page_preview=${options.disable_web_page_preview}`\n        if (options.reply_markup) url += `&reply_markup=${this.JSS(options.reply_markup)}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#editmessagecaption\n     * @param {string} caption Nuova didascalia\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    editMessageCaption(caption, options = {}) {\n        let url = `${this.url_base}editMessageCaption`\n\n        if (options.chat_id && options.message_id) {\n            url += `?chat_id=${options.chat_id}&message_id=${options.message_id}`\n        } else if (options.inline_message_id) {\n            url += `?inline_message_id=${options.inline_message_id}`\n        } else {\n            let chat_id = this.JSGet('chat_id') || this.JSGet('chat.id')\n            let message_id = this.JSGet('message_id') || this.JSGet('message.id')\n            if (!chat_id || !message_id) return ''\n            url += `?chat_id=${chat_id}&message_id=${message_id}`\n        }\n\n        url += `&caption=${caption}`\n        if (options.parse_mode) url += `&parse_mode=${options.parse_mode}`\n        if (options.caption_entities) url += `&caption_entities=${this.JSS(options.caption_entities)}`\n        if (options.reply_markup) url += `&reply_markup=${this.JSS(options.reply_markup)}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#editmessagemedia\n     * @param {string} media Nuova didascalia\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    editMessageMedia(media, options = {}) {\n        let url = `${this.url_base}editMessageMedia`\n\n        if (options.chat_id && options.message_id) {\n            url += `?chat_id=${options.chat_id}&message_id=${options.message_id}`\n        } else if (options.inline_message_id) {\n            url += `?inline_message_id=${options.inline_message_id}`\n        } else {\n            let chat_id = this.JSGet('chat_id') || this.JSGet('chat.id')\n            let message_id = this.JSGet('message_id') || this.JSGet('message.id')\n            if (!chat_id || !message_id) return ''\n            url += `?chat_id=${chat_id}&message_id=${message_id}`\n        }\n\n        url += `&media=${media}`\n        if (options.reply_markup) url += `&reply_markup=${this.JSS(options.reply_markup)}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#editmessagereplymarkup\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    editMessageReplyMarkup(media, options = {}) {\n        let url = `${this.url_base}editMessageReplyMarkup`\n\n        if (options.chat_id && options.message_id) {\n            url += `?chat_id=${options.chat_id}&message_id=${options.message_id}`\n        } else if (options.inline_message_id) {\n            url += `?inline_message_id=${options.inline_message_id}`\n        } else {\n            let chat_id = this.JSGet('chat_id') || this.JSGet('chat.id')\n            let message_id = this.JSGet('message_id') || this.JSGet('message.id')\n            if (!chat_id || !message_id) return ''\n            url += `?chat_id=${chat_id}&message_id=${message_id}`\n        }\n        if (options.reply_markup) url += `&reply_markup=${this.JSS(options.reply_markup)}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#stoppoll\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string | number} message_id Identificativo messaggio\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    stopPoll(chat_id, message_id, options = {}) {\n        let url = `${this.url_base}stopPoll?chat_id=${chat_id}&message_id=${message_id}`\n        if (options.reply_markup) url += `&reply_markup=${this.JSS(options.reply_markup)}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#deletemessage\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string | number} message_id Identificativo messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    deleteMessage(chat_id, message_id) {\n        return `${this.url_base}deleteMessage?chat_id=${chat_id}&message_id=${message_id}`\n    }\n\n    //////////////////////////////////////////////////////////////////////////\n    //Stickers\n    //https://core.telegram.org/bots/api#stickers\n    //////////////////////////////////////////////////////////////////////////\n\n    //Mancante Stickers\n    //https://core.telegram.org/bots/api#sticker\n\n    //Mancante StickerSet\n    //https://core.telegram.org/bots/api#stickerset\n\n    //Mancante MaskPosition\n    //https://core.telegram.org/bots/api#maskposition\n\n    /**\n     * https://core.telegram.org/bots/api#sendsticker\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string} sticker File da inviare\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    sendSticker(chat_id, sticker, options = {}) {\n        let url = `${this.url_base}sendSticker?chat_id=${chat_id}&sticker=${sticker}`\n        if (options.message_thread_id) url += `&message_thread_id=${options.message_thread_id}`\n        if (options.disable_notification) url += `&disable_notification=${options.disable_notification}`\n        if (options.protect_content) url += `&protect_content=${options.protect_content}`\n        if (options.reply_to_message_id) url += `&reply_to_message_id=${options.reply_to_message_id}`\n        if (options.allow_sending_without_reply) url += `&allow_sending_without_reply=${options.allow_sending_without_reply}`\n        if (options.reply_markup) url += `&reply_markup=${this.JSS(options.reply_markup)}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#getstickerset\n     * @param {string} name Nome del set\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    getStickerSet(name) {\n        return `${this.url_base}getStickerSet?name=${name}`\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#getcustomemojistickers\n     * @param {string} array Array set custom emoji\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    getCustomEmojiStickers(array) {\n        return `${this.url_base}getCustomEmojiStickers?custom_emoji_ids=${this.JSS(array)}`\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#uploadstickerfile\n     * @param {string | number} user_id Identificativo utente\n     * @param {string} png_sticker File sticker\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    uploadStickerFile(user_id, png_sticker) {\n        return `${this.url_base}uploadStickerFile?user_id=${user_id}&png_sticker=${png_sticker}`\n    }\n\n    //Mancante createNewStickerSet\n    //https://core.telegram.org/bots/api#createnewstickerset\n\n    //Mancante addStickerToSet\n    //https://core.telegram.org/bots/api#addstickertoset\n\n    //Mancante setStickerPositionInSet\n    //https://core.telegram.org/bots/api#setstickerpositioninset\n\n    //Mancante deleteStickerFromSet\n    //https://core.telegram.org/bots/api#deletestickerfromset\n\n    //Mancante setStickerSetThumb\n    //https://core.telegram.org/bots/api#setstickersetthumb\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nglobal.set('TelegramBotApi', { class: TelegramBotApi, version: '3.7.0', api: '6.4', date: Date.now() })\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//Telegram Bot Api Javascript for Node-RED//////////////////////////////////////////////////////////////////////////////////////////////",
        "finalize": "",
        "libs": [],
        "x": 240,
        "y": 330,
        "wires": []
    },
    {
        "id": "1d55ae881be97fe5",
        "type": "function",
        "z": "799d902a165e50be",
        "name": "Class Tools",
        "func": "//On Start",
        "outputs": 0,
        "noerr": 0,
        "initialize": "/**\n * Tools Class Collections Javascript for Node-RED\n * Bruno Leonardi - b.leonardi78@gmail.com\n * Version 3.6.5 - 02/01/2023\n */\nclass Tools {\n    /**\n     * @param {NodeMessage | {}} object Imposta l'oggetto o il messaggio fondamentale per alcune funzioni (Template...)\n     */\n    constructor(object = {}) {\n        this.object = object\n    }\n\n    /**\n     * Imposta il messaggio di Node-RED\n     * @param {NodeMessage} object\n     */\n    SetNodeMessage(object) {\n        this.object = object\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //NODE-RED FUNCTION\n\n    /**\n     * Restituisce il messaggio inserendo le nuove propriet√†\n     * @param {string} path Propriet√† oggetto (esempio: 'msg.payload.chiave1.chiave2')\n     * @param {any} value Valore propriet√†\n     */\n    CreateMessage(path, value = null) {\n        var object = msg\n        RED.util.setMessageProperty(object, path, value, true)\n        return Object.assign(msg, object)\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //NODE-RED GLOBAL\n\n    /**\n     * Restituisce la variabile globale\n     * @param {string | string []} path Percorso variabile globale\n     * @param {any} returnValue Valore di ritorno in caso di variabile undefined o errore\n     */\n    GetGlobalVariable(path, returnValue = null) {\n        if (path === null || path === undefined || typeof path !== 'string') return returnValue\n        try {\n            return global.get(path)\n        } catch (error) {\n            return returnValue\n        }\n    }\n\n    //NODE-RED GLOBAL\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //STRING\n\n    /**\n     * Sostituisce l'apostrofo con l'apice dalla stringa\n     * @param {string} string Stringa da valutare\n     */\n    TextReplaceApostrophe(string) {\n        if (string === null || string === undefined || typeof string !== 'string') return string\n        return String.raw`${string}`.replace(/'/gm, '`')\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //STRING\n\n    /**\n     * Converte una stringa Ascii in Hex\n     * @param {string} string Stringa Ascii\n     */\n    AsciiToHex(string) {\n        if (string === null || string === undefined || typeof string !== 'string') return string\n        var hex_array = []\n        for (var n = 0, l = string.length; n < l; n++) {\n            let hex = Number(string.charCodeAt(n)).toString(16)\n            hex_array.push(hex)\n        }\n\n        return hex_array.join('')\n    }\n\n    /**\n     * Converte una stringa Hex in Ascii\n     * @param {string} string Stringa Hex\n     */\n    HexToAscii(string) {\n        if (string === null || string === undefined || typeof string !== 'string') return string\n        var hex = string.toString()\n        string = ''\n        for (var n = 0; n < hex.length; n += 2) {\n            string += String.fromCharCode(parseInt(hex.substr(n, 2), 16))\n        }\n\n        return string\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //STRING\n\n    /**\n     * Restituisce la stringa elaborata\n     * @param {string} string Stringa da valutare\n     * @param {string} text Stringa formato RegExp di ricerca\n     * @param {string} with_text Testo da applicare\n     * @param {string} flags Opzioni di ricerca RegExp, default 'gm'\n     * https://regex101.com/#javascript\n     */\n    TextReplace(string, text, with_text, flags = 'gm') {\n        if (string === null || string === undefined || typeof string !== 'string') return string\n        if (text === null || text === undefined || typeof text !== 'string') return string\n        if (with_text === null || with_text === undefined || typeof with_text !== 'string') return string\n        let re = new RegExp(text, flags)\n        return String.raw`${string}`.replace(re, with_text)\n    }\n\n    /**\n     * Restituisce una Array del match\n     * @param {string} string Stringa da valutare\n     * @param {string} text Stringa formato RegExp di ricerca\n     * @param {string} flags Opzioni di ricerca RegExp, default 'gmi'\n     * https://regex101.com/#javascript\n    */\n    TextMatch(string, text, flags = 'gmi') {\n        if (string === null || string === undefined || typeof string !== 'string') return []\n        if (text === null || text === undefined || typeof text !== 'string') return []\n        if (typeof string !== 'string') string = string.toString()\n        let re = new RegExp(text, flags)\n        let match = String.raw`${string}`.match(re)\n        return (match && match.length > 0) ? match : []\n    }\n\n    /**\n     * Restituisce un valore number\n     * @param {string} string Stringa da valutare\n     * @param {string | RegExp} text Testo da cercare\n     * @param {string} flags Opzioni di ricerca RegExp, default 'gmi'\n     * https://regex101.com/#javascript\n     */\n    TextSearch(string, text, flags = 'gmi') {\n        if (string === null || string === undefined || typeof string !== 'string') return false\n        if (text === null || text === undefined || typeof text !== 'string') return false\n        let re = new RegExp(text, flags)\n        return string.search(re)\n    }\n\n    /**\n     * Restituisce un valore booleano\n     * @param {string} string Stringa da valutare\n     * @param {string | RegExp} text Testo da cercare\n     * @param {string} flags Opzioni di ricerca RegExp, default 'gmi'\n     * https://regex101.com/#javascript\n     */\n    TextExists(string, text, flags = 'gmi') {\n        if (string === null || string === undefined || typeof string !== 'string') return false\n        if (text === null || text === undefined || typeof text !== 'string') return false\n        let re = new RegExp(text, flags)\n        return re.test(string)\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //STRING\n\n    /**\n     * Restituisce il valore terminato con il carattere specificato\n     * @param {string} string Stringa da valutare\n     * @param {string} char Carattere da assegnare\n     */\n    TextMustEndwith(string, char) {\n        if (string === null || string === undefined || typeof string !== 'string') return string\n        if (char === null || char === undefined || typeof char !== 'string') return string\n        string += (String.raw`${string}`.endsWith(char)) ? '' : char\n        return string\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //STRING\n\n    /**\n     * Verifica se la stringa contiene Emoji\n     * @param {string} string Stringa da valutare\n     */\n    ContainsEmoji(string) {\n        if (string === null || string === undefined || typeof string !== 'string') return false\n        const emojiKeycap = (/[\\u0023-\\u0039]\\ufe0f?\\u20e3/)\n        if (emojiKeycap.test(string)) return true\n        const emoji = (/[\\p{Extended_Pictographic}\\u{1F3FB}-\\u{1F3FF}\\u{1F9B0}-\\u{1F9B3}]/u)\n        return emoji.test(string)\n    }\n\n    /**\n     * Verifica se la stringa contiene soltanto Emoji\n     * @param {string} string Stringa da valutare\n     */\n    ContainsOnlyEmoji(string) {\n        if (string === null || string === undefined || typeof string !== 'string') return false\n        const emojiKeycap = (/[\\u0023-\\u0039]\\ufe0f?\\u20e3/g)\n        if (emojiKeycap.test(string)) string = String.raw`${string}`.replace(emojiKeycap, '')\n        const emoji = (/[\\p{Extended_Pictographic}\\u{1F3FB}-\\u{1F3FF}\\u{1F9B0}-\\u{1F9B3}]/gu)\n        if (emoji.test(string)) string = String.raw`${string}`.replace(emoji, '')\n        return (string.trim().length === 0)\n    }\n\n    /**\n     * Rimuove gli Emoji dalla stringa\n     * @param {string} string Stringa da valutare\n     */\n    RemoveEmoji(string) {\n        if (string === null || string === undefined || typeof string !== 'string') return false\n        const emojiKeycap = (/[\\u0023-\\u0039]\\ufe0f?\\u20e3/g)\n        if (emojiKeycap.test(string)) string = String.raw`${string}`.replace(emojiKeycap, '')\n        const emoji = (/[\\p{Extended_Pictographic}\\u{1F3FB}-\\u{1F3FF}\\u{1F9B0}-\\u{1F9B3}]/gu)\n        if (emoji.test(string)) string = String.raw`${string}`.replace(emoji, '')\n        return string\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //STRING\n\n    /** \n     * Verifica se un indirizzo di posta elettronica √® corretto\n     * @param {string} email Indirizzo di posta elettronica da validare\n     */\n    IsEmail(email) {\n        return /^\\w+([\\.-]?\\w+)*@\\w+([\\.-]?\\w+)*(\\.\\w{2,3})+$/.test(email)\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //STRING\n\n    /**\n     * Verifica se un valore √® di tipo Hex\n     * @param {string} value Valore da valutare\n     */\n    IsHex(value) {\n        if (value === null || value === undefined || typeof value !== 'string') return false\n        return (/^[A-F0-9]+$/i).test(value)\n    }\n\n    /**\n     * Verifica se un valore √® di tipo Ascii\n     * @param {string} value Valore da valutare\n     */\n    IsAscii(value) {\n        if (value === null || value === undefined || typeof value !== 'string') return false\n        return (/^[\\x00-\\x7F]*$/).test(value)\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //STRING\n\n    /**\n     * {{Template}} - Restituisce il template elaborato\n     * @param {string} string Testo da processare\n     * @param {string[]} flags Delimitatori del valore, default ['{{', '}}'] \n     */\n    Template(string, flags = ['{{', '}}']) {\n        if (string === null || string === undefined || typeof string !== 'string') return string\n        if (string.trim() == '') return string\n        let re = new RegExp(flags[0] + '(.*?)' + flags[1], 'gmi')\n        let match = string.match(re)\n        if (!match) return string\n        if (match && match.length > 0) {\n            for (let index = 0; index < match.length; index++) {\n                const element = match[index]\n                let value = this.JSGet(element.substr(flags[0].length, element.length - (flags[0].length + flags[1].length)))\n                string = String.raw`${string}`.replace(element, value)\n            }\n\n        }\n\n        return string\n    }\n\n    //STRING\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //NUMBER\n\n    /**\n     * Verifica se un numero √® pari\n     * @param {number} number Numero da valutare\n     */\n    IsEven(number) {\n        if (number === null || number === undefined) return false\n        return (Number(number) === number && number % 2 === 0)\n    }\n\n    /**\n     * Verifica se un numero √® dispari\n     * @param {number} number Numero da valutare\n     */\n    IsOdd(number) {\n        if (number === null || number === undefined) return false\n        return (Number(number) === number && number % 2 !== 0)\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //NUMBER\n\n    /**\n     * Verifica se un numero √® intero\n     * @param {number} number Numero da valutare\n     */\n    IsInteger(number) {\n        if (number === null || number === undefined) return false\n        return (Number(number) === number && number % 1 === 0)\n    }\n\n    /**\n     * Verifica se un numero √® decimale\n     * @param {number} number Numero da valutare\n     */\n    IsDecimal(number) {\n        if (number === null || number === undefined) return false\n        return (Number(number) === number && number % 1 !== 0)\n    }\n\n    //NUMBER\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //OBJETC\n\n    /**\n     * Verifica se un oggetto √® null o undefined\n     * @param {object} object Oggetto da verificare\n     */\n    IsNullOrUndefined(object) {\n        return (object === null || object === undefined)\n    }\n\n    /**\n     * Verifica se un oggetto √® null\n     * @param {object} object Oggetto da verificare\n     */\n    IsNull(object) {\n        return (object === null)\n    }\n\n    /**\n     * Verifica se un oggetto √® undefined\n     * @param {object} object Oggetto da verificare\n     */\n    IsUndefined(object) {\n        return (object === undefined)\n    }\n\n    /**\n     * Verifica se un oggetto √® vuoto, null, undefined, numero negativo o stringa vuota\n     * @param {object} object Oggetto da verificare\n     */\n    IsNullOrEmpty(object) {\n        if (object === null || object === undefined) return true\n        switch (typeof object) {\n            case 'object':\n                //controlla se √® vuoto\n                if (Array.isArray(object)) {\n                    return (object.length === 0)\n                } else if (object.constructor === Object && !Array.isArray(object)) {\n                    return (Object.keys(object).length === 0)\n                } else {\n                    return false\n                }\n            case 'string':\n                //elimina gli spazi e controlla se √® vuota            \n                return (object.trim().length == 0)\n            case 'number':\n                //elimina gli spazi e controlla se √® vuota            \n                return (object < 0)\n            default:\n                //per tutto il resto boolean, function...\n                return false\n        }\n    }\n\n    /**\n     * Verifica se un oggetto √® vuoto, null o undefined\n     * @param {object} object Oggetto da verificare\n     */\n    IsEmpty(object) {\n        if (object === null || object === undefined) return true\n        switch (typeof object) {\n            case 'object':\n                //controlla se √® vuoto\n                if (Array.isArray(object)) {\n                    return (object.length === 0)\n                } else if (object.constructor === Object && !Array.isArray(object)) {\n                    return (Object.keys(object).length === 0)\n                } else {\n                    return false\n                }\n            case 'string':\n                //elimina gli spazi e controlla se √® vuota            \n                return (object.trim().length == 0)\n            default:\n                //per tutto il resto boolean, function...\n                return false\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //OBJETC\n\n    /**\n     * Verifica se un oggetto √® di tipo String\n     * @param {object} object Oggetto da verificare\n     */\n    IsString(object) {\n        if (object === null || object === undefined) return false\n        return (typeof object === 'string')\n    }\n\n    /**\n     * Verifica se un oggetto √® di tipo String vuota, non contiene caratteri\n     * @param {object} object Oggetto da verificare\n     */\n    IsStringEmpty(object) {\n        if (object === null || object === undefined) return true\n        return (typeof object === 'string' && object.trim().length === 0)\n    }\n\n    /**\n     * Verifica se un oggetto √® di tipo String piena, contiene caratteri\n     * @param {object} object Oggetto da verificare\n     */\n    IsStringFull(object) {\n        if (object === null || object === undefined) return false\n        return (typeof object === 'string' && object.trim().length > 0)\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //OBJETC\n\n    /**\n     * Verifica se un oggetto √® di tipo numerico\n     * @param {object} object Oggetto da verificare\n     */\n    IsNumber(object) {\n        if (object === null || object === undefined) return false\n        if ((typeof object === 'number' && isFinite(object)) || Object.prototype.toString.apply(object) === '[object Number]') return true\n        return (typeof object === \"string\" && !isNaN(object) && !isNaN(parseFloat(object)))\n    }\n\n    /**\n     * Verifica se un oggetto √® di tipo numerico positivo, uguale o superiore a zero\n     * @param {object} object Oggetto da verificare\n     */\n    IsNumberPositive(object) {\n        return (this.IsNumber(object) && object >= 0)\n    }\n\n    /**\n     * Verifica se un oggetto √® di tipo numerico negativo, inferiore a zero\n     * @param {object} object Oggetto da verificare\n     */\n    IsNumberNegative(object) {\n        return (this.IsNumber(object) && object < 0)\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //OBJETC\n\n    /**\n     * Verifica se un oggetto √® di tipo Boolean\n     * @param {object} object Oggetto da verificare\n     */\n    IsBoolean(object) {\n        if (object === null || object === undefined) return false\n        return (typeof object === 'boolean')\n    }\n\n    /**\n     * Verifica se un oggetto √® di tipo Boolean True\n     * @param {object} object Oggetto da verificare\n     */\n    IsTrue(object) {\n        if (object === null || object === undefined) return false\n        return (typeof object === 'boolean' && object === true)\n    }\n\n    /**\n     * Verifica se un oggetto √® di tipo Boolean False\n     * @param {object} object Oggetto da verificare\n     */\n    IsFalse(object) {\n        if (object === null || object === undefined) return true\n        return (typeof object === 'boolean' && object === false)\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //OBJETC\n\n    /**\n     * Verifica se due oggetti sono uguali\n     * @param {object} object0 Primo oggetto del confronto\n     * @param {object} object1 Secondo oggetto del confronto\n     */\n    IsEqual(object0, object1) {\n        return (object0 === object1)\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //OBJETC\n\n    /**\n     * Verifica se un oggetto √® di tipo Date\n     * @param {object} object Oggetto da verificare\n     */\n    IsDate(object) {\n        if (object === null || object === undefined) return false\n        return (typeof object === 'object' && object instanceof Date && !isNaN(object.valueOf()))\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //OBJETC\n\n    /**\n     * Verifica se un oggetto √® un matrice di tipo Object o Array\n     * @param {object} object Oggetto da verificare\n     */\n    IsMatrix(object) {\n        if (object === null || object === undefined) return false\n        return (typeof object === 'object' && (object instanceof Object || Array.isArray(object)))\n    }\n\n    /**\n     * Verifica se un oggetto √® un JSON Object\n     * @param {object} object Oggetto da verificare\n     */\n    IsObject(object) {\n        if (object === null || object === undefined) return false\n        return (!Array.isArray(object))\n    }\n\n    /**\n     * Verifica se un oggetto √® un Object Array\n     * @param {object} object Oggetto da verificare\n     */\n    IsArray(object) {\n        if (object === null || object === undefined) return false\n        return (Array.isArray(object))\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //OBJETC\n\n    /**\n     * Restituisce il tipo di oggetto\n     * @param {object} object Oggetto da verificare\n     */\n    GetTypeOf(object) {\n        return typeof object\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //OBJETC\n\n    /**\n     * Converte un oggetto JSON Object in Array\n     * @param {object} object Oggetto da convertire\n     */\n    ObjectToArray(object) {\n        if (object === null || object === undefined) return []\n        if (this.IsObject(object)) {\n            return Object.values(object)\n        } else {\n            return []\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //OBJETC\n\n    /**\n     * Converte un oggetto Array in JSON Object\n     * @param {string[]} object Array da convertire\n     */\n    ArrayToObject(object) {\n        if (object === null || object === undefined) return {}\n        if (this.IsArray(object)) {\n            return Object.assign({}, object)\n        } else {\n            return {}\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //OBJETC\n\n    /**\n     * Restituisce un valore casuale selezionandolo da una matrice\n     * @param {{} | [] | string} object Object, Array o String separato da punto e virgola\n     */\n    GetRandomValue(object) {\n        if (object === null || object === undefined) return null\n        if (typeof object === 'string') {\n            object = object.trim()\n            if ((/;/gm).test(object)) {\n                object = object.split(';')\n            } else {\n                return object\n            }\n        } else if (typeof object === 'object') {\n            object = Object.values(object)\n        } else {\n            return null\n        }\n\n        if (!Array.isArray(object)) return null\n        let result = object[Math.floor(Math.random() * object.length)]\n        if (!result) return null\n        if (typeof result === 'string' && result.trim() == '') return null\n        return result\n    }\n\n    //OBJETC\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //JSON utility\n\n    /**\n     * Converte JSON String >> Object\n     * @param {string} json_string JSON String\n     */\n    JSO(json_string) {\n        try {\n            if (json_string === null || json_string === undefined || typeof json_string !== 'string') return json_string\n            return JSON.parse(json_string)\n        } catch (error) {\n            return json_string\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //JSON utility\n\n    /**\n     * Converte JSON Object >> String\n     * @param {object} json_object JSON Object\n     */\n    JSS(json_object) {\n        try {\n            if (json_object === null || json_object === undefined || typeof json_object !== 'object') return json_object\n            return JSON.stringify(json_object)\n        } catch (error) {\n            return json_object\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //JSON utility\n\n    /**\n     * Converte JSON Object >> String formattato\n     * @param {object} json_object JSON Object\n     * @param {number} indentation Identazione formattazione testo\n     */\n    JSSPrint(json_object, indentation = 3) {\n        try {\n            if (json_object === null || json_object === undefined || typeof json_object !== 'object') return json_object\n            return JSON.stringify(json_object, null, indentation)\n        } catch (error) {\n            return json_object\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //JSON utility\n\n    /**\n     * Ricerca le chievi in un oggetto JSON e restituisce il valore o le propriet√†\n     * @param {string | string []} args args = 'key' || 'key.subkey.{what}' || 'key.*.{what}' || ['key', 'subkey', '{what}'] || ['key', '*', '{what}']\n     * @param {string | string []} args {what} = $type || $keys || $first_key || $last_key || $root || $boolean || $object || $...> (ultimo risultato)\n     * @param {NodeMessage | {} | []} object Oggetto sul quale effettuare la ricerca\n     */\n    JSGet(args, object = this.object) {\n        //creo una copia di object\n        object = RED.util.cloneMessage(object)\n\n        //definisci le chiavi\n        if (!args || (typeof args === 'string' && !args.trim())) {\n            return null\n        } else if (typeof args === 'string') {\n            //crea una array di chiavi\n            args = args.split('.')\n        } else if (!Array.isArray(args)) {\n            return null\n        }\n\n        //chiave primaria\n        var key = args[0]\n        if (!key) return null\n        if (typeof key !== 'string') return null\n        if (key == '') return null\n\n        //chiave secondaria\n        var subKey = (args.length == 2) ? args[1] : null\n        if (subKey && (subKey == '*' || subKey == '')) subKey = null\n\n        //risultato richiesto\n        var what = (args.length == 3) ? args[2] : ''\n\n        //definisci l'oggetto, deve essere un JSON\n        if (object && typeof object === 'object' && Array.isArray(object) && object.length > 0) {\n            //se √® una array lo converto\n            Object.assign({}, object)\n        } else if (typeof object === 'string') {\n            //se √® un JSON string lo converto\n            try {\n                object = JSON.parse(object)\n            } catch (error) {\n                return null\n            }\n        }\n\n        //se non √® un JSON restituisco null\n        if (!object || (Object.keys(object).length == 0 && object.constructor === Object)) {\n            return null\n        }\n\n        //risultati della ricerca\n        var result = null\n\n        //ricerca in profondit√† la chiave nell'oggetto\n        var searchDeep = function SearchDeep(/** @type {{ [x: string]: any; hasOwnProperty: (arg0: string) => any; }} */ object, /** @type {string} */ rootKeys) {\n            //percorso della chiave\n            var root = function GetRootKey(/** @type {string} */ addKey) {\n                return rootKeys ? `${rootKeys}.${addKey}` : addKey\n            }\n\n            //chiave trovata\n            if (object && object.hasOwnProperty(key)) {\n                //se vuota assegna key\n                if (!rootKeys) rootKeys = key\n\n                if (subKey && object[key].hasOwnProperty(subKey)) {\n                    result = {\n                        value: object[key][subKey],\n                        type: typeof object[key][subKey],\n                        keys: rootKeys.split('.').length,\n                        first_key: rootKeys.split('.')[0],\n                        last_key: (rootKeys.split('.').length > 0) ? rootKeys.split('.')[rootKeys.split('.').length - 1] : rootKeys.split('.')[0],\n                        root: rootKeys\n                    }\n                } else if (!subKey) {\n                    result = {\n                        value: object[key],\n                        type: typeof object[key],\n                        keys: rootKeys.split('.').length,\n                        first_key: rootKeys.split('.')[0],\n                        last_key: (rootKeys.split('.').length > 0) ? rootKeys.split('.')[rootKeys.split('.').length - 1] : rootKeys.split('.')[0],\n                        root: rootKeys\n                    }\n                }\n            }\n\n            //ricerca della chiave\n            if (!result || what.endsWith('>')) {\n                for (let k in object) {\n                    if (object.hasOwnProperty(k) && typeof object[k] === 'object') {\n                        searchDeep(object[k], root(k))\n                    }\n                }\n            }\n        }\n\n        //inizia la ricerca\n        searchDeep(object)\n\n        //restituisci il risultato\n        switch (what.replace('>', '')) {\n            case \"$type\":\n                return (!result ? null : result.type)\n            case \"$keys\":\n                return (!result ? null : result.keys)\n            case \"$first_key\":\n                return (!result ? null : result.first_key)\n            case \"$last_key\":\n                return (!result ? null : result.last_key)\n            case \"$root\":\n                return (!result ? null : result.root)\n            case \"$boolean\":\n                return !!result\n            case \"$object\":\n                return (!result ? null : result)\n            default:\n                return (!result ? null : result.value)\n        }\n    }\n\n    //JSON utility\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //CONSTANTS DATE\n\n    /**\n     * Nomi dei giorni\n     */\n    DAYS = ['Domenica', 'Luned√¨', 'Marted√¨', 'Mercoled√¨', 'Gioved√¨', 'Venerd√¨', 'Sabato']\n\n    /**\n     * Nomi dei giorni abbreviati\n     */\n    DAYS_SHORT = ['DOM', 'LUN', 'MAR', 'MER', 'GIO', 'VEN', 'SAB']\n\n    /**\n     * Nomi dei mesi\n     */\n    MONTHS = ['Gennaio', 'Febbraio', 'Marzo', 'Aprile', 'Maggio', 'Giugno', 'Luglio', 'Agosto', 'Settembre', 'Ottobre', 'Novembre', 'Dicembre']\n\n    /**\n     * Nomi dei mesi abbreviati\n     */\n    MONTHS_SHORT = ['GEN', 'FEB', 'MAR', 'APR', 'MAG', 'GIU', 'LUG', 'AGO', 'SET', 'OTT', 'NOV', 'DIC']\n\n    //CONSTANTS DATE\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Restituisce Unix in millisecondi\n     * @param {string | number | Date} date Data di riferimento, se Null restituisce la data Unix attuale\n     * @param {boolean} seconds Unix in secondi, default false\n     */\n    GetUnix(date = null, seconds = false) {\n        if (!date) return Date.now()\n        if (typeof date === 'string' && !isNaN(date)) date = parseInt(date)\n        if (typeof date === 'number') {\n            if (date.toString().length < 13 && !seconds) date *= 1000\n            date = Math.round(date)\n        }\n        return (seconds) ? new Date(date).valueOf() / 1000 : new Date(date).valueOf()\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Verifica se il numero Unix √® espresso in secondi\n     * @param {number | string} unix Numero formato Unix\n     */\n    UnixIsSeconds(unix = null) {\n        if (!unix) return false\n        if (typeof unix === 'string') unix = parseInt(unix)\n        return (unix.toString().length < 13)\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Verifica se il numero Unix √® espresso in millisecondi\n     * @param {number | string} unix Numero formato Unix\n     */\n    UnixIsMilliseconds(unix = null) {\n        if (!unix) return false\n        if (typeof unix === 'string') unix = parseInt(unix)\n        return (unix.toString().length >= 13)\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Restituisce la data e ora UTC\n     * @param {number | string} unix Numero formato Unix, se Null restituisce la data attuale\n     */\n    UnixToUTC(unix = null) {\n        unix = this.GetUnix(unix)\n        return new Date(unix)\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Restituisce l'offset in minuti tra la data UTC e locale\n     * @param {string | number | Date} date Data di riferimento, se Null restituisce la data attuale\n     */\n    GetTimeZone(date = null) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n\n        let offset = date.getTimezoneOffset()\n\n        if (offset <= 0) {\n            offset = Math.abs(offset)\n            offset = (offset / 60)\n            offset = Math.floor(offset)\n        } else {\n            offset = (offset / 60)\n            offset = Math.floor(offset)\n        }\n\n        return offset\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Restituisce la data e ora (UTC)\n     * @param {string | number | Date} date Data UTC di riferimento, se Null restituisce la data attuale\n     */\n    GetDateISO(date = null) {\n        date = this.GetUnix(date)\n        return (new Date(date)).toISOString()\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Restituisce la data e ora (Local Time)\n     * @param {string | number | Date} date Data UTC di riferimento, se Null restituisce la data attuale\n     * @param {boolean} en Formato inglese YYYY-MM-DD H:M:S\n     */\n    GetLocalDateTime(date = null, en = false) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n\n        let h = (new Intl.DateTimeFormat('it-IT', { timeStyle: 'long' }).format(date)).substr(0, 8).trim()\n        let y = date.getFullYear()\n        let m = (date.getMonth() + 1).toString()\n        let d = (date.getDate()).toString()\n        m = (m.length == 1) ? '0' + m : m\n        d = (d.length == 1) ? '0' + d : d\n\n        return (en) ? y + '-' + m + '-' + d + ' ' + h : d + '/' + m + '/' + y + ' ' + h\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Restituisce la data (Local Time)\n     * @param {string | number | Date} date Data UTC di riferimento, se Null restituisce la data attuale\n     * @param {boolean} en Formato inglese YYYY-MM-DD\n     */\n    GetLocalDate(date = null, en = false) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n\n        let y = date.getFullYear()\n        let m = (date.getMonth() + 1).toString()\n        let d = (date.getDate()).toString()\n        m = (m.length == 1) ? '0' + m : m\n        d = (d.length == 1) ? '0' + d : d\n\n        return (en) ? y + '-' + m + '-' + d : d + '/' + m + '/' + y\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Restituisce l'orario (Local Time)\n     * @param {string | number | Date} date Data UTC di riferimento, se Null restituisce la data attuale\n     */\n    GetLocalTime(date = null) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n        return (new Intl.DateTimeFormat('it-IT', { timeStyle: 'long' }).format(date)).substr(0, 8).trim()\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Restituisce l'ora da 0 a 23 (Local Time)\n     * @param {string | number | Date} date Data del confronto, se Null restituisce la data attuale\n     */\n    GetHours(date = null) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n        return date.getHours()\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Restituisce i minuti da 0 a 59 (Local Time)\n     * @param {string | number | Date} date Data del confronto, se Null restituisce la data attuale\n     */\n    GetMinutes(date = null) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n        return date.getMinutes()\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Restituisce i secondi da 0 a 59 (Local Time)\n     * @param {string | number | Date} date Data del confronto, se Null restituisce la data attuale\n     */\n    GetSeconds(date = null) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n        return date.getSeconds()\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Converte i minuti in orario nel formato 00:00\n    * @param {number} minutes Minuti da convertire\n     */\n    ConvMinutesToTime(minutes = 0) {\n        if (minutes === 0) { return `00:00` }\n        const h = Math.floor(minutes / 60)\n        const m = minutes % 60\n        return `${(h < 10) ? '0' : ''}${h}:${(m < 10) ? '0' : ''}${m}`\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Converte i minuti in testo letterale\n    * @param {number} minutes Minuti da convertire\n    * @param {boolean} short Testo abbreviato\n     */\n    ConvMinutesToText(minutes = 0, short = false) {\n        if (minutes === 0) { return short ? `0 m` : `0 minuti` }\n        const h = Math.floor(minutes / 60)\n        const m = minutes % 60\n\n        if (h === 0) {\n            return short ? `${m} m` : `${m} minut${(m > 1) ? 'i' : 'o'}`\n        } else {\n            if (m === 0) {\n                return short ? `${h} h` : `${h} ore`\n            } else {\n                return short ? `${h} h e ${m} m` : `${h} or${(h > 1) ? 'e' : 'a'} e ${m} minut${(m > 1) ? 'i' : 'o'}`\n            }\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Arrotondamento dei minuti per difetto o eccesso, default difetto\n     * @param {number} minutes Minuti da arrotondare\n     * @param {number} rounding Minuti di arrotondamento, default 15 minuti\n     * @param {boolean} defect Arrotondamento per difetto, default difetto\n     */\n    MinutesRounding(minutes = 0, rounding = 15, defect = true) {\n        if (minutes == 0 || rounding == 0) { return minutes }\n        if (defect) {\n            return Math.abs(minutes - (minutes % rounding))\n        } else {\n            return ((minutes % rounding) === 0) ? minutes : Math.abs(minutes - (minutes % rounding)) + rounding\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Restituisce la data di ieri (Local Time)\n     */\n    GetYesterday() {\n        var date = new Date()\n        date = this.AddDays(date, -1)\n        return this.GetLocalDate(date)\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Restituisce la data di domani (Local Time)\n     */\n    GetTomorrow() {\n        var date = new Date()\n        date = this.AddDays(date, 1)\n        return this.GetLocalDate(date)\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Restituisce il nome del giorno della settimana (Local Time)\n     * @param {string | number | Date} date Data UTC di riferimento, se Null restituisce la data attuale\n     * @param {string[]} day Array dei nomi\n     */\n    GetDayName(date = null, day = this.DAYS) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n        if (!day) day = this.DAYS\n        return day[date.getDay()]\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Restituisce il numero del giorno della settimana (Local Time)\n     * @param {string | number | Date} date Data UTC di riferimento, se Null restituisce la data attuale\n     */\n    GetDayOfWeek(date = null) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n        return date.getDay()\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Restituisce il numero del giorno del mese (Local Time)\n     * @param {string | number | Date} date Data UTC di riferimento, se Null restituisce la data attuale\n     */\n    GetDayOfMonth(date = null) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n        return date.getDate()\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Restituisce il numero dell'ultimo giorno del mese (Local Time)\n     * @param {string | number | Date} date Data UTC di riferimento, se Null restituisce la data attuale\n     */\n    GetLastDayOfMonth(date = null) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n        return new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate()\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Restituisce il nome del mese (Local Time)\n     * @param {string | number | Date} date Data UTC di riferimento, se Null restituisce la data attuale\n     * @param {string[]} month Array dei nomi\n     */\n    GetMonthName(date = null, month = this.MONTHS) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n        if (!month) month = this.MONTHS\n        return month[date.getMonth()]\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Restituisce il numero del mese (Local Time)\n     * @param {string | number | Date} date Data UTC di riferimento, se Null restituisce la data attuale\n     */\n    GetMonth(date = null) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n        return date.getMonth() + 1\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Restituisce il numero dell'anno (Local Time)\n     * @param {string | number | Date} date Data UTC di riferimento, se Null restituisce la data attuale\n     */\n    GetYear(date = null) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n        return date.getFullYear()\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Restituisce un Object con tutti i risultati (Local Time)\n     * @param {string | number | Date} date_from Data UTC inizio\n     * @param {string | number | Date} date_to Data UTC fine, se Null restituisce la data attuale\n     */\n    GetTimeElapsed(date_from, date_to = null) {\n        date_from = this.GetUnix(date_from)\n        date_from = new Date(date_from)\n        date_to = this.GetUnix(date_to)\n        date_to = new Date(date_to)\n\n        var mls = Math.abs((date_from.getTime() - date_to.getTime()))\n        mls = Math.round(mls)\n\n        var milliseconds = mls / 1000\n        var years = Math.floor(milliseconds / 31536000)\n        var days = Math.floor((milliseconds % 31536000) / 86400)\n        var hours = Math.floor(((milliseconds % 31536000) % 86400) / 3600)\n        var minutes = Math.floor((((milliseconds % 31536000) % 86400) % 3600) / 60)\n        var seconds = Math.floor((((milliseconds % 31536000) % 86400) % 3600) % 60)\n\n        var levels = [\n            [years, ((years > 1) ? 'anni' : 'anno')],\n            [days, ((days > 1) ? 'giorni' : 'giorno')],\n            [hours, ((hours > 1) ? 'ore' : 'ora')],\n            [minutes, ((minutes > 1) ? 'minuti' : 'minuto')],\n            [seconds, ((seconds > 1) ? 'secondi' : 'secondo')],\n        ]\n\n        var description = ''\n\n        for (var i = 0, max = levels.length; i < max; i++) {\n            if (levels[i][0] === 0) continue\n            description += ' ' + levels[i][0] + ' ' + levels[i][1]\n        }\n\n        description = description.trim()\n        description = (description == '') ? '1 secondo' : description\n\n        return {\n            start: date_from,\n            end: date_to,\n            description: description,\n            years: years,\n            days: Math.floor(mls / (1000 * 60 * 60 * 24)),\n            hours: Math.floor(mls / (1000 * 60 * 60)),\n            minutes: Math.floor(mls / (1000 * 60)),\n            seconds: Math.floor(mls / 1000),\n            milliseconds: mls\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Aggiunge o rimuove giorni alla data (Local Time)\n     * @param {string | number | Date} date Data UTC di riferimento, se Null restituisce la data attuale\n     * @param {number} days Numero di giorni da aggiungere o rimuovere\n     */\n    AddDays(date = null, days = 0) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n        if (!days) days = 0\n        date.setDate(date.getDate() + days)\n        return date\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Verifica se la data √® valida nel formato dd/mm/yyyy oppure dd-mm-yyyy\n     * @param {string} text Data da verificare nel formato dd/mm/yyyy oppure dd-mm-yyyy\n     */\n    IsValidDateInput(text) {\n        try {\n            text = text.replace(/ /gm, '')\n\n            if (text.match(/^(0?[1-9]|[12][0-9]|3[01])[\\/\\-](0?[1-9]|1[012])[\\/\\-]\\d{4}$/)) {\n                var opera1 = text.split('/')\n                var opera2 = text.split('-')\n                var lopera1 = opera1.length\n                var lopera2 = opera2.length\n                var pdate\n\n                if (lopera1 > 1) {\n                    pdate = text.split('/')\n                } else if (lopera2 > 1) {\n                    pdate = text.split('-')\n                }\n\n                var dd = parseInt(pdate[0])\n                var mm = parseInt(pdate[1])\n                var yy = parseInt(pdate[2])\n                var ListofDays = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n                if (mm == 1 || mm > 2) {\n                    if (dd > ListofDays[mm - 1]) { return false }\n                }\n\n                if (mm == 2) {\n                    var lyear = false\n                    if ((!(yy % 4) && yy % 100) || !(yy % 400)) { lyear = true }\n                    if ((lyear == false) && (dd >= 29)) { return false }\n                    if ((lyear == true) && (dd > 29)) { return false }\n                }\n            } else {\n                return false\n            }\n        } catch (error) {\n            return false\n        }\n\n        return true\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Stabilisce se la data indicata √® quella attuale (Local Time)\n     * @param {string | number | Date} date Data di riferimento, se Null restituisce falso\n     */\n    IsToday(date = null) {\n        if (date === null || date === undefined) { return false }\n        date = this.GetUnix(date)\n        date = new Date(date)\n        return (this.GetLocalDate(date) == this.GetLocalDate())\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Stabilisce se la data indicata √® quella di ieri (Local Time)\n     * @param {string | number | Date} date Data di riferimento, se Null restituisce falso\n     */\n    IsYesterday(date = null) {\n        if (date === null || date === undefined) { return false }\n        date = this.GetUnix(date)\n        date = new Date(date)\n        var yesterday = this.AddDays(new Date(), -1)\n        return (this.GetLocalDate(date) == this.GetLocalDate(yesterday))\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Stabilisce se la data indicata √® quella di domani (Local Time)\n     * @param {string | number | Date} date Data di riferimento, se Null restituisce falso\n     */\n    IsTomorrow(date = null) {\n        if (date === null || date === undefined) { return false }\n        date = this.GetUnix(date)\n        date = new Date(date)\n        var tomorrow = this.AddDays(new Date(), 1)\n        return (this.GetLocalDate(date) == this.GetLocalDate(tomorrow))\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Confronta due date (Local Time)\n     * @param {string | number | Date} date1 Prima data del confronto, se Null restituisce la data attuale\n     * @param {string | number | Date} date2 Seconda data del confronto, se Null restituisce la data attuale\n     */\n    IsThisDay(date1 = null, date2 = null) {\n        date1 = this.GetUnix(date1)\n        date1 = new Date(date1)\n        date2 = this.GetUnix(date2)\n        date2 = new Date(date2)\n        return (this.GetLocalDate(date1) == this.GetLocalDate(date2))\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Stabilisce se la data indicata √® quella attuale (Local Time)\n     * @param {string | number | Date} date Data da valutare, se Null restituisce falso\n     */\n    IsBirthday(date = null) {\n        if (date === null || date === undefined) { return false }\n        date = this.GetUnix(date)\n        date = new Date(date)\n        let today = new Date()\n        return (date.getMonth() == today.getMonth() && date.getDate() == today.getDate())\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Verifica se la data rientra in un intervallo tra due date\n     * @param {string | number | Date} date Data del confronto, se Null restituisce la data attuale\n     * @param {string | number | Date} date1 Data inizio range, se Null restituisce la data attuale\n     * @param {string | number | Date} date2 Data fine range, se Null restituisce la data attuale\n     */\n    IsBetweenDate(date = null, date1 = null, date2 = null) {\n        date = this.GetUnix(date)\n        date = new Date(date).valueOf()\n        date1 = this.GetUnix(date1)\n        date1 = new Date(date1).valueOf()\n        date2 = this.GetUnix(date2)\n        date2 = new Date(date2).valueOf()\n        return (date > date1 && date < date2)\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Verifica se la data rientra in un intervallo orario (Local Time)\n     * @param {string | number | Date} date Data del confronto, se Null restituisce la data attuale\n     * @param {number} hour1 Ora inizio intervallo\n     * @param {number} hour2 Ora fine intervallo\n     */\n    IsBetweenTime(date = null, hour1 = 0, hour2 = 23) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n        let hour = date.getHours()\n        return (hour >= hour1 && hour <= hour2)\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Verifica se una data √® superiore ad un altra data\n     * @param {string | number | Date} date1 Prima data del confronto, se Null restituisce la data attuale\n     * @param {string | number | Date} date2 Seconda data del confronto, se Null restituisce la data attuale\n     */\n    IsAfterDate(date1 = null, date2 = null) {\n        date1 = this.GetUnix(date1)\n        date1 = new Date(date1).valueOf()\n        date2 = this.GetUnix(date2)\n        date2 = new Date(date2).valueOf()\n        return (date1 > date2)\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Verifica se una data √® inferiore ad un altra data\n     * @param {string | number | Date} date1 Prima data del confronto, se Null restituisce la data attuale\n     * @param {string | number | Date} date2 Seconda data del confronto, se Null restituisce la data attuale\n     */\n    IsBeforeDate(date1 = null, date2 = null) {\n        date1 = this.GetUnix(date1)\n        date1 = new Date(date1).valueOf()\n        date2 = this.GetUnix(date2)\n        date2 = new Date(date2).valueOf()\n        return (date1 < date2)\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Verifica se una data √® uguale ad un altra data\n     * @param {string | number | Date} date1 Prima data del confronto, se Null restituisce la data attuale\n     * @param {string | number | Date} date2 Seconda data del confronto, se Null restituisce la data attuale\n     */\n    IsSameDate(date1 = null, date2 = null) {\n        date1 = this.GetUnix(date1)\n        date1 = new Date(date1).valueOf()\n        date2 = this.GetUnix(date2)\n        date2 = new Date(date2).valueOf()\n        return (date1 == date2)\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Verifica se l'ora √® superiore ad un numero che va da 0 a 23 (Local Time)\n     * @param {string | number | Date} date Data del confronto, se Null restituisce la data attuale\n     * @param {number} hour Ora del confronto\n     */\n    IsAfterTime(date = null, hour = 0) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n        let hour_date = date.getHours()\n        return (hour_date > hour)\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Verifica se l'ora √® uguale ad un numero che va da 0 a 23 (Local Time)\n     * @param {string | number | Date} date Data del confronto, se Null restituisce la data attuale\n     * @param {number} hour Ora del confronto\n     */\n    IsSameTime(date = null, hour = 0) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n        let hour_date = date.getHours()\n        return (hour_date == hour)\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Verifica se l'ora √® uguale o superiore ad un numero che va da 0 a 23 (Local Time)\n     * @param {string | number | Date} date Data del confronto, se Null restituisce la data attuale\n     * @param {number} hour Ora del confronto\n     */\n    IsSameOrAfterTime(date = null, hour = 0) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n        let hour_date = date.getHours()\n        return (hour_date >= hour)\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Verifica se l'ora √® inferiore ad un numero che va da 0 a 23 (Local Time)\n     * @param {string | number | Date} date Data del confronto, se Null restituisce la data attuale\n     * @param {number} hour Ora del confronto\n     */\n    IsBeforeTime(date = null, hour = 0) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n        let hour_date = date.getHours()\n        return (hour_date < hour)\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Verifica se l'ora √® uguale o inferiore ad un numero che va da 0 a 23 (Local Time)\n     * @param {string | number | Date} date Data del confronto, se Null restituisce la data attuale\n     * @param {number} hour Ora del confronto\n     */\n    IsSameOrBeforeTime(date = null, hour = 0) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n        let hour_date = date.getHours()\n        return (hour_date <= hour)\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Stabilisce se una data √® \"after\" o \"before\" rispetto ad un'altra data\n     * @param {string | number | Date} date1 Prima data del confronto, se Null restituisce la data attuale\n     * @param {string | number | Date} date2 Seconda data del confronto, se Null restituisce la data attuale\n     */\n    IsAfterOrBeforeDate(date1 = null, date2 = null) {\n        date1 = this.GetUnix(date1)\n        date1 = new Date(date1).valueOf()\n        date2 = this.GetUnix(date2)\n        date2 = new Date(date2).valueOf()\n        return (date1 < date2) ? 'before' : 'after'\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Stabilisce se l'ora legale √® in vigore\n     * @param {string | number | Date} date Data di riferimento, se Null restituisce la data attuale\n     */\n    IsDST(date = null) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n\n        const january = new Date(date.getFullYear(), 0, 1).getTimezoneOffset()\n        const july = new Date(date.getFullYear(), 6, 1).getTimezoneOffset()\n\n        return (Math.max(january, july) !== date.getTimezoneOffset())\n    }\n\n    //DATE\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    // DATE - HOLIDAY AND WORKDAY\n\n    /**\n     * Restituisce la data UTC del giorno di Pasqua in base all'anno\n     * @param {string | number | Date} date Data UTC di riferimento, se Null restituisce la data attuale\n     */\n    Easter(date = null) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n\n        let a, b, c, d, e, M, N\n        let Y = new Date(date).getFullYear()\n        let day, month\n        let year = new Date(date).getFullYear()\n\n        if (Y < 2099) {\n            M = 24\n            N = 5\n        } else if (Y < 2199) {\n            M = 24\n            N = 6\n        } else if (Y < 2299) {\n            M = 25\n            N = 0\n        } else if (Y < 2399) {\n            M = 26\n            N = 1\n        } else if (Y < 2499) {\n            M = 25\n            N = 1\n        }\n\n        a = Y % 19\n        b = Y % 4\n        c = Y % 7\n        d = ((19 * a) + M) % 30\n        e = ((2 * b) + (4 * c) + (6 * d) + N) % 7\n\n        if (d + e < 10) {\n            day = d + e + 22\n            month = 3\n        } else {\n            day = d + e - 9\n            month = 4\n        }\n\n        if (day == 26 && month == 4) {\n            day = 19\n            month = 4\n        }\n\n        if (day == 25 && month == 4 && d == 28 && e == 6 && a > 10) {\n            day = 18\n            month = 4\n        }\n\n        day = (day < 10) ? `0${day}` : `${day}`\n        month = (month < 10) ? `0${month}` : `${month}`\n        return (new Date(`${year}-${month}-${day}T00:00:00.000Z`))\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    // DATE - HOLIDAY AND WORKDAY\n\n    /**\n     * Restituisce la data UTC del giorno di Luned√¨ dell'Angelo in base all'anno\n     * @param {string | number | Date} date Data UTC di riferimento, se Null restituisce la data attuale\n     */\n    EasterMonday(date = null) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n        let easter = this.Easter(date)\n        return this.AddDays(new Date(easter), 1)\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    // DATE - HOLIDAY AND WORKDAY\n\n    /**\n     * Restituisce il nome della festa nazionale, patronale o domenica (Local Time)\n     * @param {string | number | Date} date Data UTC di riferimento, se Null restituisce la data attuale\n     */\n    GetHoliday(date = null) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n\n        //Pasqua\n        if (this.IsEaster(date)) return \"Pasqua\"\n        //Luned√¨ dell'Angelo\n        if (this.IsEasterMonday(date)) return \"Luned√¨ dell'Angelo\"\n        //giorno del mese\n        const day = date.getDate()\n        //0 Gennaio - 11 Dicembre\n        const month = (date.getMonth() + 1)\n        //festa patronale\n        if (day == 29 && month == 8) return \"San Giovanni Battista\"\n        //feste nazionali\n        if (day == 1 && month == 1) {\n            //Capodanno\n            return \"Capodanno\"\n        } else if (day == 6 && month == 1) {\n            //Epifania\n            return \"Epifania\"\n        } else if (day == 25 && month == 4) {\n            //Festa della Liberazione\n            return \"Festa della Liberazione\"\n        } else if (day == 1 && month == 5) {\n            //Festa del Lavoro\n            return \"Festa del Lavoro\"\n        } else if (day == 2 && month == 6) {\n            //Festa della Repubblica\n            return \"Festa della Repubblica\"\n        } else if (day == 15 && month == 8) {\n            //Assunzione di Maria\n            return \"Assunzione di Maria\"\n        } else if (day == 1 && month == 11) {\n            //Ognissanti\n            return \"Ognissanti\"\n        } else if (day == 8 && month == 12) {\n            //Immacolata Concezione\n            return \"Immacolata Concezione\"\n        } else if (day == 25 && month == 12) {\n            //Natale del Signore\n            return \"Natale del Signore\"\n        } else if (day == 26 && month == 12) {\n            //Santo Stefano\n            return \"Santo Stefano\"\n        } else if (date.getDay() == 0) {\n            //Domenica\n            return \"Domenica\"\n        }\n\n        return null\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    // DATE - HOLIDAY AND WORKDAY\n\n    /**\n     * Restituisce la prossima festa nazionale o patronale, no domenica (Local Time)\n     * @param {string | number | Date} date Data UTC di riferimento, se Null restituisce la data attuale\n     */\n    GetNextHoliday(date = null) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n\n        for (let day = 1; day < 365; day++) {\n            const today = this.AddDays(date, day)\n\n            if (this.IsHoliday(today)) {\n                const holiday = this.GetHoliday(today)\n                if (holiday != 'Domenica') {\n                    return {\n                        date: today,\n                        holiday: holiday,\n                        estimated_days: this.GetTimeElapsed(date, today).days,\n                        estimated_desc: this.GetTimeElapsed(date, today).description\n                    }\n                }\n            }\n        }\n\n        return {\n            date: null,\n            holiday: null,\n            estimated_days: null,\n            estimated_desc: null\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    // DATE - HOLIDAY AND WORKDAY\n\n    /**\n     * Verifica se la data indicata √® il giorno di Pasqua (Local Time)\n     * @param {string | number | Date} date Data UTC di riferimento, se Null restituisce la data attuale\n     */\n    IsEaster(date = null) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n        let easter = this.Easter(date)\n        return (new Intl.DateTimeFormat('it-IT').format(easter) == new Intl.DateTimeFormat('it-IT').format(date))\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    // DATE - HOLIDAY AND WORKDAY\n\n    /**\n     * Verifica se la data indicata √® il giorno di Luned√¨ dell'Angelo (Local Time)\n     * @param {string | number | Date} date Data UTC di riferimento, se Null restituisce la data attuale\n     */\n    IsEasterMonday(date = null) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n        let easter = this.EasterMonday(date)\n        return (new Intl.DateTimeFormat('it-IT').format(easter) == new Intl.DateTimeFormat('it-IT').format(date))\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    // DATE - HOLIDAY AND WORKDAY\n\n    /**\n     * Verifica se la data indicata √® un giorno lavorativo (Local Time)\n     * @param {string | number | Date} date Data UTC di riferimento, se Null restituisce la data attuale\n     */\n    IsWorkday(date = null) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n        if (this.IsHoliday(date)) return false\n        //escludi sabato e domenica\n        let day = date.getDay()\n        //0 Domenica - 6 Sabato\n        return (day > 0 && day < 6)\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    // DATE - HOLIDAY AND WORKDAY\n\n    /**\n     * Verifica se la data indicata √® una festa nazionale, patronale oppure domenica (Local Time)\n     * @param {string | number | Date} date Data UTC di riferimento, se Null restituisce la data attuale\n     */\n    IsHoliday(date = null) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n\n        //Pasqua\n        if (this.IsEaster(date)) return true\n        //Luned√¨ dell'Angelo\n        if (this.IsEasterMonday(date)) return true\n        //giorno del mese\n        const day = date.getDate()\n        //0 Gennaio - 11 Dicembre\n        const month = (date.getMonth() + 1)\n        //festa patronale\n        if (day == 29 && month == 8) return true\n        //feste nazionali\n        if (day == 1 && month == 1) {\n            //Capodanno\n            return true\n        } else if (day == 6 && month == 1) {\n            //Epifania\n            return true\n        } else if (day == 25 && month == 4) {\n            //Festa della Liberazione\n            return true\n        } else if (day == 1 && month == 5) {\n            //Festa del Lavoro\n            return true\n        } else if (day == 2 && month == 6) {\n            //Festa della Repubblica\n            return true\n        } else if (day == 15 && month == 8) {\n            //Assunzione di Maria\n            return true\n        } else if (day == 1 && month == 11) {\n            //Ognissanti\n            return true\n        } else if (day == 8 && month == 12) {\n            //Immacolata Concezione\n            return true\n        } else if (day == 25 && month == 12) {\n            //Natale del Signore\n            return true\n        } else if (day == 26 && month == 12) {\n            //Santo Stefano\n            return true\n        } else if (date.getDay() == 0) {\n            //Domenica\n            return true\n        }\n\n        return false\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    // DATE - HOLIDAY AND WORKDAY\n\n    /**\n     * Verifica se la data indicata √® prefestivo, sabato (Local Time)\n     * @param {string | number | Date} date Data UTC di riferimento, se Null restituisce la data attuale\n     */\n    IsPreHoliday(date = null) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n        if (this.IsHoliday(date)) return false\n        //0 Domenica - 6 Sabato\n        return (date.getDay() == 6)\n    }\n\n    // DATE - HOLIDAY AND WORKDAY\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE - PART OF DAY\n\n    /**\n     * Restituisce il saluto per le conversazioni (Local Time)\n     * @param {string | number | Date} date Data UTC di riferimento, se Null restituisce la data attuale\n     * @param {boolean} greeting_end Saluto di fine conversazione\n     */\n    GetGreeting(date = null, greeting_end = false) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n        let hour = date.getHours()\n\n        if (hour >= 0 && hour <= 5) {\n            return greeting_end ? 'Buona notte' : 'Ciao'\n        } else if (hour >= 6 && hour <= 12) {\n            return greeting_end ? 'Buona giornata' : 'Buongiorno'\n        } else if (hour >= 13 && hour <= 18) {\n            return \"Buon pomeriggio\"\n        } else if (hour >= 19 && hour <= 21) {\n            return greeting_end ? 'Buona serata' : 'Buonasera'\n        } else if (hour >= 22 && hour <= 23) {\n            return greeting_end ? 'Buona notte' : 'Buonasera'\n        } else {\n            return greeting_end ? 'Arrivederci' : 'Ciao'\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE - PART OF DAY\n\n    /**\n     * Restituisce la parte del giorno (Local Time)\n     * @param {string | number | Date} date Data UTC di riferimento, se Null restituisce la data attuale\n     */\n    GetPartOfDay(date = null) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n\n        let hour = date.getHours()\n\n        if (hour == 0) {\n            return \"Mezzanotte\"\n        } else if (hour >= 1 && hour <= 5) {\n            return \"Notte\"\n        } else if (hour >= 6 && hour <= 11) {\n            return \"Mattina\"\n        } else if (hour == 12) {\n            return \"Mezzogiorno\"\n        } else if (hour >= 13 && hour <= 17) {\n            return \"Pomeriggio\"\n        } else if (hour >= 18 && hour <= 23) {\n            return \"Sera\"\n        } else {\n            return \"Sconosciuto\"\n        }\n    }\n\n    //DATE - PART OF DAY\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //GEO FUNCTIONS\n\n    /**\n     * Calcola la distanza tra due punti in base alle coordinate\n     * @param {Array} point1 Coordinate punto 1 ['lat', 'lon']\n     * @param {Array} point2 Coordinate punto 2 ['lat', 'lon']\n     * @param {number} plus Percentuale incremento della distanza tra i due punti, default 39% in pi√π\n     */\n    GetDistance(point1 = [0, 0], point2 = [0, 0], plus = 39) {\n        if (!Array.isArray(point1) || !Array.isArray(point2)) {\n            return {\n                distance: 0,\n                meters: 0,\n                kilometers: 0,\n                minutes: 0,\n                speed: 0\n            }\n        }\n\n        var deltaLat = (point2[0] - point1[0]) * Math.PI / 180\n        var deltaLon = (point2[1] - point1[1]) * Math.PI / 180\n\n        point1[0] = point1[0] * Math.PI / 180\n        point2[0] = point2[0] * Math.PI / 180\n\n        var a = Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) + Math.cos(point1[0]) * Math.cos(point2[0]) * Math.sin(deltaLon / 2) * Math.sin(deltaLon / 2)\n        var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))\n        var ds = Math.round(c * 6371000)\n        var mt = Math.round(ds + (ds / 100 * plus))\n        var km = Math.round((ds + (ds / 100 * plus)) / 1000)\n        var speed = 1.25\n\n        if (km <= 20) {\n            speed = 0.7\n        } else if (km > 20 && km <= 40) {\n            speed = 0.8\n        } else if (km > 40 && km <= 60) {\n            speed = 0.9\n        } else if (km > 60 && km <= 80) {\n            speed = 1.0\n        }\n\n        var min = Math.round(km / speed)\n\n        if (min < 5) {\n            min = 0\n            speed = 0\n        } else {\n            min = ((min % 15) === 0) ? min : Math.abs(min - (min % 15)) + 15\n            speed = Math.floor((mt * 3600 / (min * 60)) / 1000) || 0\n            speed = Math.abs(speed)\n        }\n\n        return {\n            distance: ds,\n            meters: mt,\n            kilometers: km,\n            minutes: min,\n            speed: (speed < 0 || speed > 10000 || speed === NaN || speed === Infinity || isNaN(speed)) ? 0 : speed\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //GEO FUNCTIONS\n\n    /**\n     * Restituisce la velocit√† media di percorrenza\n     * @param {number} minutes Minuti di viaggio impiegati\n     * @param {number} meters Metri percorsi\n     */\n    GetAverageSpeed(minutes, meters) {\n        if (minutes < 1 || meters < 1) { return 0 }\n        let speed = Math.floor((meters * 3600 / (minutes * 60)) / 1000)\n        speed = Math.abs(speed)\n        return (speed < 0 || speed > 10000 || speed === NaN || speed === Infinity || isNaN(speed)) ? 0 : speed\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //GEO FUNCTIONS\n\n    /**\n     * Restituisce il link di Google Maps con il segnaposto\n     * @param {string} geocode Coordinate GPS nel formato latitudine,longitudine\n     * @param {boolean} encode Codifica URI\n     */\n    GetGoogleMapsPlaceholder(geocode = null, encode = true) {\n        //https://developers.google.com/maps/documentation/urls/get-started\n        if (geocode === null || geocode === undefined) {\n            if (encode) {\n                encodeURIComponent('https://www.google.com/maps')\n            } else {\n                return 'https://www.google.com/maps'\n            }\n        } else {\n            if (encode) {\n                return encodeURIComponent(`https://www.google.com/maps/search/?api=1&query=${geocode}`)\n            } else {\n                return `https://www.google.com/maps/search/?api=1&query=${geocode}`\n            }\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //ASTRO FUNCTIONS\n\n    /**\n     * Restituisce le informazioni sulla fase lunare (Local Time)\n     * @param {string | number | Date} date Data UTC di riferimento, se Null restituisce la data attuale\n    */\n    MoonPhase(date = null) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n\n        let year = date.getFullYear()\n        let month = date.getMonth() + 1\n        let day = date.getDate()\n\n        var icon = [\n            'üåë',\n            'üåí',\n            'üåì',\n            'üåî',\n            'üåï',\n            'üåñ',\n            'üåó',\n            'üåò'\n        ]\n\n        var name = [\n            'Nuova',\n            'Crescente',\n            'Primo quarto',\n            'Gibbosa crescente',\n            'Piena',\n            'Gibbosa calante',\n            'Ultimo quarto',\n            'Calante'\n        ]\n\n        var description = [\n            'La Luna ed il Sole sono congiunti e nello stesso segno. Un ottimo periodo per nuove opportunit√† e nuovi inizi. Si incomincia! La nascita. Rappresenta l‚Äôinizio, il seme germoglia sottoterra. Questo √® il momento di sperimentare, anche se non sai se il progetto avr√† buon fine. Tendi ad essere soggettivo ed egocentrico.Le regole degli altri non fanno per te.',\n            'Met√† strada tra Luna nuova e Primo quarto. Ottimo per le nuove idee e nuove energie, per coltivare le attivit√† prescelte. Devi fare i conti con l‚Äôambiente circostante, che pu√≤ sembrare difficile e ostile. Ma vai avanti incontro al nuovo, supera le resistenze.',\n            'La Luna √® a 90¬∞ dal Sole. La creazione. √à il momento di accettare la responsabilit√† di quanto abbiamo avviato. Metti le foglie e rami, un periodo di grande crescita. Esercita il massimo sforzo per raggiungere i tuoi obiettivi.',\n            'A met√† strada tra il primo quarto e luna piena. Ottimo per pianificare, individuare strategie e ridefinire i concetti. Il germoglio comincia a formarsi, portando in s√© la promessa del fiore. Avanti con il nuovo, senti che deve essere perfezionato per raggiungere il suo vero potenziale.',\n            'La Luna e Sole sono in opposizione, su lati opposti della Terra. Periodo di padronanza e completamento.Viva i risultati! √à ora di cominciare a chiudere e tirare le somme. Il fiore emerge. Sei consapevole degli effetti del tuo lavoro sugli altri.quindi la parola d‚Äôordine √®: obiettivit√†. Sei aperto all‚Äôinfluenza di coloro che ti circondano, e consapevole dell‚Äôinfluenza che puoi avere su di loro.',\n            'A met√† strada tra la Luna Piena e l‚Äôultimo quarto. Valuta e riconosci i risultati.Osserva, rivedi, ottimizza e scarta quello che non funziona. Inizia a consolidare. Compare il frutto della pianta. Sai cosa hai realizzato, condividilo con gli altri.',\n            'La Luna √® calante e a 90¬∞ dal Sole. Periodo di riflessione e ristrutturazione.Viva l‚Äôintrospezione. √à il raccolto, le parti restanti appassiscono e muoiono. Abbatti la vecchia struttura e prepara la via al nuovo. √à il tempo per le ‚Äúcrisi di coscienza‚Äù e far nascere un nuovo desiderio di cambiare.',\n            'A met√† strada tra l‚ÄôUltimo Quarto e la Luna Nuova. Butta via quello che non serve pi√π.Consolida e chiudi. √à il momento della maturazione del seme. Tutta l‚Äôenergia si concentra nel diventare seme per il ciclo successivo. La realt√† diventa lontana, e sei un po‚Äô alienato dalla struttura della societ√†. Contribuisci a preparare la strada per qualcosa di nuovo, scrollarti di dosso i resti del passato.'\n        ]\n\n        var c = 0\n        var e = 0\n        var jd = 0\n        var b = 0\n\n        if (month < 3) {\n            year--\n            month += 12\n        }\n\n        ++month\n        c = 365.25 * year\n        e = 30.6 * month\n        jd = c + e + day - 694039.09\n        jd /= 29.5305882\n        b = parseInt(jd)\n        jd -= b\n        b = Math.round(jd * 8)\n        if (b >= 8) { b = 0 }\n\n        return {\n            phase: b + 1,\n            icon: icon[b],\n            name: name[b],\n            description: description[b]\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //ASTRO FUNCTIONS\n\n    /**\n     * Restituisce il segno zodiacale (Local Time)\n     * @param {string | number | Date} date Data UTC di riferimento, se Null restituisce la data attuale\n    */\n    ZodiacSign(date = null) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n        var month = date.getMonth() + 1\n        var day = date.getDate()\n\n        if (month == 1 && day <= 19) { return { icon: \"‚ôëÔ∏è\", sign: \"Capricorno\", element: \"Terra\", season: \"Inverno\", type: \"Cardinale\", description: \"Segno di iniziativa e creativit√†\" } }\n        if (month == 1 && day >= 20) { return { icon: \"‚ôíÔ∏è\", sign: \"Acquario\", element: \"Aria\", season: \"Inverno\", type: \"Fisso\", description: \"Segno di stabilit√† e determinazione\" } }\n        if (month == 2 && day <= 18) { return { icon: \"‚ôíÔ∏è\", sign: \"Acquario\", element: \"Aria\", season: \"Inverno\", type: \"Fisso\", description: \"Segno di stabilit√† e determinazione\" } }\n        if (month == 2 && day >= 19) { return { icon: \"‚ôìÔ∏è\", sign: \"Pesci\", element: \"Acqua\", season: \"Inverno\", type: \"Mobile\", description: \"Segno di ingegno e adattamento\" } }\n        if (month == 3 && day <= 20) { return { icon: \"‚ôìÔ∏è\", sign: \"Pesci\", element: \"Acqua\", season: \"Inverno\", type: \"Mobile\", description: \"Segno di ingegno e adattamento\" } }\n        if (month == 3 && day >= 21) { return { icon: \"‚ôàÔ∏è\", sign: \"Ariete\", element: \"Fuoco\", season: \"Primavera\", type: \"Cardinale\", description: \"Segno di iniziativa e creativit√†\" } }\n        if (month == 4 && day <= 20) { return { icon: \"‚ôàÔ∏è\", sign: \"Ariete\", element: \"Fuoco\", season: \"Primavera\", type: \"Cardinale\", description: \"Segno di iniziativa e creativit√†\" } }\n        if (month == 4 && day >= 21) { return { icon: \"‚ôâÔ∏è\", sign: \"Toro\", element: \"Terra\", season: \"Primavera\", type: \"Fisso\", description: \"Segno di stabilit√† e determinazione\" } }\n        if (month == 5 && day <= 20) { return { icon: \"‚ôâÔ∏è\", sign: \"Toro\", element: \"Terra\", season: \"Primavera\", type: \"Fisso\", description: \"Segno di stabilit√† e determinazione\" } }\n        if (month == 5 && day >= 21) { return { icon: \"‚ôäÔ∏è\", sign: \"Gemelli\", element: \"Aria\", season: \"Primavera\", type: \"Mobile\", description: \"Segno di ingegno e adattamento\" } }\n        if (month == 6 && day <= 20) { return { icon: \"‚ôäÔ∏è\", sign: \"Gemelli\", element: \"Aria\", season: \"Primavera\", type: \"Mobile\", description: \"Segno di ingegno e adattamento\" } }\n        if (month == 6 && day >= 21) { return { icon: \"‚ôãÔ∏è\", sign: \"Cancro\", element: \"Acqua\", season: \"Estate\", type: \"Cardinale\", description: \"Segno di iniziativa e creativit√†\" } }\n        if (month == 7 && day <= 21) { return { icon: \"‚ôãÔ∏è\", sign: \"Cancro\", element: \"Acqua\", season: \"Estate\", type: \"Cardinale\", description: \"Segno di iniziativa e creativit√†\" } }\n        if (month == 7 && day >= 22) { return { icon: \"‚ôåÔ∏è\", sign: \"Leone\", element: \"Fuoco\", season: \"Estate\", type: \"Fisso\", description: \"Segno di stabilit√† e determinazione\" } }\n        if (month == 8 && day <= 21) { return { icon: \"‚ôåÔ∏è\", sign: \"Leone\", element: \"Fuoco\", season: \"Estate\", type: \"Fisso\", description: \"Segno di stabilit√† e determinazione\" } }\n        if (month == 8 && day >= 22) { return { icon: \"‚ôçÔ∏è\", sign: \"Vergine\", element: \"Terra\", season: \"Estate\", type: \"Mobile\", description: \"Segno di ingegno e adattamento\" } }\n        if (month == 9 && day <= 21) { return { icon: \"‚ôçÔ∏è\", sign: \"Vergine\", element: \"Terra\", season: \"Estate\", type: \"Mobile\", description: \"Segno di ingegno e adattamento\" } }\n        if (month == 9 && day >= 22) { return { icon: \"‚ôéÔ∏è\", sign: \"Bilancia\", element: \"Aria\", season: \"Autunno\", type: \"Cardinale\", description: \"Segno di iniziativa e creativit√†\" } }\n        if (month == 10 && day <= 21) { return { icon: \"‚ôéÔ∏è\", sign: \"Bilancia\", element: \"Aria\", season: \"Autunno\", type: \"Cardinale\", description: \"Segno di iniziativa e creativit√†\" } }\n        if (month == 10 && day >= 22) { return { icon: \"‚ôèÔ∏è\", sign: \"Scorpione\", element: \"Acqua\", season: \"Autunno\", type: \"Fisso\", description: \"Segno di stabilit√† e determinazione\" } }\n        if (month == 11 && day <= 21) { return { icon: \"‚ôèÔ∏è\", sign: \"Scorpione\", element: \"Acqua\", season: \"Autunno\", type: \"Fisso\", description: \"Segno di stabilit√† e determinazione\" } }\n        if (month == 11 && day >= 22) { return { icon: \"‚ôêÔ∏è\", sign: \"Sagittario\", element: \"Fuoco\", season: \"Autunno\", type: \"Mobile\", description: \"Segno di ingegno e adattamento\" } }\n        if (month == 12 && day <= 20) { return { icon: \"‚ôêÔ∏è\", sign: \"Sagittario\", element: \"Fuoco\", season: \"Autunno\", type: \"Mobile\", description: \"Segno di ingegno e adattamento\" } }\n        if (month == 12 && day >= 21) { return { icon: \"‚ôëÔ∏è\", sign: \"Capricorno\", element: \"Terra\", season: \"Inverno\", type: \"Cardinale\", description: \"Segno di iniziativa e creativit√†\" } }\n\n        return { icon: null, sign: null, element: null, season: null, type: null, description: null }\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //ASTRO FUNCTIONS\n\n}\n\n////////////////////////////////////////////////////////////////////\nvar version_tools = '3.6.5 del 02/01/2023'\n////////////////////////////////////////////////////////////////////\nglobal.set('Tools', { class: Tools, version: version_tools, date_start: Date.now() })\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n//Tools Class Collections Javascript for Node-RED///////////////////",
        "finalize": "",
        "libs": [],
        "x": 200,
        "y": 380,
        "wires": []
    },
    {
        "id": "e5df7a9578d68238",
        "type": "function",
        "z": "799d902a165e50be",
        "name": "Original message",
        "func": "return msg.original_message || msg",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 905,
        "y": 160,
        "wires": [
            []
        ],
        "l": false
    },
    {
        "id": "4bebee7279e15eae",
        "type": "delay",
        "z": "799d902a165e50be",
        "name": "",
        "pauseType": "delay",
        "timeout": "500",
        "timeoutUnits": "milliseconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "250",
        "randomLast": "500",
        "randomUnits": "milliseconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 695,
        "y": 220,
        "wires": [
            []
        ],
        "l": false
    },
    {
        "id": "8a32a3bce6dbb797",
        "type": "delay",
        "z": "799d902a165e50be",
        "name": "",
        "pauseType": "rate",
        "timeout": "500",
        "timeoutUnits": "milliseconds",
        "rate": "2",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "250",
        "randomLast": "500",
        "randomUnits": "milliseconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 695,
        "y": 160,
        "wires": [
            [
                "f2185d81a99762d2"
            ]
        ],
        "l": false
    },
    {
        "id": "f4e02ac3663daad1",
        "type": "subflow:799d902a165e50be",
        "z": "b47fd0e48cfbee58",
        "name": "",
        "x": 120,
        "y": 60,
        "wires": [
            [],
            [],
            []
        ]
    }
]