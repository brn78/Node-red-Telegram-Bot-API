[
    {
        "id": "799d902a165e50be",
        "type": "subflow",
        "name": "Telegram API receiver",
        "category": "Telegram Bot API",
        "in": [],
        "out": [
            {
                "x": 840,
                "y": 40,
                "wires": [
                    {
                        "id": "85c287a9917d09e6",
                        "port": 0
                    },
                    {
                        "id": "d868daa626a6f515",
                        "port": 0
                    }
                ]
            },
            {
                "x": 840,
                "y": 100,
                "wires": [
                    {
                        "id": "e5df7a9578d68238",
                        "port": 0
                    },
                    {
                        "id": "f2185d81a99762d2",
                        "port": 0
                    }
                ]
            },
            {
                "x": 840,
                "y": 220,
                "wires": [
                    {
                        "id": "4bebee7279e15eae",
                        "port": 0
                    }
                ]
            }
        ],
        "env": [
            {
                "name": "url",
                "type": "str",
                "value": "https://api.telegram.org",
                "ui": {
                    "icon": "font-awesome/fa-link",
                    "label": {
                        "en-US": "Url:"
                    },
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "token",
                "type": "str",
                "value": "",
                "ui": {
                    "icon": "font-awesome/fa-user-secret",
                    "label": {
                        "en-US": "Token:"
                    },
                    "type": "input",
                    "opts": {
                        "types": [
                            "str"
                        ]
                    }
                }
            },
            {
                "name": "stop_service",
                "type": "bool",
                "value": "true",
                "ui": {
                    "icon": "font-awesome/fa-stop-circle-o",
                    "label": {
                        "en-US": "Stop service"
                    },
                    "type": "checkbox"
                }
            },
            {
                "name": "send_action",
                "type": "bool",
                "value": "false",
                "ui": {
                    "icon": "font-awesome/fa-send",
                    "label": {
                        "en-US": "Send chat action"
                    },
                    "type": "checkbox"
                }
            },
            {
                "name": "original_message",
                "type": "bool",
                "value": "true",
                "ui": {
                    "icon": "font-awesome/fa-paperclip",
                    "label": {
                        "en-US": "Attach original message"
                    },
                    "type": "checkbox"
                }
            },
            {
                "name": "content_filter_list",
                "type": "json",
                "value": "[\"text\",\"location\",\"contact\"]",
                "ui": {
                    "icon": "font-awesome/fa-filter",
                    "label": {
                        "en-US": "Content filter:"
                    },
                    "type": "input",
                    "opts": {
                        "types": [
                            "json"
                        ]
                    }
                }
            },
            {
                "name": "content_filter",
                "type": "bool",
                "value": "false",
                "ui": {
                    "icon": "font-awesome/fa-filter",
                    "label": {
                        "en-US": "Enable content filter"
                    },
                    "type": "checkbox"
                }
            },
            {
                "name": "expiration_minutes",
                "type": "num",
                "value": "5",
                "ui": {
                    "icon": "font-awesome/fa-clock-o",
                    "label": {
                        "en-US": "Expiration minutes:"
                    },
                    "type": "input",
                    "opts": {
                        "types": [
                            "num"
                        ]
                    }
                }
            },
            {
                "name": "expiration",
                "type": "bool",
                "value": "false",
                "ui": {
                    "icon": "font-awesome/fa-clock-o",
                    "label": {
                        "en-US": "Enable expiration message"
                    },
                    "type": "checkbox"
                }
            }
        ],
        "meta": {
            "module": "node-red-telegram-bot-api-receiver",
            "version": "2.0.0",
            "author": "Bruno Leonardi <b.leonardi78@gmail.com>",
            "desc": "Riceve i messaggi da Telegram",
            "keywords": "telegram, bot, api, messaging, messages, message",
            "license": "MIT"
        },
        "color": "#3FADB5",
        "outputLabels": [
            "Connection status",
            "Message accepted",
            "Message rejected"
        ],
        "icon": "font-awesome/fa-cloud-download",
        "status": {
            "x": 510,
            "y": 230,
            "wires": [
                {
                    "id": "a3187931500e6642",
                    "port": 0
                }
            ]
        }
    },
    {
        "id": "5b2c6438b32488b0",
        "type": "http request",
        "z": "799d902a165e50be",
        "name": "Telegram server",
        "method": "use",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "authType": "",
        "senderr": false,
        "x": 360,
        "y": 160,
        "wires": [
            [
                "8640ec936c216e76",
                "1fe6ce616ba331fd"
            ]
        ]
    },
    {
        "id": "7ecfe4abf0357a04",
        "type": "status",
        "z": "799d902a165e50be",
        "name": "",
        "scope": [
            "fb219cf60130f353",
            "8640ec936c216e76"
        ],
        "x": 295,
        "y": 230,
        "wires": [
            [
                "a3187931500e6642"
            ]
        ],
        "l": false
    },
    {
        "id": "e5d1b95fdc03c93c",
        "type": "catch",
        "z": "799d902a165e50be",
        "name": "",
        "scope": [
            "5b2c6438b32488b0",
            "8640ec936c216e76",
            "f2185d81a99762d2",
            "dabb0bbe4e7c6777",
            "fb219cf60130f353"
        ],
        "uncaught": false,
        "x": 65,
        "y": 280,
        "wires": [
            [
                "e28aee50621cee34",
                "1fe6ce616ba331fd"
            ]
        ],
        "l": false
    },
    {
        "id": "8640ec936c216e76",
        "type": "function",
        "z": "799d902a165e50be",
        "name": "Response",
        "func": "/**\n * Telegram Bot Api Javascript for Node-RED\n */\nconst TelegramBotApi = global.get('TelegramBotApi.class')\nconst Bot = new TelegramBotApi(msg)\n\n/**\n * Tools Class Collections Javascript for Node-RED\n */\nconst Tools = global.get('Tools.class')\nconst js = new Tools(msg)\n\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n\n/**\n * ////////////////////////////////////////////////////\n * Telegram Bot API receiver\n * Subflow per Node-Red\n * node-telegram-bot-api-receiver\n * ////////////////////////////////////////////////////\n * Author: Bruno Leonardi <b.leonardi78@gmail.com>\n * ////////////////////////////////////////////////////\n */\n\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n\n//tipo non gestito\nconst UNMANAGED = Bot.UNMANAGED\nvar unmanaged = false\n//tipo sconosciuto\nconst UNKNOWN = Bot.UNKNOWN\nvar unknown = false\n\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n\n//Risposta del server\nvar Response = RED.util.cloneMessage(msg)\n//codice stato risposta\nvar status = Response.statusCode || 0\n//messaggio di errore\nvar error_message = null\n//id di aggiornamento\nvar update_id = 1\n//array dei nuovi messaggi\nvar Updates = []\n//array dei nuovi messaggi accettati\nvar Messages_accepted = []\n//array dei nuovi messaggi rifiutati\nvar Messages_rejected = []\n//nuovo messaggio\nvar Message = {}\n//scadenza nuovo messaggio\nvar message_expiration = { minutes: 0 }\n//contenuto del messaggio\nvar content = null\n//tipo di contenuto del messaggio\nvar content_type = UNKNOWN\n//filtro contenuto messaggio\nvar content_filter = env.get(\"content_filter\")\n//lista filtro contenuto messaggio\nvar content_filter_list = env.get(\"content_filter_list\")\n//tipo di messaggio ufficiale\nvar message_type = UNKNOWN\n//solo messaggi più recenti\nconst expiration = env.get(\"expiration\")\n//minuti per messaggi recenti\nconst expiration_minutes = parseInt(env.get('expiration_minutes'))\n//risposta dal server\nvar payload_ok = false\n\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n\nconst METHOD = Bot.METHOD\nconst ACTION = Bot.CHAT_ACTION\nconst CONTENT_TYPE = Bot.CONTENT_TYPE\nconst MESSAGE_TYPE = Bot.MESSAGE_TYPE\n\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n\n//configurazione informazioni global telegram\nvar settings = {\n    bot: global.get('telegram.receiver.bot'),\n    url: global.get(\"telegram.receiver.url\"),\n    token: env.get(\"token\"),\n    method: flow.get(\"method\"),\n    update_id: global.get(\"telegram.receiver.update_id\"),\n    status: null,\n    last_error: global.get(\"telegram.receiver.last_error\") || null,\n    last_date: global.get('telegram.receiver.last_date' || null)\n}\n\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n\n/**\n * Definisce il messaggio e restituisce il tipo\n * @param {object} update Messaggio di update\n */\nfunction SetMessage(update) {\n    //recupera id di reply_to_message\n    let reply_to_message_id = js.JSGet('reply_to_message.message_id', update)\n\n    //imposta la data del messaggio\n    let message_date = js.JSGet('date.*.>', update)\n\n    //tempo trascorso da quando l'utente ha inviato il messaggio\n    var date_expiration = js.UnixToUTC(message_date)\n    message_expiration = js.GetTimeElapsed(date_expiration)\n\n    //assegna il messaggio\n    Message = {}\n\n    //allego il messaggio originale\n    if (env.get(\"original_message\")) Message.original = RED.util.cloneMessage(update)\n\n    //messaggio inoltrato\n    Message.forwarded = false\n\n    //contiene i dati della risposta\n    Message.reply_to_request = null\n\n    //informazioni utente\n    if (js.JSGet('forward_from.*.$boolean', update)) {\n        Message.forwarded = true\n        Message.user_id = js.JSGet('forward_from.id', update)\n        Message.user = js.JSGet('forward_from', update)\n    } else if (js.JSGet('via_bot.*.$boolean', update)) {\n        Message.user_id = js.JSGet('via_bot.id', update)\n        Message.user = js.JSGet('via_bot', update)\n    } else {\n        Message.user_id = js.JSGet('from.id', update)\n        Message.user = js.JSGet('from', update)\n    }\n\n    //informazioni chat\n    if (js.JSGet('forward_from_chat.*.$boolean', update)) {\n        Message.forwarded = true\n        Message.chat_id = js.JSGet('forward_from_chat.id', update)\n        Message.chat = js.JSGet('forward_from_chat', update)\n    } else if (js.JSGet('sender_chat.*.$boolean', update)) {\n        Message.chat_id = js.JSGet('sender_chat.id', update)\n        Message.chat = js.JSGet('sender_chat', update)\n    } else {\n        Message.chat_id = js.JSGet('chat.id', update)\n        Message.chat = js.JSGet('chat', update)\n    }\n\n    //informazioni global\n    if (Bot.GetGlobalPending(Message.chat_id)) {\n        date_expiration = Bot.GetGlobalDate(Message.chat_id)\n        date_expiration = js.UnixToUTC(date_expiration)\n        //reset global chat se trascorso...\n        if (js.GetTimeElapsed(date_expiration).hours > 1) {\n            Bot.ResetGlobalChat(Message.chat_id)\n        } else {\n            Message.reply_to_request = Bot.GetGlobalChat(Message.chat_id)[Message.chat_id] || null\n        }\n    }\n\n    //prepara il messaggio\n    Message.message_id = js.JSGet('message_id', update)\n    if (reply_to_message_id) Message.message_reply_id = reply_to_message_id\n    Message.message_date = message_date\n\n    //scadenza messaggio\n    if (expiration) {\n        Message.message_expired = (message_expiration.minutes > expiration_minutes)\n        //verifico se c'è una pendenza e confronto la sua data\n        if (!Message.message_expired && Bot.GetGlobalPending(Message.chat_id)) {\n            let data_pending = Bot.GetGlobalData(Message.chat_id)\n            if (data_pending) {\n                data_pending = js.UnixToUTC(data_pending)\n                message_expiration = js.GetTimeElapsed(data_pending)\n                Message.message_expired = (message_expiration.minutes > expiration_minutes)\n            }\n        }\n    } else {\n        Message.message_expired = false\n    }\n\n    //definisci il tipo di messaggio e il contenuto\n    if (update.message) {\n        if (update.message.reply_to_message) {\n            //definisci il contenuto\n            content_type = Bot.GetContentType(update.message)\n            content = Bot.GetContent(update.message)\n\n            //definisci il messaggio\n            message_type = MESSAGE_TYPE.reply_to_message\n            Message.message_type = message_type\n            Message.content_type = content_type\n            Message.content_filter = content_filter\n            if (content_type == CONTENT_TYPE.text) {\n                content = js.TextReplaceApostrophe(content)\n                Message.content_emoji = js.ContainsEmoji(content)\n                Message.content_only_emoji = js.ContainsOnlyEmoji(content)\n            }\n            Message.content = content\n            if (update.message.caption) Message.caption = update.message.caption\n            return message_type\n        } else if (update.message.pinned_message) {\n            //definisci il contenuto\n            content_type = Bot.GetContentType(update.message.pinned_message)\n            content = Bot.GetContent(update.message.pinned_message)\n\n            //definisci il messaggio\n            message_type = MESSAGE_TYPE.pinned_message\n            Message.message_type = message_type\n            Message.content_type = content_type\n            Message.content_filter = content_filter\n            if (content_type == CONTENT_TYPE.text) {\n                content = js.TextReplaceApostrophe(content)\n                Message.content_emoji = js.ContainsEmoji(content)\n                Message.content_only_emoji = js.ContainsOnlyEmoji(content)\n            }\n            Message.content = content\n            if (update.message.pinned_message.caption) Message.caption = update.message.pinned_message.caption\n            return message_type\n        } else {\n            //definisci il contenuto\n            content_type = Bot.GetContentType(update.message)\n            content = Bot.GetContent(update.message)\n\n            //definisci il messaggio\n            message_type = MESSAGE_TYPE.message\n            Message.message_type = message_type\n            Message.content_type = content_type\n            Message.content_filter = content_filter\n            if (content_type == CONTENT_TYPE.text) {\n                content = js.TextReplaceApostrophe(content)\n                Message.content_emoji = js.ContainsEmoji(content)\n                Message.content_only_emoji = js.ContainsOnlyEmoji(content)\n            }\n            Message.content = content\n            if (update.message.caption) Message.caption = update.message.caption\n            return message_type\n        }\n    } else if (update.edited_message) {\n        if (update.edited_message.text) {\n            //definisci il contenuto\n            content_type = CONTENT_TYPE.text\n            content = update.edited_message.text\n        } else if (update.edited_message.caption) {\n            //definisci il contenuto\n            content_type = CONTENT_TYPE.text\n            content = update.edited_message.caption\n        } else {\n            //definisci il contenuto\n            content_type = Bot.GetContentType(update.edited_message)\n            content = Bot.GetContent(update.edited_message)\n        }\n\n        //definisci il messaggio\n        message_type = MESSAGE_TYPE.edited_message\n        Message.message_type = message_type\n        Message.content_type = content_type\n        Message.content_filter = content_filter\n        if (content_type == CONTENT_TYPE.text) {\n            content = js.TextReplaceApostrophe(content)\n            Message.content_emoji = js.ContainsEmoji(content)\n            Message.content_only_emoji = js.ContainsOnlyEmoji(content)\n        }\n        Message.content = content\n        if (update.edited_message.caption) Message.caption = update.edited_message.caption\n        return message_type\n    } else if (update.channel_post) {\n        //come update.message\n        if (update.channel_post.reply_to_message) {\n            //definisci il contenuto\n            content_type = Bot.GetContentType(update.channel_post)\n            content = Bot.GetContent(update.channel_post)\n\n            //definisci il messaggio\n            message_type = MESSAGE_TYPE.reply_to_message\n            Message.message_type = message_type\n            Message.content_type = content_type\n            Message.content_filter = content_filter\n            if (content_type == CONTENT_TYPE.text) {\n                content = js.TextReplaceApostrophe(content)\n                Message.content_emoji = js.ContainsEmoji(content)\n                Message.content_only_emoji = js.ContainsOnlyEmoji(content)\n            }\n            Message.content = content\n            if (update.channel_post.caption) Message.caption = update.channel_post.caption\n            return message_type\n        } else if (update.channel_post.pinned_message) {\n            //definisci il contenuto\n            content_type = Bot.GetContentType(update.channel_post.pinned_message)\n            content = Bot.GetContent(update.channel_post.pinned_message)\n\n            //definisci il messaggio\n            message_type = MESSAGE_TYPE.pinned_message\n            Message.message_type = message_type\n            Message.content_type = content_type\n            Message.content_filter = content_filter\n            if (content_type == CONTENT_TYPE.text) {\n                content = js.TextReplaceApostrophe(content)\n                Message.content_emoji = js.ContainsEmoji(content)\n                Message.content_only_emoji = js.ContainsOnlyEmoji(content)\n            }\n            Message.content = content\n            if (update.channel_post.pinned_message.caption) Message.caption = update.channel_post.pinned_message.caption\n            return message_type\n        } else {\n            //definisci il contenuto\n            content_type = Bot.GetContentType(update.channel_post)\n            content = Bot.GetContent(update.channel_post)\n\n            //definisci il messaggio\n            message_type = MESSAGE_TYPE.message\n            Message.message_type = message_type\n            Message.content_type = content_type\n            Message.content_filter = content_filter\n            if (content_type == CONTENT_TYPE.text) {\n                content = js.TextReplaceApostrophe(content)\n                Message.content_emoji = js.ContainsEmoji(content)\n                Message.content_only_emoji = js.ContainsOnlyEmoji(content)\n            }\n            Message.content = content\n            if (update.channel_post.caption) Message.caption = update.channel_post.caption\n            return message_type\n        }\n    } else if (update.edited_channel_post) {\n        //come update.edited_message\n        if (update.edited_channel_post.text) {\n            //definisci il contenuto\n            content_type = CONTENT_TYPE.text\n            content = update.edited_channel_post.text\n        } else if (update.edited_channel_post.caption) {\n            //definisci il contenuto\n            content_type = CONTENT_TYPE.text\n            content = update.edited_channel_post.caption\n        } else {\n            //definisci il contenuto\n            content_type = Bot.GetContentType(update.edited_channel_post)\n            content = Bot.GetContent(update.edited_channel_post)\n        }\n\n        //definisci il messaggio\n        message_type = MESSAGE_TYPE.edited_channel_post\n        Message.message_type = message_type\n        Message.content_type = content_type\n        Message.content_filter = content_filter\n        if (content_type == CONTENT_TYPE.text) {\n            content = js.TextReplaceApostrophe(content)\n            Message.content_emoji = js.ContainsEmoji(content)\n            Message.content_only_emoji = js.ContainsOnlyEmoji(content)\n        }\n        Message.content = content\n        if (update.edited_channel_post.caption) Message.caption = update.edited_channel_post.caption\n        return message_type\n    } else if (update.inline_query) {\n        //definisci il messaggio\n        Message = RED.util.cloneMessage(update)\n        unmanaged = true\n        message_type = MESSAGE_TYPE.inline_query\n        Message.message_type = message_type\n        return message_type\n    } else if (update.chosen_inline_result) {\n        //definisci il messaggio\n        Message = RED.util.cloneMessage(update)\n        unmanaged = true\n        message_type = MESSAGE_TYPE.chosen_inline_result\n        Message.message_type = message_type\n        return message_type\n    } else if (update.callback_query) {\n        //definisci il contenuto\n        content_type = CONTENT_TYPE.text\n        content = update.callback_query.data\n\n        //definisci il messaggio\n        message_type = MESSAGE_TYPE.callback_query\n        Message.message_type = message_type\n        Message.callback_id = update.callback_query.id\n        Message.content_type = content_type\n        Message.content_filter = content_filter\n        if (content_type == CONTENT_TYPE.text) {\n            content = js.TextReplaceApostrophe(content)\n            Message.content_emoji = js.ContainsEmoji(content)\n            Message.content_only_emoji = js.ContainsOnlyEmoji(content)\n        }\n        Message.content = content\n        return message_type\n    } else if (update.shipping_query) {\n        //definisci il messaggio\n        Message = RED.util.cloneMessage(update)\n        unmanaged = true\n        message_type = MESSAGE_TYPE.shipping_query\n        Message.message_type = message_type\n        return message_type\n    } else if (update.pre_checkout_query) {\n        //definisci il messaggio\n        Message = RED.util.cloneMessage(update)\n        unmanaged = true\n        message_type = MESSAGE_TYPE.pre_checkout_query\n        Message.message_type = message_type\n        return message_type\n    } else if (update.poll) {\n        //definisci il messaggio\n        Message = RED.util.cloneMessage(update)\n        unmanaged = true\n        message_type = MESSAGE_TYPE.poll\n        Message.message_type = message_type\n        return message_type\n    } else if (update.poll_answer) {\n        //definisci il messaggio\n        Message = RED.util.cloneMessage(update)\n        unmanaged = true\n        message_type = MESSAGE_TYPE.poll_answer\n        Message.message_type = message_type\n        return message_type\n    } else if (update.my_chat_member) {\n        if (update.my_chat_member.new_chat_member) {\n            //definisci il contenuto\n            content_type = CONTENT_TYPE.text\n            content = update.my_chat_member.new_chat_member.status\n\n            //definisci il messaggio\n            message_type = MESSAGE_TYPE.my_chat_member\n            Message.message_type = message_type\n            Message.content_type = content_type\n            Message.content_filter = content_filter\n            if (content_type == CONTENT_TYPE.text) {\n                content = js.TextReplaceApostrophe(content)\n                Message.content_emoji = js.ContainsEmoji(content)\n                Message.content_only_emoji = js.ContainsOnlyEmoji(content)\n            }\n            Message.content = content\n            return message_type\n        } else {\n            //definisci il messaggio\n            Message = RED.util.cloneMessage(update)\n            unmanaged = true\n            message_type = MESSAGE_TYPE.my_chat_member\n            Message.message_type = message_type\n            return message_type\n        }\n    } else if (update.chat_member) {\n        //definisci il messaggio\n        Message = RED.util.cloneMessage(update)\n        unmanaged = true\n        message_type = MESSAGE_TYPE.chat_member\n        Message.message_type = message_type\n        return message_type\n    } else if (update.chat_join_request) {\n        //definisci il messaggio\n        Message = RED.util.cloneMessage(update)\n        unmanaged = true\n        message_type = MESSAGE_TYPE.chat_join_request\n        Message.message_type = message_type\n        return message_type\n    } else {\n        //definisci il messaggio\n        Message = RED.util.cloneMessage(update)\n        unknown = true\n        message_type = UNKNOWN\n        Message.message_type = message_type\n        return message_type\n    }\n}\n\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n\n//verifico se esiste il payload\nif (Response.payload) {\n    try {\n        //lo converto in oggetto\n        Response = (typeof Response.payload === 'string') ? JSON.parse(Response.payload) : Response.payload\n    } catch (error) {\n        status = 0\n        Response = {\n            ok: false,\n            error_code: 0,\n            description: \"Error JSONParse convertion\"\n        }\n    }\n\n    //controllo se è una risposta di telegram\n    //payload: \"{\"ok\":true,\"result\":[]}\"\n    if (Response.ok === undefined) {\n        status = 0\n        Response = {\n            ok: false,\n            error_code: 0,\n            description: \"It is not a Telegram message\"\n        }\n    } else {\n        payload_ok = Response.ok\n    }\n} else {\n    status = 0\n    Response = {\n        ok: false,\n        error_code: 0,\n        description: \"Payload message not exists\"\n    }\n}\n\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n\n//verifico lo status, il loop si arresta per qualsiasi errore\nif (status == 200) {\n    //payload: \"{\"ok\":true,\"result\":[]}\"\n    if (Response.result) Updates = Response.result\n} else {\n    //https://core.telegram.org/api/errors\n    error_message = Response.description || \"Unknown error\"\n    error_message = `${status} | ${error_message}`\n    error_message = new Error(error_message)\n}\n\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n\n//processo il messaggio di update\nif (!error_message) {\n    //in base al metodo...\n    if (settings.method == METHOD.getMe) {\n        //informazioni sul bot\n        settings.bot = Response.result\n    } else {\n        if (payload_ok && Updates.length == 0) {\n            //ok ma senza messaggi\n            Message = {}\n            Messages_accepted = []\n            Messages_rejected = []\n        } else if (payload_ok && Updates.length > 0) {\n            try {\n                //verifico tutti i messaggi\n                for (let i = 0; i < Updates.length; i++) {\n                    //imposta il messaggio\n                    message_type = SetMessage(Updates[i])\n\n                    //se il tipo messaggio è gestito\n                    if (!unknown && !unmanaged) {\n                        //filtri impostati per tipo di contenuto del messaggio\n                        if (content_filter) {\n                            content_filter_list = (Array.isArray(content_filter_list)) ? content_filter_list : []\n                            content_filter = (content_filter_list.length > 0)\n                        } else {\n                            content_filter_list = []\n                        }\n\n                        //rimuovo il messaggio originale\n                        delete Message[MESSAGE_TYPE.message]\n                        delete Message[message_type]\n\n                        //filtro tipo di contenuto del messaggio\n                        if (!content_filter || (content_filter && content_filter_list.includes(content_type))) {\n                            Messages_accepted.push(Message)\n                        } else {\n                            Messages_rejected.push(Message)\n                        }\n                    } else {\n                        Messages_rejected.push(Message)\n                    }\n                }\n            } catch (error) {\n                error_message = error\n            }\n        } else {\n            error_message = \"Error match, ok is \" + payload_ok + \" and result at \" + Updates.length\n            error_message = new Error(error_message)\n        }\n    }\n}\n\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n\n//aggiorno le impostazioni\nsettings.status = (status == 200) ? \"Connected\" : \"Disconnected\"\nsettings.last_error = error_message || settings.last_error\nsettings.last_date = (error_message) ? new Date() : settings.last_date\nglobal.set(\"telegram.receiver\", settings)\n\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n\n//aggiorno lo stato e invio eventuali nuovi messaggi\nif (error_message) {\n    node.status({ fill: \"red\", shape: \"dot\", text: error_message.message })\n    node.error(error_message, msg)\n} else {\n    //messaggi accettati\n    if (Messages_accepted.length > 0) {\n        for (let i = 0; i < Messages_accepted.length; i++) {\n            node.send([null, { telegram: Messages_accepted[i] }, null])\n        }\n\n        if (Messages_accepted.length === 1) {\n            node.status({ fill: \"blue\", shape: \"dot\", text: \"New message accepted\" })\n        } else {\n            node.status({ fill: \"blue\", shape: \"dot\", text: Messages_accepted.length + \" new messages accepted\" })\n        }\n\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n\n    //messaggi respinti\n    if (Messages_rejected.length > 0) {\n        for (let i = 0; i < Messages_rejected.length; i++) {\n            node.send([null, null, { telegram: Messages_rejected[i] }])\n        }\n\n        if (Messages_rejected.length === 1) {\n            node.status({ fill: \"yellow\", shape: \"dot\", text: \"New message rejected\" })\n        } else {\n            node.status({ fill: \"yellow\", shape: \"dot\", text: Messages_rejected.length + \" new messages rejected\" })\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n\n    //memorizzo l'ultimo update_id\n    if (Updates.length > 0) {\n        //imposto update_id per confermare la lettura al server\n        update_id += (Updates[Updates.length - 1].update_id)\n        global.set(\"telegram.receiver.update_id\", update_id)\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n\n    //invio la richiesta update\n    var bot_name = global.get(\"telegram.receiver.bot.first_name\") || 'Bot'\n\n    if (Messages_accepted.length == 0 && Messages_rejected.length == 0) {\n        content_filter = content_filter ? ' + filter' : ''\n        node.status({ fill: \"blue\", shape: \"dot\", text: bot_name + \" is connected\" + content_filter })\n    }\n}\n\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n\n//nuova richiesta\nreturn [{ payload: \"new_request\" }, null, null]",
        "outputs": 3,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 550,
        "y": 160,
        "wires": [
            [
                "18e7f2955c050555"
            ],
            [
                "8a32a3bce6dbb797"
            ],
            [
                "4bebee7279e15eae"
            ]
        ],
        "inputLabels": [
            "Http response"
        ],
        "outputLabels": [
            "New request",
            "Message accepted",
            "Message rejected"
        ]
    },
    {
        "id": "90630512b101cdf9",
        "type": "inject",
        "z": "799d902a165e50be",
        "name": "Start request",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "5",
        "topic": "",
        "x": 65,
        "y": 160,
        "wires": [
            [
                "fb219cf60130f353"
            ]
        ],
        "l": false
    },
    {
        "id": "a3187931500e6642",
        "type": "delay",
        "z": "799d902a165e50be",
        "name": "Rate limit",
        "pauseType": "rate",
        "timeout": "5",
        "timeoutUnits": "minutes",
        "rate": "2",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 425,
        "y": 230,
        "wires": [
            []
        ],
        "l": false
    },
    {
        "id": "e28aee50621cee34",
        "type": "function",
        "z": "799d902a165e50be",
        "name": "Node error",
        "func": "node.error(msg, msg)",
        "outputs": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 200,
        "y": 280,
        "wires": []
    },
    {
        "id": "f2185d81a99762d2",
        "type": "function",
        "z": "799d902a165e50be",
        "name": "sendChatAction",
        "func": "/**\n * Telegram Bot Api Javascript for Node-RED\n */\nconst TelegramBotApi = global.get('TelegramBotApi.class')\nconst Bot = new TelegramBotApi(msg)\n\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n\nif (msg.telegram && env.get(\"send_action\")) {\n    msg.original_message = RED.util.cloneMessage(msg)\n\n    try {\n        var url = global.get('telegram.url_base')\n        var chat_id = msg.telegram.chat_id\n        var action = Bot.GetAction(msg.telegram.content_type)\n        if (!chat_id) return [msg, null]\n        msg.method = 'POST'\n        msg.url = `${url}sendChatAction?chat_id=${chat_id}&action=${action}`\n        return [null, msg]\n    } catch (error) {\n        node.error(error, msg)\n        return [msg.original_message, null]\n    }\n} else {\n    return [msg, null]\n}",
        "outputs": 2,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 765,
        "y": 160,
        "wires": [
            [],
            [
                "dabb0bbe4e7c6777"
            ]
        ],
        "icon": "font-awesome/fa-send",
        "l": false
    },
    {
        "id": "dabb0bbe4e7c6777",
        "type": "http request",
        "z": "799d902a165e50be",
        "name": "Chat action",
        "method": "use",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "authType": "",
        "senderr": false,
        "x": 835,
        "y": 160,
        "wires": [
            [
                "e5df7a9578d68238"
            ]
        ],
        "l": false
    },
    {
        "id": "18e7f2955c050555",
        "type": "trigger",
        "z": "799d902a165e50be",
        "name": "Wait for...",
        "op1": "",
        "op2": "",
        "op1type": "nul",
        "op2type": "pay",
        "duration": "500",
        "extend": false,
        "overrideDelay": false,
        "units": "ms",
        "reset": "",
        "bytopic": "all",
        "topic": "topic",
        "outputs": 1,
        "x": 190,
        "y": 90,
        "wires": [
            [
                "fb219cf60130f353",
                "85c287a9917d09e6",
                "b539f91be403db6c"
            ]
        ]
    },
    {
        "id": "fb219cf60130f353",
        "type": "function",
        "z": "799d902a165e50be",
        "name": "Request",
        "func": "/**\n * ////////////////////////////////////////////////////\n * Telegram Bot API receiver\n * Subflow per Node-Red\n * node-telegram-bot-api-receiver\n * Date: 20/07/2022\n * ////////////////////////////////////////////////////\n * Author: Bruno Leonardi <b.leonardi78@gmail.com>\n * ////////////////////////////////////////////////////\n */\n\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n\n//arresta il servizio\nif (env.get('stop_service')) {\n    node.status({ fill: \"yellow\", shape: \"dot\", text: \"The service is stopped!\" })\n    return null\n}\n\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n\n//configurazione bot telegram\n//var bot = env.get(\"bot\").trim().replace(/\\s/g, '_') || 'bot'\nvar settings = {\n    bot: global.get('telegram.receiver.bot'),\n    url: \"https://api.telegram.org/\",\n    token: '',\n    method: flow.get(\"method\"),\n    update_id: -1,\n    status: global.get('telegram.receiver.status'),\n    last_error: global.get('telegram.receiver.last_error') || null,\n    last_date: global.get('telegram.receiver.last_date') || null\n}\n\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n\n//imposto l'ultimo id di aggiornamento dei messaggi\nvar update_id = global.get('telegram.receiver.update_id')\n\n//imposto url in base al metodo\nvar url = env.get(\"url\").trim()\nurl = (!url.endsWith('/')) ? url + '/' : url\n\n//imposto il token\nvar token = env.get(\"token\").trim()\n\n//verifico i campi\nif (token.length < 10) {\n    node.status({ fill: \"yellow\", shape: \"dot\", text: \"Check the inserted TOKEN\" })\n    return null\n} else if (!url.includes('http') || url.length < 10) {\n    node.status({ fill: \"yellow\", shape: \"dot\", text: \"Check the inserted URL API\" })\n    return null\n}\n\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n\n//imposto url base completo di token\nglobal.set('telegram.url_base', `${url}bot${token}/`)\n\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n\n//imposto il metodo\nvar method = flow.get(\"method\") || null\n\nif (!method || global.get('telegram.receiver.bot') === undefined) {\n    //richiedo le informazioni bot ad ogni startup\n    method = 'getMe'\n    url = `${url}bot${token}/${method}`\n} else if (method == 'getMe') {\n    //richiedo tutti messaggi\n    method = 'getUpdates'\n    url = `${url}bot${token}/${method}`\n} else {\n    //richiedo gli ultimi messaggi\n    if (update_id === undefined) update_id = -1\n    url = `${url}bot${token}/${method}?offset=${update_id}`\n}\n\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n\n//aggiorno le impostazioni\nsettings.url = url\nsettings.token = token\nsettings.method = method\nsettings.update_id = update_id\nglobal.set('telegram.receiver', settings)\nflow.set(\"method\", method)\n\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n\n//nome del bot\nvar bot_name = global.get('telegram.receiver.bot.first_name')\n\nif (!bot_name) {\n    node.status({ fill: \"blue\", shape: \"dot\", text: \"Request information about the bot...\" })\n} else {\n    let content_filter = (env.get(\"content_filter\")) ? ' + filter' : ''\n    node.status({ fill: \"blue\", shape: \"ring\", text: bot_name + \" is connected\" + content_filter })\n}\n\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n\n//invio la richiesta\nreturn { method: 'GET', url: url }",
        "outputs": 1,
        "noerr": 0,
        "initialize": "/**\n * ////////////////////////////////////////////////////\n * Telegram Bot API receiver\n * Subflow per Node-Red\n * node-telegram-bot-api-receiver\n * ////////////////////////////////////////////////////\n * Author: Bruno Leonardi <b.leonardi78@gmail.com>\n * ////////////////////////////////////////////////////\n */\n\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n\n//status\nnode.status({ fill: \"blue\", shape: \"ring\", text: \"Initialized\" })\n\n//reset del metodo\nflow.set(\"method\", null)\n\n//reset update_id\nglobal.set('telegram.receiver.update_id', -1)",
        "finalize": "",
        "libs": [],
        "x": 190,
        "y": 160,
        "wires": [
            [
                "5b2c6438b32488b0"
            ]
        ],
        "inputLabels": [
            "Input"
        ],
        "outputLabels": [
            "Http request"
        ]
    },
    {
        "id": "85c287a9917d09e6",
        "type": "trigger",
        "z": "799d902a165e50be",
        "name": "Disconnected",
        "op1": "",
        "op2": "disconnected",
        "op1type": "nul",
        "op2type": "str",
        "duration": "10",
        "extend": true,
        "overrideDelay": false,
        "units": "s",
        "reset": "",
        "bytopic": "all",
        "topic": "topic",
        "outputs": 1,
        "x": 530,
        "y": 40,
        "wires": [
            []
        ]
    },
    {
        "id": "de5da420710151e8",
        "type": "inject",
        "z": "799d902a165e50be",
        "name": "Startup status",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "1",
        "topic": "",
        "x": 235,
        "y": 40,
        "wires": [
            [
                "85c287a9917d09e6"
            ]
        ],
        "l": false
    },
    {
        "id": "d868daa626a6f515",
        "type": "trigger",
        "z": "799d902a165e50be",
        "name": "Connected",
        "op1": "",
        "op2": "connected",
        "op1type": "nul",
        "op2type": "str",
        "duration": "1",
        "extend": false,
        "overrideDelay": false,
        "units": "ms",
        "reset": "",
        "bytopic": "all",
        "topic": "topic",
        "outputs": 1,
        "x": 540,
        "y": 90,
        "wires": [
            []
        ]
    },
    {
        "id": "b539f91be403db6c",
        "type": "delay",
        "z": "799d902a165e50be",
        "name": "",
        "pauseType": "rate",
        "timeout": "5",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": true,
        "allowrate": false,
        "outputs": 1,
        "x": 425,
        "y": 90,
        "wires": [
            [
                "d868daa626a6f515"
            ]
        ],
        "l": false
    },
    {
        "id": "1fe6ce616ba331fd",
        "type": "trigger",
        "z": "799d902a165e50be",
        "name": "Watchdog",
        "op1": "",
        "op2": "new_request",
        "op1type": "nul",
        "op2type": "str",
        "duration": "1",
        "extend": true,
        "overrideDelay": false,
        "units": "min",
        "reset": "",
        "bytopic": "all",
        "topic": "topic",
        "outputs": 1,
        "x": 190,
        "y": 230,
        "wires": [
            [
                "fb219cf60130f353"
            ]
        ]
    },
    {
        "id": "bbd6fcd41909a8ca",
        "type": "function",
        "z": "799d902a165e50be",
        "name": "Class Telegram Bot Api",
        "func": "//On Start",
        "outputs": 0,
        "noerr": 0,
        "initialize": "/**\n * Telegram Bot Api Javascript for Node-RED\n * Bruno Leonardi - b.leonardi78@gmail.com\n * Non tutti i metodi sono definiti!!!\n * Mancante Inline mode https://core.telegram.org/bots/api#inline-mode\n * Mancante Payments https://core.telegram.org/bots/api#payments\n * Mancante Telegram Passport https://core.telegram.org/bots/api#telegram-passport\n * Mancante Games https://core.telegram.org/bots/api#games\n */\nclass TelegramBotApi {\n    /**\n     * @param {{}} message Messaggio di Node-RED\n     */\n    constructor(message) {\n        this.message = message\n        this.url_base = global.get('telegram.url_base') || null\n        if (!this.url_base) node.error('Global variable \"telegram.url_base\" not found!')\n    }\n\n    /**\n     * Struttura variabile globale chat\n     */\n    chat = {\n        date: Date.now(),\n        pending: false,\n        type: 'unknown',\n        keycode: null,\n        message_id: null,\n        data: null\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //VARIABILI GLOBAL\n\n    /**\n     * Rirpistina i valori di default\n     * @param {string | number} chat_id ID della chat\n     * @return {boolean} Esito della scrittura\n     */\n    InitializeGlobalChat(chat_id) {\n        if (!chat_id) return false\n        try {\n            let path = `telegram.chat.${chat_id}`\n            if (global.get(path) === undefined) global.set(path, this.chat)\n            return true\n        } catch (error) {\n            node.error(error, msg)\n            return false\n        }\n    }\n\n    /**\n     * Rirpistina i valori di default\n     * @param {string | number} chat_id ID della chat\n     * @return {boolean} Esito della scrittura\n     */\n    ResetGlobalChat(chat_id) {\n        if (!chat_id) return false\n        try {\n            let path = `telegram.chat.${chat_id}`\n            global.set(path, this.chat)\n            return true\n        } catch (error) {\n            node.error(error, msg)\n            return false\n        }\n    }\n\n    /**\n     * Restituisce tutte le informazioni della chat\n     * @param {string | number} chat_id ID della chat\n     * @return {{}} Oggetto chat\n     */\n    GetGlobalChat(chat_id) {\n        if (!chat_id) return this.chat\n        try {\n            let path = `telegram.chat.${chat_id}`\n            return global.get(path) || this.chat\n        } catch (error) {\n            node.error(error, msg)\n            return this.chat\n        }\n    }\n\n    /**\n     * Memorizza tutte le informazioni della chat\n     * @param {string | number} chat_id ID della chat\n     * @param {{}} chat Oggetto chat\n     * @return {boolean} Esito della scrittura\n     */\n    SetGlobalChat(chat_id, chat) {\n        if (!chat_id || !chat) return false\n        try {\n            let path = `telegram.chat.${chat_id}`\n            global.set(path, chat)\n            return true\n        } catch (error) {\n            node.error(error, msg)\n            return false\n        }\n    }\n\n    /**\n     * Restituisce l'id dell'ultimo messaggio inviato\n     * @param {string | number} chat_id ID della chat\n     * @param {any} returnValue Valore di ritorno in caso di variabile undefined o errore\n     * @return {number | any} ID messaggio\n     */\n    GetGlobalMessageId(chat_id, returnValue = null) {\n        if (!chat_id) return returnValue\n        try {\n            let path = `telegram.chat.${chat_id}.message_id`\n            return global.get(path) || returnValue\n        } catch (error) {\n            node.error(error, msg)\n            return returnValue\n        }\n    }\n\n    /**\n     * Memorizza l'id dell'ultimo messaggio inviato\n     * @param {string | number} chat_id ID della chat\n     * @param {string | number | null} value Valore da assegnare\n     * @return {boolean} Esito della scrittura\n     */\n    SetGlobalMessageId(chat_id, value = null) {\n        if (!chat_id) return false\n        try {\n            this.InitializeGlobalChat(chat_id)\n            let path = `telegram.chat.${chat_id}.message_id`\n            global.set(path, value)\n            return true\n        } catch (error) {\n            node.error(error, msg)\n            return false\n        }\n    }\n\n    /**\n     * Restituisce la data in formato Unix dell'ultimo messaggio inviato\n     * @param {string | number} chat_id ID della chat\n     * @param {any} returnValue Valore di ritorno in caso di variabile undefined o errore\n     * @return {number | any} Data formato Unix\n     */\n    GetGlobalDate(chat_id, returnValue = null) {\n        if (!chat_id) return returnValue\n        try {\n            let path = `telegram.chat.${chat_id}.date`\n            return global.get(path) || returnValue\n        } catch (error) {\n            node.error(error, msg)\n            return returnValue\n        }\n    }\n\n    /**\n     * Memorizza la data in formato Unix dell'ultimo messaggio inviato\n     * @param {string | number} chat_id ID della chat\n     * @param {number} value Valore da assegnare, default data attuale\n     * @return {boolean} Esito della scrittura\n     */\n    SetGlobalDate(chat_id, value = Date.now()) {\n        if (!chat_id) return false\n        try {\n            this.InitializeGlobalChat(chat_id)\n            let path = `telegram.chat.${chat_id}.date`\n            global.set(path, value)\n            return true\n        } catch (error) {\n            node.error(error, msg)\n            return false\n        }\n    }\n\n    /**\n     * Restituisce la pendenza\n     * @param {string | number} chat_id ID della chat\n     * @param {any} returnValue Valore di ritorno in caso di variabile undefined o errore\n     * @return {boolean | any} Pendenza\n     */\n    GetGlobalPending(chat_id, returnValue = false) {\n        if (!chat_id) return returnValue\n        try {\n            let path = `telegram.chat.${chat_id}.pending`\n            return global.get(path) || returnValue\n        } catch (error) {\n            node.error(error, msg)\n            return returnValue\n        }\n    }\n\n    /**\n     * Memorizza la pendenza\n     * @param {string | number} chat_id ID della chat\n     * @param {boolean} value Valore da assegnare, default false\n     * @return {boolean} Esito della scrittura\n     */\n    SetGlobalPending(chat_id, value = false) {\n        if (!chat_id) return false\n        try {\n            this.InitializeGlobalChat(chat_id)\n            let path = `telegram.chat.${chat_id}.pending`\n            global.set(path, value)\n            return true\n        } catch (error) {\n            node.error(error, msg)\n            return false\n        }\n    }\n\n    /**\n     * Restituisce il codice tastiera\n     * @param {string | number} chat_id ID della chat\n     * @param {any} returnValue Valore di ritorno in caso di variabile undefined o errore\n     * @return {string | any} Codice tastiera\n     */\n    GetGlobalKeycode(chat_id, returnValue = null) {\n        if (!chat_id) return returnValue\n        try {\n            let path = `telegram.chat.${chat_id}.keycode`\n            return global.get(path) || returnValue\n        } catch (error) {\n            node.error(error, msg)\n            return returnValue\n        }\n    }\n\n    /**\n     * Memorizza il codice tastiera\n     * @param {string | number} chat_id ID della chat\n     * @param {string | number | null} value Valore da assegnare, default null\n     * @return {boolean} Esito della scrittura\n     */\n    SetGlobalKeycode(chat_id, value = null) {\n        if (!chat_id) return false\n        try {\n            this.InitializeGlobalChat(chat_id)\n            let path = `telegram.chat.${chat_id}.keycode`\n            global.set(path, value)\n            return true\n        } catch (error) {\n            node.error(error, msg)\n            return false\n        }\n    }\n\n    /**\n     * Restituisce il tipo messaggio\n     * @param {string | number} chat_id ID della chat\n     * @param {any} returnValue Valore di ritorno in caso di variabile undefined o errore\n     * @return {string | any} Tipo messaggio\n     */\n    GetGlobalType(chat_id, returnValue = null) {\n        if (!chat_id) return returnValue\n        try {\n            let path = `telegram.chat.${chat_id}.type`\n            return global.get(path) || returnValue\n        } catch (error) {\n            node.error(error, msg)\n            return returnValue\n        }\n    }\n\n    /**\n     * Memorizza il tipo di messaggio\n     * @param {string | number} chat_id ID della chat\n     * @param {string} value Valore da assegnare, default message\n     * @return {boolean} Esito della scrittura\n     */\n    SetGlobalType(chat_id, value = 'message') {\n        if (!chat_id) return false\n        try {\n            this.InitializeGlobalChat(chat_id)\n            let path = `telegram.chat.${chat_id}.type`\n            global.set(path, value)\n            return true\n        } catch (error) {\n            node.error(error, msg)\n            return false\n        }\n    }\n\n    /**\n     * Restituisce i dati del messaggio\n     * @param {string | number} chat_id ID della chat\n     * @param {any} returnValue Valore di ritorno in caso di variabile undefined o errore\n     * @return {string | {} | any} Dati del messaggio\n     */\n    GetGlobalData(chat_id, returnValue = null) {\n        if (!chat_id) return returnValue\n        try {\n            let path = `telegram.chat.${chat_id}.data`\n            return global.get(path) || returnValue\n        } catch (error) {\n            node.error(error, msg)\n            return returnValue\n        }\n    }\n\n    /**\n     * Memorizza i dati del messaggio\n     * @param {string | number} chat_id ID della chat\n     * @param {string | {} | [] | null} value Valore da assegnare, default null\n     * @return {boolean} Esito della scrittura\n     */\n    SetGlobalData(chat_id, value = null) {\n        if (!chat_id) return false\n        try {\n            this.InitializeGlobalChat(chat_id)\n            let path = `telegram.chat.${chat_id}.data`\n            global.set(path, value)\n            return true\n        } catch (error) {\n            node.error(error, msg)\n            return false\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //VARIABILI PERSONALIZZATE\n\n    /**\n     * Non gestito\n     */\n    UNMANAGED = 'unmanaged'\n\n    /**\n     * Sconosciuto\n     */\n    UNKNOWN = 'unknown'\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //JSON UTILITY\n\n    /**\n     * Converte JSON String >> Object\n     * @param {string} string JSON String\n     */\n    JSO(string) {\n        try {\n            if (!string || typeof string !== 'string') return string\n            return JSON.parse(string)\n        } catch (error) {\n            return string\n        }\n    }\n\n    /**\n     * Converte JSON Object >> String\n     * @param {object} object JSON Object\n     */\n    JSS(object) {\n        try {\n            if (!object || typeof object === 'string') return object\n            return JSON.stringify(object)\n        } catch (error) {\n            return object\n        }\n    }\n\n    /**\n     * Ricerca le chievi in un oggetto JSON e restituisce il valore o le proprietà\n     * @param {string | string []} args args = 'key' || 'key.subkey.{what}' || 'key.*.{what}' || ['key', 'subkey', '{what}'] || ['key', '*', '{what}']\n     * @param {string | string []} args {what} = $type || $keys || $first_key || $last_key || $root || $boolean || $object || $...> (ultimo risultato)\n     * @param {NodeMessage | {} | []} object Oggetto sul quale effettuare la ricerca\n     */\n    JSGet(args, object = this.message) {\n        //creo una copia di object\n        object = RED.util.cloneMessage(object)\n\n        //definisci le chiavi\n        if (!args || (typeof args === 'string' && !args.trim())) {\n            return null\n        } else if (typeof args === 'string') {\n            //crea una array di chiavi\n            args = args.split('.')\n        } else if (!Array.isArray(args)) {\n            return null\n        }\n\n        //chiave primaria\n        var key = args[0]\n        if (!key) return null\n        if (typeof key !== 'string') return null\n        if (key == '') return null\n\n        //chiave secondaria\n        var subKey = (args.length == 2) ? args[1] : null\n        if (subKey && (subKey == '*' || subKey == '')) subKey = null\n\n        //risultato richiesto\n        var what = (args.length == 3) ? args[2] : ''\n\n        //definisci l'oggetto, deve essere un JSON\n        if (object && typeof object === 'object' && Array.isArray(object) && object.length > 0) {\n            //se è una array lo converto\n            Object.assign({}, object)\n        } else if (typeof object === 'string') {\n            //se è un JSON string lo converto\n            try {\n                object = JSON.parse(object)\n            } catch (error) {\n                return null\n            }\n        }\n\n        //se non è un JSON restituisco null\n        if (!object || (Object.keys(object).length == 0 && object.constructor === Object)) {\n            return null\n        }\n\n        //risultati della ricerca\n        var result = null\n\n        //ricerca in profondità la chiave nell'oggetto\n        var searchDeep = function SearchDeep(/** @type {{ [x: string]: any; hasOwnProperty: (arg0: string) => any; }} */ object, /** @type {string} */ rootKeys) {\n            //percorso della chiave\n            var root = function GetRootKey(/** @type {string} */ addKey) {\n                return rootKeys ? `${rootKeys}.${addKey}` : addKey\n            }\n\n            //chiave trovata\n            if (object && object.hasOwnProperty(key)) {\n                //se vuota assegna key\n                if (!rootKeys) rootKeys = key\n\n                if (subKey && object[key].hasOwnProperty(subKey)) {\n                    result = {\n                        value: object[key][subKey],\n                        type: typeof object[key][subKey],\n                        keys: rootKeys.split('.').length,\n                        first_key: rootKeys.split('.')[0],\n                        last_key: (rootKeys.split('.').length > 0) ? rootKeys.split('.')[rootKeys.split('.').length - 1] : rootKeys.split('.')[0],\n                        root: rootKeys\n                    }\n                } else if (!subKey) {\n                    result = {\n                        value: object[key],\n                        type: typeof object[key],\n                        keys: rootKeys.split('.').length,\n                        first_key: rootKeys.split('.')[0],\n                        last_key: (rootKeys.split('.').length > 0) ? rootKeys.split('.')[rootKeys.split('.').length - 1] : rootKeys.split('.')[0],\n                        root: rootKeys\n                    }\n                }\n            }\n\n            //ricerca della chiave\n            if (!result || what.endsWith('>')) {\n                for (let k in object) {\n                    if (object.hasOwnProperty(k) && typeof object[k] === 'object') {\n                        searchDeep(object[k], root(k))\n                    }\n                }\n            }\n        }\n\n        //inizia la ricerca\n        searchDeep(object)\n\n        //restituisci il risultato\n        switch (what.replace('>', '')) {\n            case \"$type\":\n                return (!result ? null : result.type)\n            case \"$keys\":\n                return (!result ? null : result.keys)\n            case \"$first_key\":\n                return (!result ? null : result.first_key)\n            case \"$last_key\":\n                return (!result ? null : result.last_key)\n            case \"$root\":\n                return (!result ? null : result.root)\n            case \"$boolean\":\n                return !!result\n            case \"$object\":\n                return (!result ? null : result)\n            default:\n                return (!result ? null : result.value)\n        }\n    }\n\n    /**\n     * Determina se il contenuto del messaggio è superiore al limite massimo di 4096\n     * @param {string} content Contenuto del messaggio da valutare\n     * @param {number} limit Limite massimo per invio del messaggio, default 3072\n     */\n    IsOverSize(content, limit = 3072) {\n        limit = (limit > 4096) ? 4096 : limit\n        return (Buffer.from(content).length > limit)\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //TELEGRAM METHODS\n\n    /**\n     * Metodo per la ricezione e l'invio di messaggi\n     * https://core.telegram.org/bots/api#available-methods\n     */\n    METHOD = {\n        //GET\n        getMe: \"getMe\",\n        getUpdates: \"getUpdates\",\n        //POST\n        sendMessage: \"sendMessage\",\n        forwardMessage: \"forwardMessage\",\n        copyMessage: \"copyMessage\",\n        sendPhoto: \"sendPhoto\",\n        sendAudio: \"sendAudio\",\n        sendDocument: \"sendDocument\",\n        sendVideo: \"sendVideo\",\n        sendAnimation: \"sendAnimation\",\n        sendVoice: \"sendVoice\",\n        sendVideoNote: \"sendVideoNote\",\n        sendLocation: \"sendLocation\",\n        sendVenue: \"sendVenue\",\n        sendContact: \"sendContact\",\n        sendPoll: 'sendPoll',\n        sendDice: \"sendDice\",\n        sendChatAction: \"sendChatAction\",\n        getUserProfilePhotos: 'getUserProfilePhotos',\n        getFile: 'getFile',\n        banChatMember: 'banChatMember',\n        unbanChatMember: 'unbanChatMember',\n        restrictChatMember: 'restrictChatMember',\n        promoteChatMember: 'promoteChatMember',\n        setChatAdministratorCustomTitle: 'setChatAdministratorCustomTitle',\n        banChatSenderChat: 'banChatSenderChat',\n        unbanChatSenderChat: 'unbanChatSenderChat',\n        setChatPermissions: 'setChatPermissions',\n        exportChatInviteLink: 'exportChatInviteLink',\n        createChatInviteLink: 'createChatInviteLink',\n        editChatInviteLink: 'editChatInviteLink',\n        revokeChatInviteLink: 'revokeChatInviteLink',\n        approveChatJoinRequest: 'approveChatJoinRequest',\n        declineChatJoinRequest: 'declineChatJoinRequest',\n        setChatPhoto: 'setChatPhoto',\n        deleteChatPhoto: 'deleteChatPhoto',\n        setChatTitle: 'setChatTitle',\n        setChatDescription: 'setChatDescription',\n        pinChatMessage: 'pinChatMessage',\n        unpinChatMessage: 'unpinChatMessage',\n        unpinAllChatMessages: 'unpinAllChatMessages',\n        leaveChat: 'leaveChat',\n        getChat: 'getChat',\n        getChatAdministrators: 'getChatAdministrators',\n        getChatMemberCount: 'getChatMemberCount',\n        getChatMember: 'getChatMember',\n        setChatStickerSet: 'setChatStickerSet',\n        deleteChatStickerSet: 'deleteChatStickerSet',\n        answerCallbackQuery: 'answerCallbackQuery',\n        setMyCommands: 'setMyCommands',\n        deleteMyCommands: 'deleteMyCommands',\n        getMyCommands: 'getMyCommands',\n        setChatMenuButton: 'setChatMenuButton',\n        getChatMenuButton: 'getChatMenuButton',\n        setMyDefaultAdministratorRights: 'setMyDefaultAdministratorRights',\n        getMyDefaultAdministratorRights: 'getMyDefaultAdministratorRights',\n        sendSticker: 'sendSticker',\n        getStickerSet: 'getStickerSet',\n        uploadStickerFile: 'uploadStickerFile',\n        editMessageText: 'editMessageText',\n        editMessageCaption: 'editMessageCaption',\n        editMessageMedia: 'editMessageMedia',\n        editMessageReplyMarkup: 'editMessageReplyMarkup',\n        stopPoll: 'stopPoll',\n        deleteMessage: 'deleteMessage'\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //TELEGRAM UPDATE MESSAGE\n\n    /**\n     * Tipologia messaggio di update\n     * https://core.telegram.org/bots/api#update\n     */\n    MESSAGE_TYPE = {\n        message: 'message',\n        edited_message: 'edited_message',\n        channel_post: 'channel_post',\n        edited_channel_post: 'edited_channel_post',\n        inline_query: 'inline_query',\n        chosen_inline_result: 'chosen_inline_result',\n        callback_query: 'callback_query',\n        shipping_query: 'shipping_query',\n        pre_checkout_query: 'pre_checkout_query',\n        poll: 'poll',\n        poll_answer: 'poll_answer',\n        my_chat_member: 'my_chat_member',\n        chat_member: 'chat_member',\n        chat_join_request: 'chat_join_request',\n        //si trovano dentro message\n        reply_to_message: 'reply_to_message',\n        pinned_message: 'pinned_message'\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //TELEGRAM CONTENT TYPE\n\n    /**\n     * Tipologia contenuto del messaggio di update\n     * https://core.telegram.org/bots/api#message\n     */\n    CONTENT_TYPE = {\n        text: 'text',\n        animation: 'animation',\n        audio: 'audio',\n        document: 'document',\n        photo: 'photo',\n        sticker: 'sticker',\n        video: 'video',\n        video_note: 'video_note',\n        voice: 'voice',\n        contact: 'contact',\n        dice: 'dice',\n        game: 'game',\n        poll: 'poll',\n        venue: 'venue',\n        location: 'location',\n        new_chat_members: 'new_chat_members',\n        left_chat_member: 'left_chat_member',\n        new_chat_title: 'new_chat_title',\n        new_chat_photo: 'new_chat_photo',\n        delete_chat_photo: 'delete_chat_photo',\n        group_chat_created: 'group_chat_created',\n        supergroup_chat_created: 'supergroup_chat_created',\n        channel_chat_created: 'channel_chat_created',\n        message_auto_delete_timer_changed: 'message_auto_delete_timer_changed',\n        migrate_to_chat_id: 'migrate_to_chat_id',\n        migrate_from_chat_id: 'migrate_from_chat_id',\n        pinned_message: 'pinned_message',\n        invoice: 'invoice',\n        successful_payment: 'successful_payment',\n        connected_website: 'connected_website',\n        passport_data: 'passport_data',\n        proximity_alert_triggered: 'proximity_alert_triggered',\n        video_chat_scheduled: 'video_chat_scheduled',\n        video_chat_started: 'video_chat_started',\n        video_chat_ended: 'video_chat_ended',\n        video_chat_participants_invited: 'video_chat_participants_invited',\n        web_app_data: 'web_app_data',\n        chat_invite_link: 'chat_invite_link',\n        chat_member_updated: 'chat_member_updated'\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //TELEGRAM CHAT ACTION\n\n    /**\n     * Tipologia di azione in chat\n     * https://core.telegram.org/bots/api#sendchataction\n     */\n    CHAT_ACTION = {\n        typing: 'typing',\n        find_location: 'find_location',\n        upload_photo: 'upload_photo',\n        upload_document: 'upload_document',\n        upload_video_note: 'upload_video_note',\n        record_audio: 'record_audio',\n        record_video: 'record_video',\n        record_video_note: 'record_video_note'\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //TELEGRAM BOT COMMANDS\n\n    /**\n     * Bot Command Scope con {{template}}\n     * https://core.telegram.org/bots/api#botcommandscope\n     */\n    BOT_COMMAND_SCOPE = {\n        default: this.JSS({ type: 'default' }),\n        all_private_chats: this.JSS({ type: 'all_private_chats' }),\n        all_group_chats: this.JSS({ type: 'all_group_chats' }),\n        all_chat_administrators: this.JSS({ type: 'all_chat_administrators' }),\n        chat: this.JSS({ type: 'chat', chat_id: '{{chat_id}}' }),\n        chat_administrators: this.JSS({ type: 'chat_administrators', chat_id: '{{chat_id}}' }),\n        chat_member: this.JSS({ type: 'chat_member', chat_id: '{{chat_id}}', user_id: '{{user_id}}' })\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //ReplyKeyboardMarkup\n\n    /**\n     * Struttura ReplyKeyboardMarkup\n     * https://core.telegram.org/bots/api#replykeyboardmarkup\n     */\n    ReplyKeyboardMarkup = {\n        keyboard: [[{ text: 'Pulsante 1' }, { text: 'Pulsante 2' }]],\n        is_persistent: false,\n        resize_keyboard: true,\n        one_time_keyboard: false,\n        input_field_placeholder: 'Seleziona un pulsante',\n        selective: true\n    }\n\n    /**\n     * Struttura KeyboardButton\n     * https://core.telegram.org/bots/api#keyboardbutton\n     */\n    KeyboardButton = [\n        {\n            text: 'Pulsante 1',\n            request_contact: false,\n            request_location: false\n            //request_poll\n            //web_app\n        }\n    ]\n\n    /**\n     * Struttura ReplyKeyboardRemove\n     * https://core.telegram.org/bots/api#replykeyboardremove\n     */\n    ReplyKeyboardRemove = [\n        {\n            remove_keyboard: true,\n            selective: true\n        }\n    ]\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //FUNCTION\n\n    /**\n     * Restituisce l'url completa per l'invio del messaggio\n     */\n    GetUrl() {\n        if (!this.message) return null\n        const message = this.message.forward || this.message.telegram || null\n        if (!message) return null\n        message.method = message.method || this.GetMethod() || null\n        if (!message.method) return null\n        let options = message.options || {}\n\n        if (message.method == this.METHOD.answerCallbackQuery) {\n            return this.answerCallbackQuery(message.callback_query_id, options)\n        } else if (message.method == this.METHOD.approveChatJoinRequest) {\n            return this.approveChatJoinRequest(message.chat_id, message.user_id)\n        } else if (message.method == this.METHOD.banChatMember) {\n            return this.banChatMember(message.chat_id, message.user_id, options)\n        } else if (message.method == this.METHOD.banChatSenderChat) {\n            return this.banChatSenderChat(message.chat_id, message.sender_chat_id || message.chat_id)\n        } else if (message.method == this.METHOD.copyMessage) {\n            return this.copyMessage(message.chat_id, message.from_chat_id || message.chat_id, message.message_id, options)\n        } else if (message.method == this.METHOD.createChatInviteLink) {\n            return this.createChatInviteLink(message.chat_id, options)\n        } else if (message.method == this.METHOD.declineChatJoinRequest) {\n            return this.declineChatJoinRequest(message.chat_id, message.user_id)\n        } else if (message.method == this.METHOD.deleteChatPhoto) {\n            return this.deleteChatPhoto(message.chat_id)\n        } else if (message.method == this.METHOD.deleteChatStickerSet) {\n            return this.deleteChatStickerSet(message.chat_id)\n        } else if (message.method == this.METHOD.deleteMessage) {\n            return this.deleteMessage(message.chat_id, message.message_id)\n        } else if (message.method == this.METHOD.deleteMyCommands) {\n            return this.deleteMyCommands(options)\n        } else if (message.method == this.METHOD.editChatInviteLink) {\n            return this.editChatInviteLink(message.chat_id, message.invite_link, options)\n        } else if (message.method == this.METHOD.editMessageCaption) {\n            return this.editMessageCaption(message.caption || message.content, options)\n        } else if (message.method == this.METHOD.editMessageMedia) {\n            return this.editMessageMedia(message.media || message.content, options)\n        } else if (message.method == this.METHOD.editMessageReplyMarkup) {\n            return this.editMessageReplyMarkup(message.media || message.content, options)\n        } else if (message.method == this.METHOD.editMessageText) {\n            return this.editMessageText(message.text || message.content, options)\n        } else if (message.method == this.METHOD.exportChatInviteLink) {\n            return this.exportChatInviteLink(message.chat_id)\n        } else if (message.method == this.METHOD.forwardMessage) {\n            return this.forwardMessage(message.chat_id, message.from_chat_id || message.chat_id, message.message_id, options)\n        } else if (message.method == this.METHOD.getChat) {\n            return this.getChat(message.chat_id)\n        } else if (message.method == this.METHOD.getChatAdministrators) {\n            return this.getChatAdministrators(message.chat_id)\n        } else if (message.method == this.METHOD.getChatMember) {\n            return this.getChatMember(message.chat_id, message.user_id)\n        } else if (message.method == this.METHOD.getChatMemberCount) {\n            return this.getChatMemberCount(message.chat_id)\n        } else if (message.method == this.METHOD.getChatMenuButton) {\n            return this.getChatMenuButton(options)\n        } else if (message.method == this.METHOD.getFile) {\n            return this.getFile(message.file_id || message.content)\n        } else if (message.method == this.METHOD.getMyCommands) {\n            return this.getMyCommands(options)\n        } else if (message.method == this.METHOD.getMyDefaultAdministratorRights) {\n            return this.getMyDefaultAdministratorRights(options)\n        } else if (message.method == this.METHOD.getStickerSet) {\n            return this.getStickerSet(message.name)\n        } else if (message.method == this.METHOD.getUserProfilePhotos) {\n            return this.getUserProfilePhotos(message.user_id, options)\n        } else if (message.method == this.METHOD.leaveChat) {\n            return this.leaveChat(message.chat_id)\n        } else if (message.method == this.METHOD.pinChatMessage) {\n            return this.pinChatMessage(message.chat_id, message.message_id, options)\n        } else if (message.method == this.METHOD.promoteChatMember) {\n            return this.promoteChatMember(message.chat_id, message.user_id, options)\n        } else if (message.method == this.METHOD.restrictChatMember) {\n            return this.restrictChatMember(message.chat_id, message.user_id, message.permissions, options)\n        } else if (message.method == this.METHOD.revokeChatInviteLink) {\n            return this.revokeChatInviteLink(message.chat_id, message.invite_link)\n        } else if (message.method == this.METHOD.sendAnimation) {\n            return this.sendAnimation(message.chat_id, message.animation || message.content, options)\n        } else if (message.method == this.METHOD.sendAudio) {\n            return this.sendAudio(message.chat_id, message.audio || message.content, options)\n        } else if (message.method == this.METHOD.sendChatAction) {\n            return this.sendChatAction(message.chat_id, message.action || this.GetAction(message.content_type) || this.CHAT_ACTION.typing)\n        } else if (message.method == this.METHOD.sendContact) {\n            return this.sendContact(message.chat_id, message.phone_number, message.first_name || message.user.first_name, options)\n        } else if (message.method == this.METHOD.sendDice) {\n            return this.sendDice(message.chat_id, options)\n        } else if (message.method == this.METHOD.sendDocument) {\n            return this.sendDocument(message.chat_id, message.document || message.content, options)\n        } else if (message.method == this.METHOD.sendLocation) {\n            return this.sendLocation(message.chat_id, message.latitude, message.longitude, options)\n        } else if (message.method == this.METHOD.sendMessage) {\n            return this.sendMessage(message.chat_id, message.text || message.content, options)\n        } else if (message.method == this.METHOD.sendPhoto) {\n            return this.sendPhoto(message.chat_id, message.photo || message.content, options)\n        } else if (message.method == this.METHOD.sendPoll) {\n            return this.sendPoll(message.chat_id, message.question, message.pool_options, options)\n        } else if (message.method == this.METHOD.sendSticker) {\n            return this.sendSticker(message.chat_id, message.sticker || message.content, options)\n        } else if (message.method == this.METHOD.sendVenue) {\n            return this.sendVenue(message.chat_id, message.latitude, message.longitude, message.title, message.address, options)\n        } else if (message.method == this.METHOD.sendVideo) {\n            return this.sendVideo(message.chat_id, message.video || message.content, options)\n        } else if (message.method == this.METHOD.sendDocument) {\n            return this.sendDocument(message.chat_id, message.document || message.content, options)\n        } else if (message.method == this.METHOD.sendVideoNote) {\n            return this.sendVideoNote(message.chat_id, message.video_note || message.content, options)\n        } else if (message.method == this.METHOD.sendVoice) {\n            return this.sendVoice(message.chat_id, message.voice || message.content, options)\n        } else if (message.method == this.METHOD.setChatAdministratorCustomTitle) {\n            return this.setChatAdministratorCustomTitle(message.chat_id, message.user_id, message.custom_title)\n        } else if (message.method == this.METHOD.setChatDescription) {\n            return this.setChatDescription(message.chat_id, message.description)\n        } else if (message.method == this.METHOD.setChatMenuButton) {\n            return this.setChatMenuButton(options)\n        } else if (message.method == this.METHOD.setChatPermissions) {\n            return this.setChatPermissions(message.chat_id, message.permissions)\n        } else if (message.method == this.METHOD.setChatPhoto) {\n            return this.setChatPhoto(message.chat_id, message.photo)\n        } else if (message.method == this.METHOD.setChatStickerSet) {\n            return this.setChatStickerSet(message.chat_id, message.sticker_set_name)\n        } else if (message.method == this.METHOD.setChatTitle) {\n            return this.setChatTitle(message.chat_id, message.title)\n        } else if (message.method == this.METHOD.setMyCommands) {\n            return this.setMyCommands(message.commands, options)\n        } else if (message.method == this.METHOD.setMyDefaultAdministratorRights) {\n            return this.setMyDefaultAdministratorRights(options)\n        } else if (message.method == this.METHOD.stopPoll) {\n            return this.stopPoll(message.chat_id, message.message_id, options)\n        } else if (message.method == this.METHOD.unbanChatMember) {\n            return this.unbanChatMember(message.chat_id, message.user_id, options)\n        } else if (message.method == this.METHOD.unbanChatSenderChat) {\n            return this.unbanChatSenderChat(message.chat_id, message.sender_chat_id)\n        } else if (message.method == this.METHOD.unpinAllChatMessages) {\n            return this.unpinAllChatMessages(message.chat_id)\n        } else if (message.method == this.METHOD.unpinChatMessage) {\n            return this.unpinChatMessage(message.chat_id, message.message_id)\n        } else if (message.method == this.METHOD.uploadStickerFile) {\n            return this.uploadStickerFile(message.user_id, message.png_sticker)\n        } else {\n            return null\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //FUNCTION\n\n    /**\n     * Restituisce il metodo in base al tipo di messaggio o url\n     * @param {string} url Url da valutare\n     * @return {string} Metodo di Telegram\n     */\n    GetMethod(url = null) {\n        //in base all'url se impostata\n        if (url) {\n            var re\n            var methods = Object.values(this.METHOD)\n            for (let i = 0; i < methods.length; i++) {\n                re = new RegExp(`\\/${methods[i]}\\?`, 'i')\n                if (re.test(url)) return methods[i]\n            }\n            return this.UNKNOWN\n        }\n\n        //in base al messaggio\n        let message = this.message\n        if (!message) return null\n\n        if (message.telegram) {\n            //in base al tipo di contenuto (msg.telegram.content_type)\n            if (message.telegram.content_type == this.CONTENT_TYPE.animation) return this.METHOD.sendAnimation\n            if (message.telegram.content_type == this.CONTENT_TYPE.audio) return this.METHOD.sendAudio\n            if (message.telegram.content_type == this.CONTENT_TYPE.contact) return this.METHOD.sendContact\n            if (message.telegram.content_type == this.CONTENT_TYPE.dice) return this.METHOD.sendDice\n            if (message.telegram.content_type == this.CONTENT_TYPE.document) return this.METHOD.sendDocument\n            if (message.telegram.content_type == this.CONTENT_TYPE.location) return this.METHOD.sendLocation\n            if (message.telegram.content_type == this.CONTENT_TYPE.photo) return this.METHOD.sendPhoto\n            if (message.telegram.content_type == this.CONTENT_TYPE.sticker) return this.METHOD.sendSticker\n            if (message.telegram.content_type == this.CONTENT_TYPE.text) return this.METHOD.sendMessage\n            if (message.telegram.content_type == this.CONTENT_TYPE.venue) return this.METHOD.sendVenue\n            if (message.telegram.content_type == this.CONTENT_TYPE.video) return this.METHOD.sendVideo\n            if (message.telegram.content_type == this.CONTENT_TYPE.video_note) return this.METHOD.sendVideoNote\n            if (message.telegram.content_type == this.CONTENT_TYPE.voice) return this.METHOD.sendVoice\n            //in base al tipo di messaggio (msg.telegram.message_type)\n            if (message.telegram.message_type == this.MESSAGE_TYPE.callback_query) return this.METHOD.answerCallbackQuery\n            if (message.telegram.message_type == this.MESSAGE_TYPE.channel_post) return null\n            if (message.telegram.message_type == this.MESSAGE_TYPE.chat_join_request) return null\n            if (message.telegram.message_type == this.MESSAGE_TYPE.chat_member) return null\n            if (message.telegram.message_type == this.MESSAGE_TYPE.chosen_inline_result) return null\n            if (message.telegram.message_type == this.MESSAGE_TYPE.edited_channel_post) return this.METHOD.sendMessage\n            if (message.telegram.message_type == this.MESSAGE_TYPE.edited_message) return this.METHOD.sendMessage\n            if (message.telegram.message_type == this.MESSAGE_TYPE.inline_query) return null\n            if (message.telegram.message_type == this.MESSAGE_TYPE.message) return this.METHOD.sendMessage\n            if (message.telegram.message_type == this.MESSAGE_TYPE.my_chat_member) return null\n            if (message.telegram.message_type == this.MESSAGE_TYPE.pinned_message) return this.METHOD.sendMessage\n            if (message.telegram.message_type == this.MESSAGE_TYPE.poll) return null\n            if (message.telegram.message_type == this.MESSAGE_TYPE.poll_answer) return null\n            if (message.telegram.message_type == this.MESSAGE_TYPE.pre_checkout_query) return null\n            if (message.telegram.message_type == this.MESSAGE_TYPE.reply_to_message) return this.METHOD.sendMessage\n            if (message.telegram.message_type == this.MESSAGE_TYPE.shipping_query) return null\n        } else {\n            //in base al tipo di messaggio (msg.update)\n            if (message.callback_query == this.MESSAGE_TYPE.callback_query) return this.METHOD.answerCallbackQuery\n            if (message.channel_post == this.MESSAGE_TYPE.channel_post) return null\n            if (message.chat_join_request == this.MESSAGE_TYPE.chat_join_request) return null\n            if (message.chat_member == this.MESSAGE_TYPE.chat_member) return null\n            if (message.chosen_inline_result == this.MESSAGE_TYPE.chosen_inline_result) return null\n            if (message.edited_channel_post == this.MESSAGE_TYPE.edited_channel_post) return this.METHOD.sendMessage\n            if (message.edited_message == this.MESSAGE_TYPE.edited_message) return this.METHOD.sendMessage\n            if (message.inline_query == this.MESSAGE_TYPE.inline_query) return null\n            if (message.message == this.MESSAGE_TYPE.message) return this.METHOD.sendMessage\n            if (message.my_chat_member == this.MESSAGE_TYPE.my_chat_member) return null\n            if (message.pinned_message == this.MESSAGE_TYPE.pinned_message) return this.METHOD.sendMessage\n            if (message.poll == this.MESSAGE_TYPE.poll) return null\n            if (message.poll_answer == this.MESSAGE_TYPE.poll_answer) return null\n            if (message.pre_checkout_query == this.MESSAGE_TYPE.pre_checkout_query) return null\n            if (message.reply_to_message == this.MESSAGE_TYPE.reply_to_message) return this.METHOD.sendMessage\n            if (message.shipping_query == this.MESSAGE_TYPE.shipping_query) return null\n        }\n        return null\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //FUNCTION\n\n    /**\n     * Stabilisce il contenuto dal messaggio\n     * @param {{}} message Messaggio di Node-RED (msg)\n     * @return {string} Contenuto messaggio\n     */\n    GetContent(message = this.message) {\n        let content = null\n        let content_type = this.GetContentType(message)\n        if (content_type != this.UNKNOWN) {\n            if (content_type == this.CONTENT_TYPE.text) {\n                content = this.JSGet(content_type, message)\n            } else {\n                content = this.JSGet('file_id', message)\n            }\n            if (!content) content = this.JSGet(content_type, message)\n        }\n        return content || this.UNKNOWN\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //FUNCTION\n\n    /**\n     * Stabilisce il tipo di contenuto dal messaggio\n     * @param {{}} message Messaggio di Node-RED (msg)\n     * @return {string} Tipologia contenuto messaggio\n     */\n    GetContentType(message = this.message) {\n        if (!message) return this.UNKNOWN\n        if (message.content_type) return message.content_type\n        if (message.telegram && message.telegram.content_type) return message.telegram.content_type\n        for (let content_type in this.CONTENT_TYPE) {\n            if (message.hasOwnProperty(content_type)) return content_type\n        }\n        return this.UNKNOWN\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //FUNCTION\n\n    /**\n     * Stabilisce l'azione dal messaggio\n     * @param {string | {}} object Tipologia contenuto o messaggio di Node-RED (msg)\n     * @return {string} Tipologia di azione\n     */\n    GetAction(object = null) {\n        if (object === null || object === undefined) {\n            return this.CHAT_ACTION.typing\n        } else if (typeof object === 'object') {\n            object = this.GetContentType(object)\n        } else if (typeof object === 'string') {\n            if (object.startsWith('http')) {\n                object = this.GetMethod(object)\n            } else {\n                for (let content_type in this.CONTENT_TYPE) {\n                    if (object == content_type) {\n                        object = content_type\n                        break\n                    }\n                }\n            }\n        } else {\n            return this.CHAT_ACTION.typing\n        }\n\n        switch (object) {\n            case this.CONTENT_TYPE.text:\n                return this.CHAT_ACTION.typing\n            case this.METHOD.sendMessage:\n                return this.CHAT_ACTION.typing\n            case this.CONTENT_TYPE.document:\n                return this.CHAT_ACTION.upload_document\n            case this.METHOD.sendDocument:\n                return this.CHAT_ACTION.upload_document\n            case this.CONTENT_TYPE.photo:\n                return this.CHAT_ACTION.upload_photo\n            case this.CONTENT_TYPE.animation:\n                return this.CHAT_ACTION.upload_photo\n            case this.METHOD.sendPhoto:\n                return this.CHAT_ACTION.upload_photo\n            case this.METHOD.sendAnimation:\n                return this.CHAT_ACTION.upload_photo\n            case this.CONTENT_TYPE.video_note:\n                return this.CHAT_ACTION.upload_video_note\n            case this.METHOD.sendVideoNote:\n                return this.CHAT_ACTION.upload_video_note\n            case this.CONTENT_TYPE.audio:\n                return this.CHAT_ACTION.record_audio\n            case this.CONTENT_TYPE.voice:\n                return this.CHAT_ACTION.record_audio\n            case this.METHOD.sendAudio:\n                return this.CHAT_ACTION.record_audio\n            case this.METHOD.sendVoice:\n                return this.CHAT_ACTION.record_audio\n            case this.CONTENT_TYPE.video:\n                return this.CHAT_ACTION.record_video\n            case this.METHOD.sendVideo:\n                return this.CHAT_ACTION.record_video\n            case this.CONTENT_TYPE.location:\n                return this.CHAT_ACTION.find_location\n            case this.CONTENT_TYPE.venue:\n                return this.CHAT_ACTION.find_location\n            case this.METHOD.sendLocation:\n                return this.CHAT_ACTION.find_location\n            case this.METHOD.sendVenue:\n                return this.CHAT_ACTION.find_location\n            default:\n                return this.CHAT_ACTION.typing\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //FUNCTION\n\n    /**\n    * Stabilisce l'id della chat da una stringa\n    * @param {string} string Stringa da valutare\n    * @param {any} returnValue Valore di ritorno in caso di null\n    */\n    GetChatId(string, returnValue = null) {\n        if (!string) return returnValue\n        if (typeof string !== 'string') string = string.toString()\n        let match = string.match(/chat_id=(.*?)&/i)\n        return (match && match.length > 0) ? match[1] : returnValue\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //FUNCTION\n\n    /**\n    * Stabilisce l'id del messaggio da una stringa\n    * @param {string} string Stringa da valutare\n    * @param {any} returnValue Valore di ritorno in caso di null\n    */\n    GetMessageId(string, returnValue = null) {\n        if (!string) return returnValue\n        if (typeof string !== 'string') string = string.toString()\n        let match = string.match(/message_id=(.*?)$/i)\n        return (match && match.length > 0) ? match[1] : returnValue\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //FUNCTION\n\n    /**\n     * Restituisce una Array contenente i pulsanti della tastiera\n     * @param {any[]} keyboard Tastiera da valutare\n     */\n    GetKeyboardButtons(keyboard) {\n        if (typeof keyboard === 'string') return []\n        let buttons = []\n\n        for (let i = 0; i < keyboard.length; i++) {\n            let button = Object.values(keyboard[i])\n            for (let i = 0; i < button.length; i++) {\n                if (button[i].callback_data) {\n                    buttons.push(button[i].callback_data)\n                } else if (button[i].text) {\n                    buttons.push(button[i].text)\n                } else {\n                    if (typeof button[i] !== 'object') buttons.push(button[i])\n                }\n            }\n        }\n\n        return buttons\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //FUNCTION\n\n    /**\n     * Verifica se la risposta è corretta\n     * @param {string} answer Risposta\n     * @param {string | []} answers Risposte\n     */\n    AnswerIsCorrect(answer, answers) {\n        if (answer === null || answer === undefined || (typeof answer === 'string' && answer.trim() == '')) return false\n        if (answers === null || answers === undefined || answers.length == 0) return false\n        if (typeof answer === 'string' && Array.isArray(answers)) {\n            return answers.includes(answer)\n        } else if (typeof answer === 'string' && typeof answers === 'string') {\n            return (answer.trim() == answers.trim())\n        } else {\n            return (answer == answers)\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //TELEGRAM METHODS FUNCTION\n\n    /**\n     * https://core.telegram.org/bots/api#sendmessage\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string} text Contenuto da inviare\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    sendMessage(chat_id, text, options = {}) {\n        let url = `${this.url_base}sendMessage?chat_id=${chat_id}&text=${text}`\n        if (options.message_thread_id) url += `&message_thread_id=${options.message_thread_id}`\n        if (options.parse_mode) url += `&parse_mode=${options.parse_mode}`\n        if (options.entities) url += `&entities=${this.JSS(options.entities)}`\n        if (options.disable_web_page_preview) url += `&disable_web_page_preview=${options.disable_web_page_preview}`\n        if (options.disable_notification) url += `&disable_notification=${options.disable_notification}`\n        if (options.protect_content) url += `&protect_content=${options.protect_content}`\n        if (options.reply_to_message_id) url += `&reply_to_message_id=${options.reply_to_message_id}`\n        if (options.allow_sending_without_reply) url += `&allow_sending_without_reply=${options.allow_sending_without_reply}`\n        if (options.reply_markup) url += `&reply_markup=${this.JSS(options.reply_markup)}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#forwardmessage\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string | number} from_chat_id Identificativo chat di provenienza\n     * @param {string | number} message_id Identificativo messaggio\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    forwardMessage(chat_id, from_chat_id, message_id, options = {}) {\n        let url = `${this.url_base}forwardMessage?chat_id=${chat_id}&from_chat_id=${from_chat_id}&message_id=${message_id}`\n        if (options.message_thread_id) url += `&message_thread_id=${options.message_thread_id}`\n        if (options.disable_notification) url += `&disable_notification=${options.disable_notification}`\n        if (options.protect_content) url += `&protect_content=${options.protect_content}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#copymessage\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string | number} from_chat_id Identificativo chat di provenienza\n     * @param {string | number} message_id Identificativo messaggio\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    copyMessage(chat_id, from_chat_id, message_id, options = {}) {\n        let url = `${this.url_base}copyMessage?chat_id=${chat_id}&from_chat_id=${from_chat_id}&message_id=${message_id}`\n        if (options.message_thread_id) url += `&message_thread_id=${options.message_thread_id}`\n        if (options.caption) url += `&caption=${options.caption}`\n        if (options.parse_mode) url += `&parse_mode=${options.parse_mode}`\n        if (options.caption_entities) url += `&caption_entities=${this.JSS(options.caption_entities)}`\n        if (options.disable_notification) url += `&disable_notification=${options.disable_notification}`\n        if (options.protect_content) url += `&protect_content=${options.protect_content}`\n        if (options.reply_to_message_id) url += `&reply_to_message_id=${options.reply_to_message_id}`\n        if (options.allow_sending_without_reply) url += `&allow_sending_without_reply=${options.allow_sending_without_reply}`\n        if (options.reply_markup) url += `&reply_markup=${this.JSS(options.reply_markup)}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#sendphoto\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string} photo Contenuto da inviare\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    sendPhoto(chat_id, photo, options = {}) {\n        let url = `${this.url_base}sendPhoto?chat_id=${chat_id}&photo=${photo}`\n        if (options.message_thread_id) url += `&message_thread_id=${options.message_thread_id}`\n        if (options.caption) url += `&caption=${options.caption}`\n        if (options.parse_mode) url += `&parse_mode=${options.parse_mode}`\n        if (options.caption_entities) url += `&caption_entities=${this.JSS(options.caption_entities)}`\n        if (options.has_spoiler) url += `&has_spoiler=${options.has_spoiler}`\n        if (options.disable_notification) url += `&disable_notification=${options.disable_notification}`\n        if (options.protect_content) url += `&protect_content=${options.protect_content}`\n        if (options.reply_to_message_id) url += `&reply_to_message_id=${options.reply_to_message_id}`\n        if (options.allow_sending_without_reply) url += `&allow_sending_without_reply=${options.allow_sending_without_reply}`\n        if (options.reply_markup) url += `&reply_markup=${this.JSS(options.reply_markup)}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#sendaudio\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string} audio Contenuto da inviare\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    sendAudio(chat_id, audio, options = {}) {\n        let url = `${this.url_base}sendAudio?chat_id=${chat_id}&audio=${audio}`\n        if (options.message_thread_id) url += `&message_thread_id=${options.message_thread_id}`\n        if (options.caption) url += `&caption=${options.caption}`\n        if (options.parse_mode) url += `&parse_mode=${options.parse_mode}`\n        if (options.caption_entities) url += `&caption_entities=${this.JSS(options.caption_entities)}`\n        if (options.duration) url += `&duration=${options.duration}`\n        if (options.performer) url += `&performer=${options.performer}`\n        if (options.title) url += `&title=${options.title}`\n        if (options.thumb) url += `&thumb=${options.thumb}`\n        if (options.disable_notification) url += `&disable_notification=${options.disable_notification}`\n        if (options.protect_content) url += `&protect_content=${options.protect_content}`\n        if (options.reply_to_message_id) url += `&reply_to_message_id=${options.reply_to_message_id}`\n        if (options.allow_sending_without_reply) url += `&allow_sending_without_reply=${options.allow_sending_without_reply}`\n        if (options.reply_markup) url += `&reply_markup=${this.JSS(options.reply_markup)}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#senddocument\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string} document Contenuto da inviare\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    sendDocument(chat_id, document, options = {}) {\n        let url = `${this.url_base}sendDocument?chat_id=${chat_id}&document=${document}`\n        if (options.message_thread_id) url += `&message_thread_id=${options.message_thread_id}`\n        if (options.thumb) url += `&thumb=${options.thumb}`\n        if (options.caption) url += `&caption=${options.caption}`\n        if (options.parse_mode) url += `&parse_mode=${options.parse_mode}`\n        if (options.caption_entities) url += `&caption_entities=${this.JSS(options.caption_entities)}`\n        if (options.disable_content_type_detection) url += `&disable_content_type_detection=${options.disable_content_type_detection}`\n        if (options.disable_notification) url += `&disable_notification=${options.disable_notification}`\n        if (options.protect_content) url += `&protect_content=${options.protect_content}`\n        if (options.reply_to_message_id) url += `&reply_to_message_id=${options.reply_to_message_id}`\n        if (options.allow_sending_without_reply) url += `&allow_sending_without_reply=${options.allow_sending_without_reply}`\n        if (options.reply_markup) url += `&reply_markup=${this.JSS(options.reply_markup)}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#sendvideo\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string} video Contenuto da inviare\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    sendVideo(chat_id, video, options = {}) {\n        let url = `${this.url_base}sendDocument?chat_id=${chat_id}&video=${video}`\n        if (options.message_thread_id) url += `&message_thread_id=${options.message_thread_id}`\n        if (options.duration) url += `&duration=${options.duration}`\n        if (options.width) url += `&width=${options.width}`\n        if (options.height) url += `&height=${options.height}`\n        if (options.thumb) url += `&thumb=${options.thumb}`\n        if (options.caption) url += `&caption=${options.caption}`\n        if (options.parse_mode) url += `&parse_mode=${options.parse_mode}`\n        if (options.caption_entities) url += `&caption_entities=${this.JSS(options.caption_entities)}`\n        if (options.has_spoiler) url += `&has_spoiler=${options.has_spoiler}`\n        if (options.supports_streaming) url += `&supports_streaming=${options.supports_streaming}`\n        if (options.disable_notification) url += `&disable_notification=${options.disable_notification}`\n        if (options.protect_content) url += `&protect_content=${options.protect_content}`\n        if (options.reply_to_message_id) url += `&reply_to_message_id=${options.reply_to_message_id}`\n        if (options.allow_sending_without_reply) url += `&allow_sending_without_reply=${options.allow_sending_without_reply}`\n        if (options.reply_markup) url += `&reply_markup=${this.JSS(options.reply_markup)}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#sendanimation\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string} animation Contenuto da inviare\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    sendAnimation(chat_id, animation, options = {}) {\n        let url = `${this.url_base}sendAnimation?chat_id=${chat_id}&animation=${animation}`\n        if (options.message_thread_id) url += `&message_thread_id=${options.message_thread_id}`\n        if (options.duration) url += `&duration=${options.duration}`\n        if (options.width) url += `&width=${options.width}`\n        if (options.height) url += `&height=${options.height}`\n        if (options.thumb) url += `&thumb=${options.thumb}`\n        if (options.caption) url += `&caption=${options.caption}`\n        if (options.parse_mode) url += `&parse_mode=${options.parse_mode}`\n        if (options.caption_entities) url += `&caption_entities=${this.JSS(options.caption_entities)}`\n        if (options.has_spoiler) url += `&has_spoiler=${options.has_spoiler}`\n        if (options.disable_notification) url += `&disable_notification=${options.disable_notification}`\n        if (options.protect_content) url += `&protect_content=${options.protect_content}`\n        if (options.reply_to_message_id) url += `&reply_to_message_id=${options.reply_to_message_id}`\n        if (options.allow_sending_without_reply) url += `&allow_sending_without_reply=${options.allow_sending_without_reply}`\n        if (options.reply_markup) url += `&reply_markup=${this.JSS(options.reply_markup)}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#sendvoice\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string} voice Contenuto da inviare\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    sendVoice(chat_id, voice, options = {}) {\n        let url = `${this.url_base}sendVoice?chat_id=${chat_id}&voice=${voice}`\n        if (options.message_thread_id) url += `&message_thread_id=${options.message_thread_id}`\n        if (options.caption) url += `&caption=${options.caption}`\n        if (options.parse_mode) url += `&parse_mode=${options.parse_mode}`\n        if (options.caption_entities) url += `&caption_entities=${this.JSS(options.caption_entities)}`\n        if (options.duration) url += `&duration=${options.duration}`\n        if (options.disable_notification) url += `&disable_notification=${options.disable_notification}`\n        if (options.protect_content) url += `&protect_content=${options.protect_content}`\n        if (options.reply_to_message_id) url += `&reply_to_message_id=${options.reply_to_message_id}`\n        if (options.allow_sending_without_reply) url += `&allow_sending_without_reply=${options.allow_sending_without_reply}`\n        if (options.reply_markup) url += `&reply_markup=${this.JSS(options.reply_markup)}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#sendvideonote\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string} video_note Contenuto da inviare\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    sendVideoNote(chat_id, video_note, options = {}) {\n        let url = `${this.url_base}sendVideoNote?chat_id=${chat_id}&video_note=${video_note}`\n        if (options.message_thread_id) url += `&message_thread_id=${options.message_thread_id}`\n        if (options.duration) url += `&duration=${options.duration}`\n        if (options.length) url += `&length=${options.length}`\n        if (options.thumb) url += `&thumb=${options.thumb}`\n        if (options.disable_notification) url += `&disable_notification=${options.disable_notification}`\n        if (options.protect_content) url += `&protect_content=${options.protect_content}`\n        if (options.reply_to_message_id) url += `&reply_to_message_id=${options.reply_to_message_id}`\n        if (options.allow_sending_without_reply) url += `&allow_sending_without_reply=${options.allow_sending_without_reply}`\n        if (options.reply_markup) url += `&reply_markup=${this.JSS(options.reply_markup)}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#sendmediagroup\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string} media Contenuto da inviare\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    sendMediaGroup(chat_id, media, options = {}) {\n        let url = `${this.url_base}sendMediaGroup?chat_id=${chat_id}&media=${media}`\n        if (options.message_thread_id) url += `&message_thread_id=${options.message_thread_id}`\n        if (options.disable_notification) url += `&disable_notification=${options.disable_notification}`\n        if (options.protect_content) url += `&protect_content=${options.protect_content}`\n        if (options.reply_to_message_id) url += `&reply_to_message_id=${options.reply_to_message_id}`\n        if (options.allow_sending_without_reply) url += `&allow_sending_without_reply=${options.allow_sending_without_reply}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#sendlocation\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string} latitude Coordinata del luogo\n     * @param {string} longitude Coordinata del luogo\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    sendLocation(chat_id, latitude, longitude, options = {}) {\n        let url = `${this.url_base}sendLocation?chat_id=${chat_id}&latitude=${latitude}&longitude=${longitude}`\n        if (options.message_thread_id) url += `&message_thread_id=${options.message_thread_id}`\n        if (options.horizontal_accuracy) url += `&horizontal_accuracy=${options.horizontal_accuracy}`\n        if (options.live_period) url += `&live_period=${options.live_period}`\n        if (options.heading) url += `&heading=${options.heading}`\n        if (options.proximity_alert_radius) url += `&proximity_alert_radius=${options.proximity_alert_radius}`\n        if (options.disable_notification) url += `&disable_notification=${options.disable_notification}`\n        if (options.protect_content) url += `&protect_content=${options.protect_content}`\n        if (options.reply_to_message_id) url += `&reply_to_message_id=${options.reply_to_message_id}`\n        if (options.allow_sending_without_reply) url += `&allow_sending_without_reply=${options.allow_sending_without_reply}`\n        if (options.reply_markup) url += `&reply_markup=${this.JSS(options.reply_markup)}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#editmessagelivelocation\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    editMessageLiveLocation(options = {}) {\n        let url = `${this.url_base}editMessageLiveLocation`\n\n        if (options.chat_id && options.message_id) {\n            url += `?chat_id=${options.chat_id}&message_id=${options.message_id}`\n        } else if (options.inline_message_id) {\n            url += `?inline_message_id=${options.inline_message_id}`\n        } else {\n            let chat_id = this.JSGet('chat_id') || this.JSGet('chat.id')\n            let message_id = this.JSGet('message_id') || this.JSGet('message.id')\n            if (!chat_id || !message_id) return ''\n            url += `?chat_id=${chat_id}&message_id=${message_id}`\n        }\n\n        if (options.latitude) url += `&latitude=${options.latitude}`\n        if (options.longitude) url += `&longitude=${options.longitude}`\n        if (options.horizontal_accuracy) url += `&horizontal_accuracy=${options.horizontal_accuracy}`\n        if (options.heading) url += `&heading=${options.heading}`\n        if (options.proximity_alert_radius) url += `&proximity_alert_radius=${options.proximity_alert_radius}`\n        if (options.reply_markup) url += `&reply_markup=${this.JSS(options.reply_markup)}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#stopmessagelivelocation\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    stopMessageLiveLocation(options = {}) {\n        let url = `${this.url_base}stopMessageLiveLocation?`\n\n        if (options.chat_id && options.message_id) {\n            url += `?chat_id=${options.chat_id}&message_id=${options.message_id}`\n        } else if (options.inline_message_id) {\n            url += `?inline_message_id=${options.inline_message_id}`\n        } else {\n            let chat_id = this.JSGet('chat_id') || this.JSGet('chat.id')\n            let message_id = this.JSGet('message_id') || this.JSGet('message.id')\n            if (!chat_id || !message_id) return ''\n            url += `?chat_id=${chat_id}&message_id=${message_id}`\n        }\n\n        if (options.reply_markup) url += `&reply_markup=${this.JSS(options.reply_markup)}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#sendvenue\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string} latitude Coordinata del luogo\n     * @param {string} longitude Coordinata del luogo\n     * @param {string} title Titolo del luogo\n     * @param {string} address Indirizzo del luogo\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    sendVenue(chat_id, latitude, longitude, title, address, options = {}) {\n        let url = `${this.url_base}sendVenue?chat_id=${chat_id}&latitude=${latitude}&longitude=${longitude}&title=${title}&address=${address}`\n        if (options.message_thread_id) url += `&message_thread_id=${options.message_thread_id}`\n        if (options.foursquare_id) url += `&foursquare_id=${options.foursquare_id}`\n        if (options.foursquare_type) url += `&foursquare_type=${options.foursquare_type}`\n        if (options.google_place_id) url += `&google_place_id=${options.google_place_id}`\n        if (options.google_place_type) url += `&google_place_type=${options.google_place_type}`\n        if (options.disable_notification) url += `&disable_notification=${options.disable_notification}`\n        if (options.protect_content) url += `&protect_content=${options.protect_content}`\n        if (options.reply_to_message_id) url += `&reply_to_message_id=${options.reply_to_message_id}`\n        if (options.allow_sending_without_reply) url += `&allow_sending_without_reply=${options.allow_sending_without_reply}`\n        if (options.reply_markup) url += `&reply_markup=${this.JSS(options.reply_markup)}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#sendcontact\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string} phone_number Contatto telefonico\n     * @param {string} first_name Nome del contatto\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    sendContact(chat_id, phone_number, first_name, options = {}) {\n        let url = `${this.url_base}sendContact?chat_id=${chat_id}&phone_number=${phone_number}&first_name=${first_name}`\n        if (options.message_thread_id) url += `&message_thread_id=${options.message_thread_id}`\n        if (options.last_name) url += `&last_name=${options.last_name}`\n        if (options.vcard) url += `&vcard=${options.vcard}`\n        if (options.disable_notification) url += `&disable_notification=${options.disable_notification}`\n        if (options.protect_content) url += `&protect_content=${options.protect_content}`\n        if (options.reply_to_message_id) url += `&reply_to_message_id=${options.reply_to_message_id}`\n        if (options.allow_sending_without_reply) url += `&allow_sending_without_reply=${options.allow_sending_without_reply}`\n        if (options.reply_markup) url += `&reply_markup=${this.JSS(options.reply_markup)}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#sendpoll\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string} question Domanda del sondaggio\n     * @param {string | string []} pool_options Opzioni del sondaggio\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    sendPoll(chat_id, question, pool_options, options = {}) {\n        let url = `${this.url_base}sendPoll?chat_id=${chat_id}&question=${question}&options=${this.JSS(pool_options)}`\n        if (options.message_thread_id) url += `&message_thread_id=${options.message_thread_id}`\n        if (options.is_anonymous) url += `&is_anonymous=${options.is_anonymous}`\n        if (options.type) url += `&type=${options.type}`\n        if (options.allows_multiple_answers) url += `&allows_multiple_answers=${options.allows_multiple_answers}`\n        if (options.correct_option_id) url += `&correct_option_id=${options.correct_option_id}`\n        if (options.explanation) url += `&explanation=${options.explanation}`\n        if (options.explanation_parse_mode) url += `&explanation_parse_mode=${options.explanation_parse_mode}`\n        if (options.explanation_entities) url += `&explanation_entities=${this.JSS(options.explanation_entities)}`\n        if (options.open_period) url += `&open_period=${options.open_period}`\n        if (options.close_date) url += `&close_date=${options.close_date}`\n        if (options.is_closed) url += `&is_closed=${options.is_closed}`\n        if (options.disable_notification) url += `&disable_notification=${options.disable_notification}`\n        if (options.protect_content) url += `&protect_content=${options.protect_content}`\n        if (options.reply_to_message_id) url += `&reply_to_message_id=${options.reply_to_message_id}`\n        if (options.allow_sending_without_reply) url += `&allow_sending_without_reply=${options.allow_sending_without_reply}`\n        if (options.reply_markup) url += `&reply_markup=${this.JSS(options.reply_markup)}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#senddice\n     * @param {string | number} chat_id Identificativo chat\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    sendDice(chat_id, options = {}) {\n        let url = `${this.url_base}sendDice?chat_id=${chat_id}`\n        if (options.message_thread_id) url += `&message_thread_id=${options.message_thread_id}`\n        if (options.emoji) url += `&emoji=${options.emoji}`\n        if (options.disable_notification) url += `&disable_notification=${options.disable_notification}`\n        if (options.protect_content) url += `&protect_content=${options.protect_content}`\n        if (options.reply_to_message_id) url += `&reply_to_message_id=${options.reply_to_message_id}`\n        if (options.allow_sending_without_reply) url += `&allow_sending_without_reply=${options.allow_sending_without_reply}`\n        if (options.reply_markup) url += `&reply_markup=${this.JSS(options.reply_markup)}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#sendchataction\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string} action Tipo di azione, default CHAT_ACTION.typing\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    sendChatAction(chat_id, action = this.CHAT_ACTION.typing, options = {}) {\n        let url = `${this.url_base}sendChatAction?chat_id=${chat_id}&action=${action || this.CHAT_ACTION.typing}`\n        if (options.message_thread_id) url += `&message_thread_id=${options.message_thread_id}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#getuserprofilephotos\n     * @param {string | number} user_id Identificativo utente\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    getUserProfilePhotos(user_id, options = {}) {\n        let url = `${this.url_base}getUserProfilePhotos?user_id=${user_id}`\n        if (options.offset) url += `&offset=${options.offset}`\n        if (options.limit) url += `&limit=${options.limit}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#getfile\n     * @param {string} file_id Identificativo file\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    getFile(file_id) {\n        return `${this.url_base}getFile?file_id=${file_id}`\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#banchatmember\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string | number} user_id Identificativo utente\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    banChatMember(chat_id, user_id, options = {}) {\n        let url = `${this.url_base}banChatMember?chat_id=${chat_id}&user_id=${user_id}`\n        if (options.until_date) url += `&until_date=${options.until_date}`\n        if (options.revoke_messages) url += `&revoke_messages=${options.revoke_messages}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#unbanchatmember\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string | number} user_id Identificativo utente\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    unbanChatMember(chat_id, user_id, options = {}) {\n        let url = `${this.url_base}unbanChatMember?chat_id=${chat_id}&user_id=${user_id}`\n        if (options.only_if_banned) url += `&only_if_banned=${options.only_if_banned}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#restrictchatmember\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string | number} user_id Identificativo utente\n     * @param {string | string []} permissions Permessi utente, https://core.telegram.org/bots/api#chatpermissions\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    restrictChatMember(chat_id, user_id, permissions, options = {}) {\n        let url = `${this.url_base}restrictChatMember?chat_id=${chat_id}&user_id=${user_id}&permissions=${this.JSS(permissions)}`\n        if (options.until_date) url += `&until_date=${options.until_date}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#promotechatmember\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string | number} user_id Identificativo utente\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    promoteChatMember(chat_id, user_id, options = {}) {\n        let url = `${this.url_base}promoteChatMember?chat_id=${chat_id}&user_id=${user_id}`\n        if (options.is_anonymous) url += `&is_anonymous=${options.is_anonymous}`\n        if (options.can_manage_chat) url += `&can_manage_chat=${options.can_manage_chat}`\n        if (options.can_post_messages) url += `&can_post_messages=${options.can_post_messages}`\n        if (options.can_edit_messages) url += `&can_edit_messages=${options.can_edit_messages}`\n        if (options.can_delete_messages) url += `&can_delete_messages=${options.can_delete_messages}`\n        if (options.can_manage_video_chats) url += `&can_manage_video_chats=${options.can_manage_video_chats}`\n        if (options.can_restrict_members) url += `&can_restrict_members=${options.can_restrict_members}`\n        if (options.can_promote_members) url += `&can_promote_members=${options.can_promote_members}`\n        if (options.can_change_info) url += `&can_change_info=${options.can_change_info}`\n        if (options.can_invite_users) url += `&can_invite_users=${options.can_invite_users}`\n        if (options.can_pin_messages) url += `&can_pin_messages=${options.can_pin_messages}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#setchatadministratorcustomtitle\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string | number} user_id Identificativo utente\n     * @param {string} custom_title Nuovo titolo per l'amministratore (0-16 caratteri)\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    setChatAdministratorCustomTitle(chat_id, user_id, custom_title) {\n        return `${this.url_base}setChatAdministratorCustomTitle?chat_id=${chat_id}&user_id=${user_id}&custom_title=${custom_title}`\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#banchatsenderchat\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string | number} sender_chat_id Identificativo chat\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    banChatSenderChat(chat_id, sender_chat_id) {\n        return `${this.url_base}banChatSenderChat?chat_id=${chat_id}&sender_chat_id=${sender_chat_id}`\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#unbanchatsenderchat\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string | number} sender_chat_id Identificativo chat\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    unbanChatSenderChat(chat_id, sender_chat_id) {\n        return `${this.url_base}unbanChatSenderChat?chat_id=${chat_id}&sender_chat_id=${sender_chat_id}`\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#setchatpermissions\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string | string []} permissions Permessi utente, https://core.telegram.org/bots/api#chatpermissions\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    setChatPermissions(chat_id, permissions) {\n        return `${this.url_base}setChatPermissions?chat_id=${chat_id}&permissions=${this.JSS(permissions)}`\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#exportchatinvitelink\n     * @param {string | number} chat_id Identificativo chat\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    exportChatInviteLink(chat_id) {\n        return `${this.url_base}exportChatInviteLink?chat_id=${chat_id}`\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#createchatinvitelink\n     * @param {string | number} chat_id Identificativo chat\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    createChatInviteLink(chat_id, options = {}) {\n        let url = `${this.url_base}createChatInviteLink?chat_id=${chat_id}`\n        if (options.name) url += `&name=${options.name}`\n        if (options.expire_date) url += `&expire_date=${options.expire_date}`\n        if (options.member_limit) url += `&member_limit=${options.member_limit}`\n        if (options.creates_join_request) url += `&creates_join_request=${options.creates_join_request}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#editchatinvitelink\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string} invite_link Link invito\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    editChatInviteLink(chat_id, invite_link, options = {}) {\n        let url = `${this.url_base}editChatInviteLink?chat_id=${chat_id}&invite_link=${invite_link}`\n        if (options.name) url += `&name=${options.name}`\n        if (options.expire_date) url += `&expire_date=${options.expire_date}`\n        if (options.member_limit) url += `&member_limit=${options.member_limit}`\n        if (options.creates_join_request) url += `&creates_join_request=${options.creates_join_request}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#revokechatinvitelink\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string} invite_link Link invito\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    revokeChatInviteLink(chat_id, invite_link) {\n        return `${this.url_base}revokeChatInviteLink?chat_id=${chat_id}&invite_link=${invite_link}`\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#approvechatjoinrequest\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string | number} user_id Identificativo utente\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    approveChatJoinRequest(chat_id, user_id) {\n        return `${this.url_base}approveChatJoinRequest?chat_id=${chat_id}&user_id=${user_id}`\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#declinechatjoinrequest\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string | number} user_id Identificativo utente\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    declineChatJoinRequest(chat_id, user_id) {\n        return `${this.url_base}declineChatJoinRequest?chat_id=${chat_id}&user_id=${user_id}`\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#setchatphoto\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string} photo Foto, https://core.telegram.org/bots/api#inputfile\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    setChatPhoto(chat_id, photo) {\n        return `${this.url_base}setChatPhoto?chat_id=${chat_id}&photo=${photo}`\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#deletechatphoto\n     * @param {string | number} chat_id Identificativo chat\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    deleteChatPhoto(chat_id) {\n        return `${this.url_base}deleteChatPhoto?chat_id=${chat_id}`\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#setchattitle\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string} title Titolo (1-255 caratteri)\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    setChatTitle(chat_id, title) {\n        return `${this.url_base}setChatTitle?chat_id=${chat_id}&title=${title}`\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#setchatdescription\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string} description Titolo (1-255 caratteri)\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    setChatDescription(chat_id, description) {\n        return `${this.url_base}setChatDescription?chat_id=${chat_id}&description=${description}`\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#pinchatmessage\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string | number} message_id Identificativo messaggio\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    pinChatMessage(chat_id, message_id, options = {}) {\n        let url = `${this.url_base}pinChatMessage?chat_id=${chat_id}&message_id=${message_id}`\n        if (options.disable_notification) url += `&disable_notification=${options.disable_notification}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#unpinchatmessage\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string | number} message_id Identificativo messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    unpinChatMessage(chat_id, message_id) {\n        return `${this.url_base}unpinChatMessage?chat_id=${chat_id}&message_id=${message_id}`\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#unpinallchatmessages\n     * @param {string | number} chat_id Identificativo chat\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    unpinAllChatMessages(chat_id) {\n        return `${this.url_base}unpinAllChatMessages?chat_id=${chat_id}`\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#leavechat\n     * @param {string | number} chat_id Identificativo chat\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    leaveChat(chat_id) {\n        return `${this.url_base}leaveChat?chat_id=${chat_id}`\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#getchat\n     * @param {string | number} chat_id Identificativo chat\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    getChat(chat_id) {\n        return `${this.url_base}getChat?chat_id=${chat_id}`\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#getchatadministrators\n     * @param {string | number} chat_id Identificativo chat\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    getChatAdministrators(chat_id) {\n        return `${this.url_base}getChatAdministrators?chat_id=${chat_id}`\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#getchatmembercount\n     * @param {string | number} chat_id Identificativo chat\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    getChatMemberCount(chat_id) {\n        return `${this.url_base}getChatMemberCount?chat_id=${chat_id}`\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#getchatmember\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string | number} user_id Identificativo utente\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    getChatMember(chat_id, user_id) {\n        return `${this.url_base}getChatMember?chat_id=${chat_id}&user_id=${user_id}`\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#setchatstickerset\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string | number} sticker_set_name Nome set di sticker\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    setChatStickerSet(chat_id, sticker_set_name) {\n        return `${this.url_base}setChatStickerSet?chat_id=${chat_id}&sticker_set_name=${sticker_set_name}`\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#deletechatstickerset\n     * @param {string | number} chat_id Identificativo chat\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    deleteChatStickerSet(chat_id) {\n        return `${this.url_base}deleteChatStickerSet?chat_id=${chat_id}`\n    }\n\n    //getForumTopicIconStickers\n\n    //createForumTopic\n\n    //editForumTopic\n\n    //closeForumTopic\n\n    //reopenForumTopic\n\n    //deleteForumTopic\n\n    //unpinAllForumTopicMessages\n\n    //editGeneralForumTopic\n\n    //closeGeneralForumTopic\n\n    //reopenGeneralForumTopic\n\n    //hideGeneralForumTopic\n\n    //unhideGeneralForumTopic\n\n    /**\n     * https://core.telegram.org/bots/api#answercallbackquery\n     * @param {string | number} callback_query_id Identificativo callback\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    answerCallbackQuery(callback_query_id, options = {}) {\n        let url = `${this.url_base}answerCallbackQuery?callback_query_id=${callback_query_id}`\n        if (options.text) url += `&text=${options.text}`\n        if (options.show_alert) url += `&show_alert=${options.show_alert}`\n        if (options.cache_time) url += `&cache_time=${options.cache_time}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#setmycommands\n     * @param {string | string []} commands Comandi\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    setMyCommands(commands, options = {}) {\n        let url = `${this.url_base}setMyCommands?commands=${this.JSS(commands)}`\n        if (options.scope) url += `&scope=${this.JSS(options.scope)}`\n        if (options.language_code) url += `&language_code=${options.language_code}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#deletemycommands\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    deleteMyCommands(options = {}) {\n        let url = `${this.url_base}deleteMyCommands`\n        if (options.scope) url += `?scope=${this.JSS(options.scope)}`\n        if (options.language_code) {\n            url += (options.scope) ? '&' : '?'\n            url += `language_code=${options.language_code}`\n        }\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#getmycommands\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    getMyCommands(options = {}) {\n        let url = `${this.url_base}getMyCommands`\n        if (options.scope) url += `?scope=${this.JSS(options.scope)}`\n        if (options.language_code) {\n            url += (options.scope) ? '&' : '?'\n            url += `language_code=${options.language_code}`\n        }\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#setchatmenubutton\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    setChatMenuButton(options = {}) {\n        let url = `${this.url_base}setChatMenuButton`\n        if (options.chat_id) url += `?chat_id=${options.chat_id}`\n        if (options.menu_button) {\n            url += (options.chat_id) ? '&' : '?'\n            url += `menu_button=${options.menu_button}`\n        }\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#getchatmenubutton\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    getChatMenuButton(options = {}) {\n        let url = `${this.url_base}getChatMenuButton`\n        if (options.chat_id) url += `?chat_id=${options.chat_id}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#setmydefaultadministratorrights\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    setMyDefaultAdministratorRights(options = {}) {\n        let url = `${this.url_base}setMyDefaultAdministratorRights`\n        if (options.rights) url += `?rights=${this.JSS(options.rights)}`\n        if (options.for_channels) {\n            url += (options.rights) ? '&' : '?'\n            url += `for_channels=${options.for_channels}`\n        }\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#getmydefaultadministratorrights\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    getMyDefaultAdministratorRights(options = {}) {\n        let url = `${this.url_base}getMyDefaultAdministratorRights`\n        if (options.for_channels) url += `?for_channels=${options.for_channels}`\n        return url\n    }\n\n    //////////////////////////////////////////////////////////////////////////\n    //Updating messages\n    //https://core.telegram.org/bots/api#updating-messages\n    //////////////////////////////////////////////////////////////////////////\n\n    /**\n     * https://core.telegram.org/bots/api#editmessagetext\n     * @param {string} text Nuovo testo\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    editMessageText(text, options = {}) {\n        let url = `${this.url_base}editMessageText`\n\n        if (options.chat_id && options.message_id) {\n            url += `?chat_id=${options.chat_id}&message_id=${options.message_id}`\n        } else if (options.inline_message_id) {\n            url += `?inline_message_id=${options.inline_message_id}`\n        } else {\n            let chat_id = this.JSGet('chat_id') || this.JSGet('chat.id')\n            let message_id = this.JSGet('message_id') || this.JSGet('message.id')\n            if (!chat_id || !message_id) return ''\n            url += `?chat_id=${chat_id}&message_id=${message_id}`\n        }\n\n        url += `&text=${text}`\n        if (options.parse_mode) url += `&parse_mode=${options.parse_mode}`\n        if (options.entities) url += `&entities=${this.JSS(options.entities)}`\n        if (options.disable_web_page_preview) url += `&disable_web_page_preview=${options.disable_web_page_preview}`\n        if (options.reply_markup) url += `&reply_markup=${this.JSS(options.reply_markup)}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#editmessagecaption\n     * @param {string} caption Nuova didascalia\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    editMessageCaption(caption, options = {}) {\n        let url = `${this.url_base}editMessageCaption`\n\n        if (options.chat_id && options.message_id) {\n            url += `?chat_id=${options.chat_id}&message_id=${options.message_id}`\n        } else if (options.inline_message_id) {\n            url += `?inline_message_id=${options.inline_message_id}`\n        } else {\n            let chat_id = this.JSGet('chat_id') || this.JSGet('chat.id')\n            let message_id = this.JSGet('message_id') || this.JSGet('message.id')\n            if (!chat_id || !message_id) return ''\n            url += `?chat_id=${chat_id}&message_id=${message_id}`\n        }\n\n        url += `&caption=${caption}`\n        if (options.parse_mode) url += `&parse_mode=${options.parse_mode}`\n        if (options.caption_entities) url += `&caption_entities=${this.JSS(options.caption_entities)}`\n        if (options.reply_markup) url += `&reply_markup=${this.JSS(options.reply_markup)}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#editmessagemedia\n     * @param {string} media Nuova didascalia\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    editMessageMedia(media, options = {}) {\n        let url = `${this.url_base}editMessageMedia`\n\n        if (options.chat_id && options.message_id) {\n            url += `?chat_id=${options.chat_id}&message_id=${options.message_id}`\n        } else if (options.inline_message_id) {\n            url += `?inline_message_id=${options.inline_message_id}`\n        } else {\n            let chat_id = this.JSGet('chat_id') || this.JSGet('chat.id')\n            let message_id = this.JSGet('message_id') || this.JSGet('message.id')\n            if (!chat_id || !message_id) return ''\n            url += `?chat_id=${chat_id}&message_id=${message_id}`\n        }\n\n        url += `&media=${media}`\n        if (options.reply_markup) url += `&reply_markup=${this.JSS(options.reply_markup)}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#editmessagereplymarkup\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    editMessageReplyMarkup(media, options = {}) {\n        let url = `${this.url_base}editMessageReplyMarkup`\n\n        if (options.chat_id && options.message_id) {\n            url += `?chat_id=${options.chat_id}&message_id=${options.message_id}`\n        } else if (options.inline_message_id) {\n            url += `?inline_message_id=${options.inline_message_id}`\n        } else {\n            let chat_id = this.JSGet('chat_id') || this.JSGet('chat.id')\n            let message_id = this.JSGet('message_id') || this.JSGet('message.id')\n            if (!chat_id || !message_id) return ''\n            url += `?chat_id=${chat_id}&message_id=${message_id}`\n        }\n        if (options.reply_markup) url += `&reply_markup=${this.JSS(options.reply_markup)}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#stoppoll\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string | number} message_id Identificativo messaggio\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    stopPoll(chat_id, message_id, options = {}) {\n        let url = `${this.url_base}stopPoll?chat_id=${chat_id}&message_id=${message_id}`\n        if (options.reply_markup) url += `&reply_markup=${this.JSS(options.reply_markup)}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#deletemessage\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string | number} message_id Identificativo messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    deleteMessage(chat_id, message_id) {\n        return `${this.url_base}deleteMessage?chat_id=${chat_id}&message_id=${message_id}`\n    }\n\n    //////////////////////////////////////////////////////////////////////////\n    //Stickers\n    //https://core.telegram.org/bots/api#stickers\n    //////////////////////////////////////////////////////////////////////////\n\n    //Mancante Stickers\n    //https://core.telegram.org/bots/api#sticker\n\n    //Mancante StickerSet\n    //https://core.telegram.org/bots/api#stickerset\n\n    //Mancante MaskPosition\n    //https://core.telegram.org/bots/api#maskposition\n\n    /**\n     * https://core.telegram.org/bots/api#sendsticker\n     * @param {string | number} chat_id Identificativo chat\n     * @param {string} sticker File da inviare\n     * @param {{}} options Opzioni messaggio\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    sendSticker(chat_id, sticker, options = {}) {\n        let url = `${this.url_base}sendSticker?chat_id=${chat_id}&sticker=${sticker}`\n        if (options.message_thread_id) url += `&message_thread_id=${options.message_thread_id}`\n        if (options.disable_notification) url += `&disable_notification=${options.disable_notification}`\n        if (options.protect_content) url += `&protect_content=${options.protect_content}`\n        if (options.reply_to_message_id) url += `&reply_to_message_id=${options.reply_to_message_id}`\n        if (options.allow_sending_without_reply) url += `&allow_sending_without_reply=${options.allow_sending_without_reply}`\n        if (options.reply_markup) url += `&reply_markup=${this.JSS(options.reply_markup)}`\n        return url\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#getstickerset\n     * @param {string} name Nome del set\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    getStickerSet(name) {\n        return `${this.url_base}getStickerSet?name=${name}`\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#getcustomemojistickers\n     * @param {string} array Array set custom emoji\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    getCustomEmojiStickers(array) {\n        return `${this.url_base}getCustomEmojiStickers?custom_emoji_ids=${this.JSS(array)}`\n    }\n\n    /**\n     * https://core.telegram.org/bots/api#uploadstickerfile\n     * @param {string | number} user_id Identificativo utente\n     * @param {string} png_sticker File sticker\n     * @returns {string} Url completa e pronta per l'invio\n     */\n    uploadStickerFile(user_id, png_sticker) {\n        return `${this.url_base}uploadStickerFile?user_id=${user_id}&png_sticker=${png_sticker}`\n    }\n\n    //Mancante createNewStickerSet\n    //https://core.telegram.org/bots/api#createnewstickerset\n\n    //Mancante addStickerToSet\n    //https://core.telegram.org/bots/api#addstickertoset\n\n    //Mancante setStickerPositionInSet\n    //https://core.telegram.org/bots/api#setstickerpositioninset\n\n    //Mancante deleteStickerFromSet\n    //https://core.telegram.org/bots/api#deletestickerfromset\n\n    //Mancante setStickerSetThumb\n    //https://core.telegram.org/bots/api#setstickersetthumb\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nglobal.set('TelegramBotApi', { class: TelegramBotApi, version: '3.7.0', api: '6.4', date: Date.now() })\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//Telegram Bot Api Javascript for Node-RED//////////////////////////////////////////////////////////////////////////////////////////////",
        "finalize": "",
        "libs": [],
        "x": 240,
        "y": 330,
        "wires": []
    },
    {
        "id": "1d55ae881be97fe5",
        "type": "function",
        "z": "799d902a165e50be",
        "name": "Class Tools",
        "func": "//On Start",
        "outputs": 0,
        "noerr": 0,
        "initialize": "/**\n * Tools Class Collections Javascript for Node-RED\n * Bruno Leonardi - b.leonardi78@gmail.com\n * Version 3.6.5 - 02/01/2023\n */\nclass Tools {\n    /**\n     * @param {NodeMessage | {}} object Imposta l'oggetto o il messaggio fondamentale per alcune funzioni (Template...)\n     */\n    constructor(object = {}) {\n        this.object = object\n    }\n\n    /**\n     * Imposta il messaggio di Node-RED\n     * @param {NodeMessage} object\n     */\n    SetNodeMessage(object) {\n        this.object = object\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //NODE-RED FUNCTION\n\n    /**\n     * Restituisce il messaggio inserendo le nuove proprietà\n     * @param {string} path Proprietà oggetto (esempio: 'msg.payload.chiave1.chiave2')\n     * @param {any} value Valore proprietà\n     */\n    CreateMessage(path, value = null) {\n        var object = msg\n        RED.util.setMessageProperty(object, path, value, true)\n        return Object.assign(msg, object)\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //NODE-RED GLOBAL\n\n    /**\n     * Restituisce la variabile globale\n     * @param {string | string []} path Percorso variabile globale\n     * @param {any} returnValue Valore di ritorno in caso di variabile undefined o errore\n     */\n    GetGlobalVariable(path, returnValue = null) {\n        if (path === null || path === undefined || typeof path !== 'string') return returnValue\n        try {\n            return global.get(path)\n        } catch (error) {\n            return returnValue\n        }\n    }\n\n    //NODE-RED GLOBAL\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //STRING\n\n    /**\n     * Sostituisce l'apostrofo con l'apice dalla stringa\n     * @param {string} string Stringa da valutare\n     */\n    TextReplaceApostrophe(string) {\n        if (string === null || string === undefined || typeof string !== 'string') return string\n        return String.raw`${string}`.replace(/'/gm, '`')\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //STRING\n\n    /**\n     * Converte una stringa Ascii in Hex\n     * @param {string} string Stringa Ascii\n     */\n    AsciiToHex(string) {\n        if (string === null || string === undefined || typeof string !== 'string') return string\n        var hex_array = []\n        for (var n = 0, l = string.length; n < l; n++) {\n            let hex = Number(string.charCodeAt(n)).toString(16)\n            hex_array.push(hex)\n        }\n\n        return hex_array.join('')\n    }\n\n    /**\n     * Converte una stringa Hex in Ascii\n     * @param {string} string Stringa Hex\n     */\n    HexToAscii(string) {\n        if (string === null || string === undefined || typeof string !== 'string') return string\n        var hex = string.toString()\n        string = ''\n        for (var n = 0; n < hex.length; n += 2) {\n            string += String.fromCharCode(parseInt(hex.substr(n, 2), 16))\n        }\n\n        return string\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //STRING\n\n    /**\n     * Restituisce la stringa elaborata\n     * @param {string} string Stringa da valutare\n     * @param {string} text Stringa formato RegExp di ricerca\n     * @param {string} with_text Testo da applicare\n     * @param {string} flags Opzioni di ricerca RegExp, default 'gm'\n     * https://regex101.com/#javascript\n     */\n    TextReplace(string, text, with_text, flags = 'gm') {\n        if (string === null || string === undefined || typeof string !== 'string') return string\n        if (text === null || text === undefined || typeof text !== 'string') return string\n        if (with_text === null || with_text === undefined || typeof with_text !== 'string') return string\n        let re = new RegExp(text, flags)\n        return String.raw`${string}`.replace(re, with_text)\n    }\n\n    /**\n     * Restituisce una Array del match\n     * @param {string} string Stringa da valutare\n     * @param {string} text Stringa formato RegExp di ricerca\n     * @param {string} flags Opzioni di ricerca RegExp, default 'gmi'\n     * https://regex101.com/#javascript\n    */\n    TextMatch(string, text, flags = 'gmi') {\n        if (string === null || string === undefined || typeof string !== 'string') return []\n        if (text === null || text === undefined || typeof text !== 'string') return []\n        if (typeof string !== 'string') string = string.toString()\n        let re = new RegExp(text, flags)\n        let match = String.raw`${string}`.match(re)\n        return (match && match.length > 0) ? match : []\n    }\n\n    /**\n     * Restituisce un valore number\n     * @param {string} string Stringa da valutare\n     * @param {string | RegExp} text Testo da cercare\n     * @param {string} flags Opzioni di ricerca RegExp, default 'gmi'\n     * https://regex101.com/#javascript\n     */\n    TextSearch(string, text, flags = 'gmi') {\n        if (string === null || string === undefined || typeof string !== 'string') return false\n        if (text === null || text === undefined || typeof text !== 'string') return false\n        let re = new RegExp(text, flags)\n        return string.search(re)\n    }\n\n    /**\n     * Restituisce un valore booleano\n     * @param {string} string Stringa da valutare\n     * @param {string | RegExp} text Testo da cercare\n     * @param {string} flags Opzioni di ricerca RegExp, default 'gmi'\n     * https://regex101.com/#javascript\n     */\n    TextExists(string, text, flags = 'gmi') {\n        if (string === null || string === undefined || typeof string !== 'string') return false\n        if (text === null || text === undefined || typeof text !== 'string') return false\n        let re = new RegExp(text, flags)\n        return re.test(string)\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //STRING\n\n    /**\n     * Restituisce il valore terminato con il carattere specificato\n     * @param {string} string Stringa da valutare\n     * @param {string} char Carattere da assegnare\n     */\n    TextMustEndwith(string, char) {\n        if (string === null || string === undefined || typeof string !== 'string') return string\n        if (char === null || char === undefined || typeof char !== 'string') return string\n        string += (String.raw`${string}`.endsWith(char)) ? '' : char\n        return string\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //STRING\n\n    /**\n     * Verifica se la stringa contiene Emoji\n     * @param {string} string Stringa da valutare\n     */\n    ContainsEmoji(string) {\n        if (string === null || string === undefined || typeof string !== 'string') return false\n        const emojiKeycap = (/[\\u0023-\\u0039]\\ufe0f?\\u20e3/)\n        if (emojiKeycap.test(string)) return true\n        const emoji = (/[\\p{Extended_Pictographic}\\u{1F3FB}-\\u{1F3FF}\\u{1F9B0}-\\u{1F9B3}]/u)\n        return emoji.test(string)\n    }\n\n    /**\n     * Verifica se la stringa contiene soltanto Emoji\n     * @param {string} string Stringa da valutare\n     */\n    ContainsOnlyEmoji(string) {\n        if (string === null || string === undefined || typeof string !== 'string') return false\n        const emojiKeycap = (/[\\u0023-\\u0039]\\ufe0f?\\u20e3/g)\n        if (emojiKeycap.test(string)) string = String.raw`${string}`.replace(emojiKeycap, '')\n        const emoji = (/[\\p{Extended_Pictographic}\\u{1F3FB}-\\u{1F3FF}\\u{1F9B0}-\\u{1F9B3}]/gu)\n        if (emoji.test(string)) string = String.raw`${string}`.replace(emoji, '')\n        return (string.trim().length === 0)\n    }\n\n    /**\n     * Rimuove gli Emoji dalla stringa\n     * @param {string} string Stringa da valutare\n     */\n    RemoveEmoji(string) {\n        if (string === null || string === undefined || typeof string !== 'string') return false\n        const emojiKeycap = (/[\\u0023-\\u0039]\\ufe0f?\\u20e3/g)\n        if (emojiKeycap.test(string)) string = String.raw`${string}`.replace(emojiKeycap, '')\n        const emoji = (/[\\p{Extended_Pictographic}\\u{1F3FB}-\\u{1F3FF}\\u{1F9B0}-\\u{1F9B3}]/gu)\n        if (emoji.test(string)) string = String.raw`${string}`.replace(emoji, '')\n        return string\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //STRING\n\n    /** \n     * Verifica se un indirizzo di posta elettronica è corretto\n     * @param {string} email Indirizzo di posta elettronica da validare\n     */\n    IsEmail(email) {\n        return /^\\w+([\\.-]?\\w+)*@\\w+([\\.-]?\\w+)*(\\.\\w{2,3})+$/.test(email)\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //STRING\n\n    /**\n     * Verifica se un valore è di tipo Hex\n     * @param {string} value Valore da valutare\n     */\n    IsHex(value) {\n        if (value === null || value === undefined || typeof value !== 'string') return false\n        return (/^[A-F0-9]+$/i).test(value)\n    }\n\n    /**\n     * Verifica se un valore è di tipo Ascii\n     * @param {string} value Valore da valutare\n     */\n    IsAscii(value) {\n        if (value === null || value === undefined || typeof value !== 'string') return false\n        return (/^[\\x00-\\x7F]*$/).test(value)\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //STRING\n\n    /**\n     * {{Template}} - Restituisce il template elaborato\n     * @param {string} string Testo da processare\n     * @param {string[]} flags Delimitatori del valore, default ['{{', '}}'] \n     */\n    Template(string, flags = ['{{', '}}']) {\n        if (string === null || string === undefined || typeof string !== 'string') return string\n        if (string.trim() == '') return string\n        let re = new RegExp(flags[0] + '(.*?)' + flags[1], 'gmi')\n        let match = string.match(re)\n        if (!match) return string\n        if (match && match.length > 0) {\n            for (let index = 0; index < match.length; index++) {\n                const element = match[index]\n                let value = this.JSGet(element.substr(flags[0].length, element.length - (flags[0].length + flags[1].length)))\n                string = String.raw`${string}`.replace(element, value)\n            }\n\n        }\n\n        return string\n    }\n\n    //STRING\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //NUMBER\n\n    /**\n     * Verifica se un numero è pari\n     * @param {number} number Numero da valutare\n     */\n    IsEven(number) {\n        if (number === null || number === undefined) return false\n        return (Number(number) === number && number % 2 === 0)\n    }\n\n    /**\n     * Verifica se un numero è dispari\n     * @param {number} number Numero da valutare\n     */\n    IsOdd(number) {\n        if (number === null || number === undefined) return false\n        return (Number(number) === number && number % 2 !== 0)\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //NUMBER\n\n    /**\n     * Verifica se un numero è intero\n     * @param {number} number Numero da valutare\n     */\n    IsInteger(number) {\n        if (number === null || number === undefined) return false\n        return (Number(number) === number && number % 1 === 0)\n    }\n\n    /**\n     * Verifica se un numero è decimale\n     * @param {number} number Numero da valutare\n     */\n    IsDecimal(number) {\n        if (number === null || number === undefined) return false\n        return (Number(number) === number && number % 1 !== 0)\n    }\n\n    //NUMBER\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //OBJETC\n\n    /**\n     * Verifica se un oggetto è null o undefined\n     * @param {object} object Oggetto da verificare\n     */\n    IsNullOrUndefined(object) {\n        return (object === null || object === undefined)\n    }\n\n    /**\n     * Verifica se un oggetto è null\n     * @param {object} object Oggetto da verificare\n     */\n    IsNull(object) {\n        return (object === null)\n    }\n\n    /**\n     * Verifica se un oggetto è undefined\n     * @param {object} object Oggetto da verificare\n     */\n    IsUndefined(object) {\n        return (object === undefined)\n    }\n\n    /**\n     * Verifica se un oggetto è vuoto, null, undefined, numero negativo o stringa vuota\n     * @param {object} object Oggetto da verificare\n     */\n    IsNullOrEmpty(object) {\n        if (object === null || object === undefined) return true\n        switch (typeof object) {\n            case 'object':\n                //controlla se è vuoto\n                if (Array.isArray(object)) {\n                    return (object.length === 0)\n                } else if (object.constructor === Object && !Array.isArray(object)) {\n                    return (Object.keys(object).length === 0)\n                } else {\n                    return false\n                }\n            case 'string':\n                //elimina gli spazi e controlla se è vuota            \n                return (object.trim().length == 0)\n            case 'number':\n                //elimina gli spazi e controlla se è vuota            \n                return (object < 0)\n            default:\n                //per tutto il resto boolean, function...\n                return false\n        }\n    }\n\n    /**\n     * Verifica se un oggetto è vuoto, null o undefined\n     * @param {object} object Oggetto da verificare\n     */\n    IsEmpty(object) {\n        if (object === null || object === undefined) return true\n        switch (typeof object) {\n            case 'object':\n                //controlla se è vuoto\n                if (Array.isArray(object)) {\n                    return (object.length === 0)\n                } else if (object.constructor === Object && !Array.isArray(object)) {\n                    return (Object.keys(object).length === 0)\n                } else {\n                    return false\n                }\n            case 'string':\n                //elimina gli spazi e controlla se è vuota            \n                return (object.trim().length == 0)\n            default:\n                //per tutto il resto boolean, function...\n                return false\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //OBJETC\n\n    /**\n     * Verifica se un oggetto è di tipo String\n     * @param {object} object Oggetto da verificare\n     */\n    IsString(object) {\n        if (object === null || object === undefined) return false\n        return (typeof object === 'string')\n    }\n\n    /**\n     * Verifica se un oggetto è di tipo String vuota, non contiene caratteri\n     * @param {object} object Oggetto da verificare\n     */\n    IsStringEmpty(object) {\n        if (object === null || object === undefined) return true\n        return (typeof object === 'string' && object.trim().length === 0)\n    }\n\n    /**\n     * Verifica se un oggetto è di tipo String piena, contiene caratteri\n     * @param {object} object Oggetto da verificare\n     */\n    IsStringFull(object) {\n        if (object === null || object === undefined) return false\n        return (typeof object === 'string' && object.trim().length > 0)\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //OBJETC\n\n    /**\n     * Verifica se un oggetto è di tipo numerico\n     * @param {object} object Oggetto da verificare\n     */\n    IsNumber(object) {\n        if (object === null || object === undefined) return false\n        if ((typeof object === 'number' && isFinite(object)) || Object.prototype.toString.apply(object) === '[object Number]') return true\n        return (typeof object === \"string\" && !isNaN(object) && !isNaN(parseFloat(object)))\n    }\n\n    /**\n     * Verifica se un oggetto è di tipo numerico positivo, uguale o superiore a zero\n     * @param {object} object Oggetto da verificare\n     */\n    IsNumberPositive(object) {\n        return (this.IsNumber(object) && object >= 0)\n    }\n\n    /**\n     * Verifica se un oggetto è di tipo numerico negativo, inferiore a zero\n     * @param {object} object Oggetto da verificare\n     */\n    IsNumberNegative(object) {\n        return (this.IsNumber(object) && object < 0)\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //OBJETC\n\n    /**\n     * Verifica se un oggetto è di tipo Boolean\n     * @param {object} object Oggetto da verificare\n     */\n    IsBoolean(object) {\n        if (object === null || object === undefined) return false\n        return (typeof object === 'boolean')\n    }\n\n    /**\n     * Verifica se un oggetto è di tipo Boolean True\n     * @param {object} object Oggetto da verificare\n     */\n    IsTrue(object) {\n        if (object === null || object === undefined) return false\n        return (typeof object === 'boolean' && object === true)\n    }\n\n    /**\n     * Verifica se un oggetto è di tipo Boolean False\n     * @param {object} object Oggetto da verificare\n     */\n    IsFalse(object) {\n        if (object === null || object === undefined) return true\n        return (typeof object === 'boolean' && object === false)\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //OBJETC\n\n    /**\n     * Verifica se due oggetti sono uguali\n     * @param {object} object0 Primo oggetto del confronto\n     * @param {object} object1 Secondo oggetto del confronto\n     */\n    IsEqual(object0, object1) {\n        return (object0 === object1)\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //OBJETC\n\n    /**\n     * Verifica se un oggetto è di tipo Date\n     * @param {object} object Oggetto da verificare\n     */\n    IsDate(object) {\n        if (object === null || object === undefined) return false\n        return (typeof object === 'object' && object instanceof Date && !isNaN(object.valueOf()))\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //OBJETC\n\n    /**\n     * Verifica se un oggetto è un matrice di tipo Object o Array\n     * @param {object} object Oggetto da verificare\n     */\n    IsMatrix(object) {\n        if (object === null || object === undefined) return false\n        return (typeof object === 'object' && (object instanceof Object || Array.isArray(object)))\n    }\n\n    /**\n     * Verifica se un oggetto è un JSON Object\n     * @param {object} object Oggetto da verificare\n     */\n    IsObject(object) {\n        if (object === null || object === undefined) return false\n        return (!Array.isArray(object))\n    }\n\n    /**\n     * Verifica se un oggetto è un Object Array\n     * @param {object} object Oggetto da verificare\n     */\n    IsArray(object) {\n        if (object === null || object === undefined) return false\n        return (Array.isArray(object))\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //OBJETC\n\n    /**\n     * Restituisce il tipo di oggetto\n     * @param {object} object Oggetto da verificare\n     */\n    GetTypeOf(object) {\n        return typeof object\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //OBJETC\n\n    /**\n     * Converte un oggetto JSON Object in Array\n     * @param {object} object Oggetto da convertire\n     */\n    ObjectToArray(object) {\n        if (object === null || object === undefined) return []\n        if (this.IsObject(object)) {\n            return Object.values(object)\n        } else {\n            return []\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //OBJETC\n\n    /**\n     * Converte un oggetto Array in JSON Object\n     * @param {string[]} object Array da convertire\n     */\n    ArrayToObject(object) {\n        if (object === null || object === undefined) return {}\n        if (this.IsArray(object)) {\n            return Object.assign({}, object)\n        } else {\n            return {}\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //OBJETC\n\n    /**\n     * Restituisce un valore casuale selezionandolo da una matrice\n     * @param {{} | [] | string} object Object, Array o String separato da punto e virgola\n     */\n    GetRandomValue(object) {\n        if (object === null || object === undefined) return null\n        if (typeof object === 'string') {\n            object = object.trim()\n            if ((/;/gm).test(object)) {\n                object = object.split(';')\n            } else {\n                return object\n            }\n        } else if (typeof object === 'object') {\n            object = Object.values(object)\n        } else {\n            return null\n        }\n\n        if (!Array.isArray(object)) return null\n        let result = object[Math.floor(Math.random() * object.length)]\n        if (!result) return null\n        if (typeof result === 'string' && result.trim() == '') return null\n        return result\n    }\n\n    //OBJETC\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //JSON utility\n\n    /**\n     * Converte JSON String >> Object\n     * @param {string} json_string JSON String\n     */\n    JSO(json_string) {\n        try {\n            if (json_string === null || json_string === undefined || typeof json_string !== 'string') return json_string\n            return JSON.parse(json_string)\n        } catch (error) {\n            return json_string\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //JSON utility\n\n    /**\n     * Converte JSON Object >> String\n     * @param {object} json_object JSON Object\n     */\n    JSS(json_object) {\n        try {\n            if (json_object === null || json_object === undefined || typeof json_object !== 'object') return json_object\n            return JSON.stringify(json_object)\n        } catch (error) {\n            return json_object\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //JSON utility\n\n    /**\n     * Converte JSON Object >> String formattato\n     * @param {object} json_object JSON Object\n     * @param {number} indentation Identazione formattazione testo\n     */\n    JSSPrint(json_object, indentation = 3) {\n        try {\n            if (json_object === null || json_object === undefined || typeof json_object !== 'object') return json_object\n            return JSON.stringify(json_object, null, indentation)\n        } catch (error) {\n            return json_object\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //JSON utility\n\n    /**\n     * Ricerca le chievi in un oggetto JSON e restituisce il valore o le proprietà\n     * @param {string | string []} args args = 'key' || 'key.subkey.{what}' || 'key.*.{what}' || ['key', 'subkey', '{what}'] || ['key', '*', '{what}']\n     * @param {string | string []} args {what} = $type || $keys || $first_key || $last_key || $root || $boolean || $object || $...> (ultimo risultato)\n     * @param {NodeMessage | {} | []} object Oggetto sul quale effettuare la ricerca\n     */\n    JSGet(args, object = this.object) {\n        //creo una copia di object\n        object = RED.util.cloneMessage(object)\n\n        //definisci le chiavi\n        if (!args || (typeof args === 'string' && !args.trim())) {\n            return null\n        } else if (typeof args === 'string') {\n            //crea una array di chiavi\n            args = args.split('.')\n        } else if (!Array.isArray(args)) {\n            return null\n        }\n\n        //chiave primaria\n        var key = args[0]\n        if (!key) return null\n        if (typeof key !== 'string') return null\n        if (key == '') return null\n\n        //chiave secondaria\n        var subKey = (args.length == 2) ? args[1] : null\n        if (subKey && (subKey == '*' || subKey == '')) subKey = null\n\n        //risultato richiesto\n        var what = (args.length == 3) ? args[2] : ''\n\n        //definisci l'oggetto, deve essere un JSON\n        if (object && typeof object === 'object' && Array.isArray(object) && object.length > 0) {\n            //se è una array lo converto\n            Object.assign({}, object)\n        } else if (typeof object === 'string') {\n            //se è un JSON string lo converto\n            try {\n                object = JSON.parse(object)\n            } catch (error) {\n                return null\n            }\n        }\n\n        //se non è un JSON restituisco null\n        if (!object || (Object.keys(object).length == 0 && object.constructor === Object)) {\n            return null\n        }\n\n        //risultati della ricerca\n        var result = null\n\n        //ricerca in profondità la chiave nell'oggetto\n        var searchDeep = function SearchDeep(/** @type {{ [x: string]: any; hasOwnProperty: (arg0: string) => any; }} */ object, /** @type {string} */ rootKeys) {\n            //percorso della chiave\n            var root = function GetRootKey(/** @type {string} */ addKey) {\n                return rootKeys ? `${rootKeys}.${addKey}` : addKey\n            }\n\n            //chiave trovata\n            if (object && object.hasOwnProperty(key)) {\n                //se vuota assegna key\n                if (!rootKeys) rootKeys = key\n\n                if (subKey && object[key].hasOwnProperty(subKey)) {\n                    result = {\n                        value: object[key][subKey],\n                        type: typeof object[key][subKey],\n                        keys: rootKeys.split('.').length,\n                        first_key: rootKeys.split('.')[0],\n                        last_key: (rootKeys.split('.').length > 0) ? rootKeys.split('.')[rootKeys.split('.').length - 1] : rootKeys.split('.')[0],\n                        root: rootKeys\n                    }\n                } else if (!subKey) {\n                    result = {\n                        value: object[key],\n                        type: typeof object[key],\n                        keys: rootKeys.split('.').length,\n                        first_key: rootKeys.split('.')[0],\n                        last_key: (rootKeys.split('.').length > 0) ? rootKeys.split('.')[rootKeys.split('.').length - 1] : rootKeys.split('.')[0],\n                        root: rootKeys\n                    }\n                }\n            }\n\n            //ricerca della chiave\n            if (!result || what.endsWith('>')) {\n                for (let k in object) {\n                    if (object.hasOwnProperty(k) && typeof object[k] === 'object') {\n                        searchDeep(object[k], root(k))\n                    }\n                }\n            }\n        }\n\n        //inizia la ricerca\n        searchDeep(object)\n\n        //restituisci il risultato\n        switch (what.replace('>', '')) {\n            case \"$type\":\n                return (!result ? null : result.type)\n            case \"$keys\":\n                return (!result ? null : result.keys)\n            case \"$first_key\":\n                return (!result ? null : result.first_key)\n            case \"$last_key\":\n                return (!result ? null : result.last_key)\n            case \"$root\":\n                return (!result ? null : result.root)\n            case \"$boolean\":\n                return !!result\n            case \"$object\":\n                return (!result ? null : result)\n            default:\n                return (!result ? null : result.value)\n        }\n    }\n\n    //JSON utility\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //CONSTANTS DATE\n\n    /**\n     * Nomi dei giorni\n     */\n    DAYS = ['Domenica', 'Lunedì', 'Martedì', 'Mercoledì', 'Giovedì', 'Venerdì', 'Sabato']\n\n    /**\n     * Nomi dei giorni abbreviati\n     */\n    DAYS_SHORT = ['DOM', 'LUN', 'MAR', 'MER', 'GIO', 'VEN', 'SAB']\n\n    /**\n     * Nomi dei mesi\n     */\n    MONTHS = ['Gennaio', 'Febbraio', 'Marzo', 'Aprile', 'Maggio', 'Giugno', 'Luglio', 'Agosto', 'Settembre', 'Ottobre', 'Novembre', 'Dicembre']\n\n    /**\n     * Nomi dei mesi abbreviati\n     */\n    MONTHS_SHORT = ['GEN', 'FEB', 'MAR', 'APR', 'MAG', 'GIU', 'LUG', 'AGO', 'SET', 'OTT', 'NOV', 'DIC']\n\n    //CONSTANTS DATE\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Restituisce Unix in millisecondi\n     * @param {string | number | Date} date Data di riferimento, se Null restituisce la data Unix attuale\n     * @param {boolean} seconds Unix in secondi, default false\n     */\n    GetUnix(date = null, seconds = false) {\n        if (!date) return Date.now()\n        if (typeof date === 'string' && !isNaN(date)) date = parseInt(date)\n        if (typeof date === 'number') {\n            if (date.toString().length < 13 && !seconds) date *= 1000\n            date = Math.round(date)\n        }\n        return (seconds) ? new Date(date).valueOf() / 1000 : new Date(date).valueOf()\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Verifica se il numero Unix è espresso in secondi\n     * @param {number | string} unix Numero formato Unix\n     */\n    UnixIsSeconds(unix = null) {\n        if (!unix) return false\n        if (typeof unix === 'string') unix = parseInt(unix)\n        return (unix.toString().length < 13)\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Verifica se il numero Unix è espresso in millisecondi\n     * @param {number | string} unix Numero formato Unix\n     */\n    UnixIsMilliseconds(unix = null) {\n        if (!unix) return false\n        if (typeof unix === 'string') unix = parseInt(unix)\n        return (unix.toString().length >= 13)\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Restituisce la data e ora UTC\n     * @param {number | string} unix Numero formato Unix, se Null restituisce la data attuale\n     */\n    UnixToUTC(unix = null) {\n        unix = this.GetUnix(unix)\n        return new Date(unix)\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Restituisce l'offset in minuti tra la data UTC e locale\n     * @param {string | number | Date} date Data di riferimento, se Null restituisce la data attuale\n     */\n    GetTimeZone(date = null) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n\n        let offset = date.getTimezoneOffset()\n\n        if (offset <= 0) {\n            offset = Math.abs(offset)\n            offset = (offset / 60)\n            offset = Math.floor(offset)\n        } else {\n            offset = (offset / 60)\n            offset = Math.floor(offset)\n        }\n\n        return offset\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Restituisce la data e ora (UTC)\n     * @param {string | number | Date} date Data UTC di riferimento, se Null restituisce la data attuale\n     */\n    GetDateISO(date = null) {\n        date = this.GetUnix(date)\n        return (new Date(date)).toISOString()\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Restituisce la data e ora (Local Time)\n     * @param {string | number | Date} date Data UTC di riferimento, se Null restituisce la data attuale\n     * @param {boolean} en Formato inglese YYYY-MM-DD H:M:S\n     */\n    GetLocalDateTime(date = null, en = false) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n\n        let h = (new Intl.DateTimeFormat('it-IT', { timeStyle: 'long' }).format(date)).substr(0, 8).trim()\n        let y = date.getFullYear()\n        let m = (date.getMonth() + 1).toString()\n        let d = (date.getDate()).toString()\n        m = (m.length == 1) ? '0' + m : m\n        d = (d.length == 1) ? '0' + d : d\n\n        return (en) ? y + '-' + m + '-' + d + ' ' + h : d + '/' + m + '/' + y + ' ' + h\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Restituisce la data (Local Time)\n     * @param {string | number | Date} date Data UTC di riferimento, se Null restituisce la data attuale\n     * @param {boolean} en Formato inglese YYYY-MM-DD\n     */\n    GetLocalDate(date = null, en = false) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n\n        let y = date.getFullYear()\n        let m = (date.getMonth() + 1).toString()\n        let d = (date.getDate()).toString()\n        m = (m.length == 1) ? '0' + m : m\n        d = (d.length == 1) ? '0' + d : d\n\n        return (en) ? y + '-' + m + '-' + d : d + '/' + m + '/' + y\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Restituisce l'orario (Local Time)\n     * @param {string | number | Date} date Data UTC di riferimento, se Null restituisce la data attuale\n     */\n    GetLocalTime(date = null) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n        return (new Intl.DateTimeFormat('it-IT', { timeStyle: 'long' }).format(date)).substr(0, 8).trim()\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Restituisce l'ora da 0 a 23 (Local Time)\n     * @param {string | number | Date} date Data del confronto, se Null restituisce la data attuale\n     */\n    GetHours(date = null) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n        return date.getHours()\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Restituisce i minuti da 0 a 59 (Local Time)\n     * @param {string | number | Date} date Data del confronto, se Null restituisce la data attuale\n     */\n    GetMinutes(date = null) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n        return date.getMinutes()\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Restituisce i secondi da 0 a 59 (Local Time)\n     * @param {string | number | Date} date Data del confronto, se Null restituisce la data attuale\n     */\n    GetSeconds(date = null) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n        return date.getSeconds()\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Converte i minuti in orario nel formato 00:00\n    * @param {number} minutes Minuti da convertire\n     */\n    ConvMinutesToTime(minutes = 0) {\n        if (minutes === 0) { return `00:00` }\n        const h = Math.floor(minutes / 60)\n        const m = minutes % 60\n        return `${(h < 10) ? '0' : ''}${h}:${(m < 10) ? '0' : ''}${m}`\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Converte i minuti in testo letterale\n    * @param {number} minutes Minuti da convertire\n    * @param {boolean} short Testo abbreviato\n     */\n    ConvMinutesToText(minutes = 0, short = false) {\n        if (minutes === 0) { return short ? `0 m` : `0 minuti` }\n        const h = Math.floor(minutes / 60)\n        const m = minutes % 60\n\n        if (h === 0) {\n            return short ? `${m} m` : `${m} minut${(m > 1) ? 'i' : 'o'}`\n        } else {\n            if (m === 0) {\n                return short ? `${h} h` : `${h} ore`\n            } else {\n                return short ? `${h} h e ${m} m` : `${h} or${(h > 1) ? 'e' : 'a'} e ${m} minut${(m > 1) ? 'i' : 'o'}`\n            }\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Arrotondamento dei minuti per difetto o eccesso, default difetto\n     * @param {number} minutes Minuti da arrotondare\n     * @param {number} rounding Minuti di arrotondamento, default 15 minuti\n     * @param {boolean} defect Arrotondamento per difetto, default difetto\n     */\n    MinutesRounding(minutes = 0, rounding = 15, defect = true) {\n        if (minutes == 0 || rounding == 0) { return minutes }\n        if (defect) {\n            return Math.abs(minutes - (minutes % rounding))\n        } else {\n            return ((minutes % rounding) === 0) ? minutes : Math.abs(minutes - (minutes % rounding)) + rounding\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Restituisce la data di ieri (Local Time)\n     */\n    GetYesterday() {\n        var date = new Date()\n        date = this.AddDays(date, -1)\n        return this.GetLocalDate(date)\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Restituisce la data di domani (Local Time)\n     */\n    GetTomorrow() {\n        var date = new Date()\n        date = this.AddDays(date, 1)\n        return this.GetLocalDate(date)\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Restituisce il nome del giorno della settimana (Local Time)\n     * @param {string | number | Date} date Data UTC di riferimento, se Null restituisce la data attuale\n     * @param {string[]} day Array dei nomi\n     */\n    GetDayName(date = null, day = this.DAYS) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n        if (!day) day = this.DAYS\n        return day[date.getDay()]\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Restituisce il numero del giorno della settimana (Local Time)\n     * @param {string | number | Date} date Data UTC di riferimento, se Null restituisce la data attuale\n     */\n    GetDayOfWeek(date = null) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n        return date.getDay()\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Restituisce il numero del giorno del mese (Local Time)\n     * @param {string | number | Date} date Data UTC di riferimento, se Null restituisce la data attuale\n     */\n    GetDayOfMonth(date = null) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n        return date.getDate()\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Restituisce il numero dell'ultimo giorno del mese (Local Time)\n     * @param {string | number | Date} date Data UTC di riferimento, se Null restituisce la data attuale\n     */\n    GetLastDayOfMonth(date = null) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n        return new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate()\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Restituisce il nome del mese (Local Time)\n     * @param {string | number | Date} date Data UTC di riferimento, se Null restituisce la data attuale\n     * @param {string[]} month Array dei nomi\n     */\n    GetMonthName(date = null, month = this.MONTHS) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n        if (!month) month = this.MONTHS\n        return month[date.getMonth()]\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Restituisce il numero del mese (Local Time)\n     * @param {string | number | Date} date Data UTC di riferimento, se Null restituisce la data attuale\n     */\n    GetMonth(date = null) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n        return date.getMonth() + 1\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Restituisce il numero dell'anno (Local Time)\n     * @param {string | number | Date} date Data UTC di riferimento, se Null restituisce la data attuale\n     */\n    GetYear(date = null) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n        return date.getFullYear()\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Restituisce un Object con tutti i risultati (Local Time)\n     * @param {string | number | Date} date_from Data UTC inizio\n     * @param {string | number | Date} date_to Data UTC fine, se Null restituisce la data attuale\n     */\n    GetTimeElapsed(date_from, date_to = null) {\n        date_from = this.GetUnix(date_from)\n        date_from = new Date(date_from)\n        date_to = this.GetUnix(date_to)\n        date_to = new Date(date_to)\n\n        var mls = Math.abs((date_from.getTime() - date_to.getTime()))\n        mls = Math.round(mls)\n\n        var milliseconds = mls / 1000\n        var years = Math.floor(milliseconds / 31536000)\n        var days = Math.floor((milliseconds % 31536000) / 86400)\n        var hours = Math.floor(((milliseconds % 31536000) % 86400) / 3600)\n        var minutes = Math.floor((((milliseconds % 31536000) % 86400) % 3600) / 60)\n        var seconds = Math.floor((((milliseconds % 31536000) % 86400) % 3600) % 60)\n\n        var levels = [\n            [years, ((years > 1) ? 'anni' : 'anno')],\n            [days, ((days > 1) ? 'giorni' : 'giorno')],\n            [hours, ((hours > 1) ? 'ore' : 'ora')],\n            [minutes, ((minutes > 1) ? 'minuti' : 'minuto')],\n            [seconds, ((seconds > 1) ? 'secondi' : 'secondo')],\n        ]\n\n        var description = ''\n\n        for (var i = 0, max = levels.length; i < max; i++) {\n            if (levels[i][0] === 0) continue\n            description += ' ' + levels[i][0] + ' ' + levels[i][1]\n        }\n\n        description = description.trim()\n        description = (description == '') ? '1 secondo' : description\n\n        return {\n            start: date_from,\n            end: date_to,\n            description: description,\n            years: years,\n            days: Math.floor(mls / (1000 * 60 * 60 * 24)),\n            hours: Math.floor(mls / (1000 * 60 * 60)),\n            minutes: Math.floor(mls / (1000 * 60)),\n            seconds: Math.floor(mls / 1000),\n            milliseconds: mls\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Aggiunge o rimuove giorni alla data (Local Time)\n     * @param {string | number | Date} date Data UTC di riferimento, se Null restituisce la data attuale\n     * @param {number} days Numero di giorni da aggiungere o rimuovere\n     */\n    AddDays(date = null, days = 0) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n        if (!days) days = 0\n        date.setDate(date.getDate() + days)\n        return date\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Verifica se la data è valida nel formato dd/mm/yyyy oppure dd-mm-yyyy\n     * @param {string} text Data da verificare nel formato dd/mm/yyyy oppure dd-mm-yyyy\n     */\n    IsValidDateInput(text) {\n        try {\n            text = text.replace(/ /gm, '')\n\n            if (text.match(/^(0?[1-9]|[12][0-9]|3[01])[\\/\\-](0?[1-9]|1[012])[\\/\\-]\\d{4}$/)) {\n                var opera1 = text.split('/')\n                var opera2 = text.split('-')\n                var lopera1 = opera1.length\n                var lopera2 = opera2.length\n                var pdate\n\n                if (lopera1 > 1) {\n                    pdate = text.split('/')\n                } else if (lopera2 > 1) {\n                    pdate = text.split('-')\n                }\n\n                var dd = parseInt(pdate[0])\n                var mm = parseInt(pdate[1])\n                var yy = parseInt(pdate[2])\n                var ListofDays = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n                if (mm == 1 || mm > 2) {\n                    if (dd > ListofDays[mm - 1]) { return false }\n                }\n\n                if (mm == 2) {\n                    var lyear = false\n                    if ((!(yy % 4) && yy % 100) || !(yy % 400)) { lyear = true }\n                    if ((lyear == false) && (dd >= 29)) { return false }\n                    if ((lyear == true) && (dd > 29)) { return false }\n                }\n            } else {\n                return false\n            }\n        } catch (error) {\n            return false\n        }\n\n        return true\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Stabilisce se la data indicata è quella attuale (Local Time)\n     * @param {string | number | Date} date Data di riferimento, se Null restituisce falso\n     */\n    IsToday(date = null) {\n        if (date === null || date === undefined) { return false }\n        date = this.GetUnix(date)\n        date = new Date(date)\n        return (this.GetLocalDate(date) == this.GetLocalDate())\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Stabilisce se la data indicata è quella di ieri (Local Time)\n     * @param {string | number | Date} date Data di riferimento, se Null restituisce falso\n     */\n    IsYesterday(date = null) {\n        if (date === null || date === undefined) { return false }\n        date = this.GetUnix(date)\n        date = new Date(date)\n        var yesterday = this.AddDays(new Date(), -1)\n        return (this.GetLocalDate(date) == this.GetLocalDate(yesterday))\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Stabilisce se la data indicata è quella di domani (Local Time)\n     * @param {string | number | Date} date Data di riferimento, se Null restituisce falso\n     */\n    IsTomorrow(date = null) {\n        if (date === null || date === undefined) { return false }\n        date = this.GetUnix(date)\n        date = new Date(date)\n        var tomorrow = this.AddDays(new Date(), 1)\n        return (this.GetLocalDate(date) == this.GetLocalDate(tomorrow))\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Confronta due date (Local Time)\n     * @param {string | number | Date} date1 Prima data del confronto, se Null restituisce la data attuale\n     * @param {string | number | Date} date2 Seconda data del confronto, se Null restituisce la data attuale\n     */\n    IsThisDay(date1 = null, date2 = null) {\n        date1 = this.GetUnix(date1)\n        date1 = new Date(date1)\n        date2 = this.GetUnix(date2)\n        date2 = new Date(date2)\n        return (this.GetLocalDate(date1) == this.GetLocalDate(date2))\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Stabilisce se la data indicata è quella attuale (Local Time)\n     * @param {string | number | Date} date Data da valutare, se Null restituisce falso\n     */\n    IsBirthday(date = null) {\n        if (date === null || date === undefined) { return false }\n        date = this.GetUnix(date)\n        date = new Date(date)\n        let today = new Date()\n        return (date.getMonth() == today.getMonth() && date.getDate() == today.getDate())\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Verifica se la data rientra in un intervallo tra due date\n     * @param {string | number | Date} date Data del confronto, se Null restituisce la data attuale\n     * @param {string | number | Date} date1 Data inizio range, se Null restituisce la data attuale\n     * @param {string | number | Date} date2 Data fine range, se Null restituisce la data attuale\n     */\n    IsBetweenDate(date = null, date1 = null, date2 = null) {\n        date = this.GetUnix(date)\n        date = new Date(date).valueOf()\n        date1 = this.GetUnix(date1)\n        date1 = new Date(date1).valueOf()\n        date2 = this.GetUnix(date2)\n        date2 = new Date(date2).valueOf()\n        return (date > date1 && date < date2)\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Verifica se la data rientra in un intervallo orario (Local Time)\n     * @param {string | number | Date} date Data del confronto, se Null restituisce la data attuale\n     * @param {number} hour1 Ora inizio intervallo\n     * @param {number} hour2 Ora fine intervallo\n     */\n    IsBetweenTime(date = null, hour1 = 0, hour2 = 23) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n        let hour = date.getHours()\n        return (hour >= hour1 && hour <= hour2)\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Verifica se una data è superiore ad un altra data\n     * @param {string | number | Date} date1 Prima data del confronto, se Null restituisce la data attuale\n     * @param {string | number | Date} date2 Seconda data del confronto, se Null restituisce la data attuale\n     */\n    IsAfterDate(date1 = null, date2 = null) {\n        date1 = this.GetUnix(date1)\n        date1 = new Date(date1).valueOf()\n        date2 = this.GetUnix(date2)\n        date2 = new Date(date2).valueOf()\n        return (date1 > date2)\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Verifica se una data è inferiore ad un altra data\n     * @param {string | number | Date} date1 Prima data del confronto, se Null restituisce la data attuale\n     * @param {string | number | Date} date2 Seconda data del confronto, se Null restituisce la data attuale\n     */\n    IsBeforeDate(date1 = null, date2 = null) {\n        date1 = this.GetUnix(date1)\n        date1 = new Date(date1).valueOf()\n        date2 = this.GetUnix(date2)\n        date2 = new Date(date2).valueOf()\n        return (date1 < date2)\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Verifica se una data è uguale ad un altra data\n     * @param {string | number | Date} date1 Prima data del confronto, se Null restituisce la data attuale\n     * @param {string | number | Date} date2 Seconda data del confronto, se Null restituisce la data attuale\n     */\n    IsSameDate(date1 = null, date2 = null) {\n        date1 = this.GetUnix(date1)\n        date1 = new Date(date1).valueOf()\n        date2 = this.GetUnix(date2)\n        date2 = new Date(date2).valueOf()\n        return (date1 == date2)\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Verifica se l'ora è superiore ad un numero che va da 0 a 23 (Local Time)\n     * @param {string | number | Date} date Data del confronto, se Null restituisce la data attuale\n     * @param {number} hour Ora del confronto\n     */\n    IsAfterTime(date = null, hour = 0) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n        let hour_date = date.getHours()\n        return (hour_date > hour)\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Verifica se l'ora è uguale ad un numero che va da 0 a 23 (Local Time)\n     * @param {string | number | Date} date Data del confronto, se Null restituisce la data attuale\n     * @param {number} hour Ora del confronto\n     */\n    IsSameTime(date = null, hour = 0) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n        let hour_date = date.getHours()\n        return (hour_date == hour)\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Verifica se l'ora è uguale o superiore ad un numero che va da 0 a 23 (Local Time)\n     * @param {string | number | Date} date Data del confronto, se Null restituisce la data attuale\n     * @param {number} hour Ora del confronto\n     */\n    IsSameOrAfterTime(date = null, hour = 0) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n        let hour_date = date.getHours()\n        return (hour_date >= hour)\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Verifica se l'ora è inferiore ad un numero che va da 0 a 23 (Local Time)\n     * @param {string | number | Date} date Data del confronto, se Null restituisce la data attuale\n     * @param {number} hour Ora del confronto\n     */\n    IsBeforeTime(date = null, hour = 0) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n        let hour_date = date.getHours()\n        return (hour_date < hour)\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Verifica se l'ora è uguale o inferiore ad un numero che va da 0 a 23 (Local Time)\n     * @param {string | number | Date} date Data del confronto, se Null restituisce la data attuale\n     * @param {number} hour Ora del confronto\n     */\n    IsSameOrBeforeTime(date = null, hour = 0) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n        let hour_date = date.getHours()\n        return (hour_date <= hour)\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Stabilisce se una data è \"after\" o \"before\" rispetto ad un'altra data\n     * @param {string | number | Date} date1 Prima data del confronto, se Null restituisce la data attuale\n     * @param {string | number | Date} date2 Seconda data del confronto, se Null restituisce la data attuale\n     */\n    IsAfterOrBeforeDate(date1 = null, date2 = null) {\n        date1 = this.GetUnix(date1)\n        date1 = new Date(date1).valueOf()\n        date2 = this.GetUnix(date2)\n        date2 = new Date(date2).valueOf()\n        return (date1 < date2) ? 'before' : 'after'\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE\n\n    /**\n     * Stabilisce se l'ora legale è in vigore\n     * @param {string | number | Date} date Data di riferimento, se Null restituisce la data attuale\n     */\n    IsDST(date = null) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n\n        const january = new Date(date.getFullYear(), 0, 1).getTimezoneOffset()\n        const july = new Date(date.getFullYear(), 6, 1).getTimezoneOffset()\n\n        return (Math.max(january, july) !== date.getTimezoneOffset())\n    }\n\n    //DATE\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    // DATE - HOLIDAY AND WORKDAY\n\n    /**\n     * Restituisce la data UTC del giorno di Pasqua in base all'anno\n     * @param {string | number | Date} date Data UTC di riferimento, se Null restituisce la data attuale\n     */\n    Easter(date = null) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n\n        let a, b, c, d, e, M, N\n        let Y = new Date(date).getFullYear()\n        let day, month\n        let year = new Date(date).getFullYear()\n\n        if (Y < 2099) {\n            M = 24\n            N = 5\n        } else if (Y < 2199) {\n            M = 24\n            N = 6\n        } else if (Y < 2299) {\n            M = 25\n            N = 0\n        } else if (Y < 2399) {\n            M = 26\n            N = 1\n        } else if (Y < 2499) {\n            M = 25\n            N = 1\n        }\n\n        a = Y % 19\n        b = Y % 4\n        c = Y % 7\n        d = ((19 * a) + M) % 30\n        e = ((2 * b) + (4 * c) + (6 * d) + N) % 7\n\n        if (d + e < 10) {\n            day = d + e + 22\n            month = 3\n        } else {\n            day = d + e - 9\n            month = 4\n        }\n\n        if (day == 26 && month == 4) {\n            day = 19\n            month = 4\n        }\n\n        if (day == 25 && month == 4 && d == 28 && e == 6 && a > 10) {\n            day = 18\n            month = 4\n        }\n\n        day = (day < 10) ? `0${day}` : `${day}`\n        month = (month < 10) ? `0${month}` : `${month}`\n        return (new Date(`${year}-${month}-${day}T00:00:00.000Z`))\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    // DATE - HOLIDAY AND WORKDAY\n\n    /**\n     * Restituisce la data UTC del giorno di Lunedì dell'Angelo in base all'anno\n     * @param {string | number | Date} date Data UTC di riferimento, se Null restituisce la data attuale\n     */\n    EasterMonday(date = null) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n        let easter = this.Easter(date)\n        return this.AddDays(new Date(easter), 1)\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    // DATE - HOLIDAY AND WORKDAY\n\n    /**\n     * Restituisce il nome della festa nazionale, patronale o domenica (Local Time)\n     * @param {string | number | Date} date Data UTC di riferimento, se Null restituisce la data attuale\n     */\n    GetHoliday(date = null) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n\n        //Pasqua\n        if (this.IsEaster(date)) return \"Pasqua\"\n        //Lunedì dell'Angelo\n        if (this.IsEasterMonday(date)) return \"Lunedì dell'Angelo\"\n        //giorno del mese\n        const day = date.getDate()\n        //0 Gennaio - 11 Dicembre\n        const month = (date.getMonth() + 1)\n        //festa patronale\n        if (day == 29 && month == 8) return \"San Giovanni Battista\"\n        //feste nazionali\n        if (day == 1 && month == 1) {\n            //Capodanno\n            return \"Capodanno\"\n        } else if (day == 6 && month == 1) {\n            //Epifania\n            return \"Epifania\"\n        } else if (day == 25 && month == 4) {\n            //Festa della Liberazione\n            return \"Festa della Liberazione\"\n        } else if (day == 1 && month == 5) {\n            //Festa del Lavoro\n            return \"Festa del Lavoro\"\n        } else if (day == 2 && month == 6) {\n            //Festa della Repubblica\n            return \"Festa della Repubblica\"\n        } else if (day == 15 && month == 8) {\n            //Assunzione di Maria\n            return \"Assunzione di Maria\"\n        } else if (day == 1 && month == 11) {\n            //Ognissanti\n            return \"Ognissanti\"\n        } else if (day == 8 && month == 12) {\n            //Immacolata Concezione\n            return \"Immacolata Concezione\"\n        } else if (day == 25 && month == 12) {\n            //Natale del Signore\n            return \"Natale del Signore\"\n        } else if (day == 26 && month == 12) {\n            //Santo Stefano\n            return \"Santo Stefano\"\n        } else if (date.getDay() == 0) {\n            //Domenica\n            return \"Domenica\"\n        }\n\n        return null\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    // DATE - HOLIDAY AND WORKDAY\n\n    /**\n     * Restituisce la prossima festa nazionale o patronale, no domenica (Local Time)\n     * @param {string | number | Date} date Data UTC di riferimento, se Null restituisce la data attuale\n     */\n    GetNextHoliday(date = null) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n\n        for (let day = 1; day < 365; day++) {\n            const today = this.AddDays(date, day)\n\n            if (this.IsHoliday(today)) {\n                const holiday = this.GetHoliday(today)\n                if (holiday != 'Domenica') {\n                    return {\n                        date: today,\n                        holiday: holiday,\n                        estimated_days: this.GetTimeElapsed(date, today).days,\n                        estimated_desc: this.GetTimeElapsed(date, today).description\n                    }\n                }\n            }\n        }\n\n        return {\n            date: null,\n            holiday: null,\n            estimated_days: null,\n            estimated_desc: null\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    // DATE - HOLIDAY AND WORKDAY\n\n    /**\n     * Verifica se la data indicata è il giorno di Pasqua (Local Time)\n     * @param {string | number | Date} date Data UTC di riferimento, se Null restituisce la data attuale\n     */\n    IsEaster(date = null) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n        let easter = this.Easter(date)\n        return (new Intl.DateTimeFormat('it-IT').format(easter) == new Intl.DateTimeFormat('it-IT').format(date))\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    // DATE - HOLIDAY AND WORKDAY\n\n    /**\n     * Verifica se la data indicata è il giorno di Lunedì dell'Angelo (Local Time)\n     * @param {string | number | Date} date Data UTC di riferimento, se Null restituisce la data attuale\n     */\n    IsEasterMonday(date = null) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n        let easter = this.EasterMonday(date)\n        return (new Intl.DateTimeFormat('it-IT').format(easter) == new Intl.DateTimeFormat('it-IT').format(date))\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    // DATE - HOLIDAY AND WORKDAY\n\n    /**\n     * Verifica se la data indicata è un giorno lavorativo (Local Time)\n     * @param {string | number | Date} date Data UTC di riferimento, se Null restituisce la data attuale\n     */\n    IsWorkday(date = null) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n        if (this.IsHoliday(date)) return false\n        //escludi sabato e domenica\n        let day = date.getDay()\n        //0 Domenica - 6 Sabato\n        return (day > 0 && day < 6)\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    // DATE - HOLIDAY AND WORKDAY\n\n    /**\n     * Verifica se la data indicata è una festa nazionale, patronale oppure domenica (Local Time)\n     * @param {string | number | Date} date Data UTC di riferimento, se Null restituisce la data attuale\n     */\n    IsHoliday(date = null) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n\n        //Pasqua\n        if (this.IsEaster(date)) return true\n        //Lunedì dell'Angelo\n        if (this.IsEasterMonday(date)) return true\n        //giorno del mese\n        const day = date.getDate()\n        //0 Gennaio - 11 Dicembre\n        const month = (date.getMonth() + 1)\n        //festa patronale\n        if (day == 29 && month == 8) return true\n        //feste nazionali\n        if (day == 1 && month == 1) {\n            //Capodanno\n            return true\n        } else if (day == 6 && month == 1) {\n            //Epifania\n            return true\n        } else if (day == 25 && month == 4) {\n            //Festa della Liberazione\n            return true\n        } else if (day == 1 && month == 5) {\n            //Festa del Lavoro\n            return true\n        } else if (day == 2 && month == 6) {\n            //Festa della Repubblica\n            return true\n        } else if (day == 15 && month == 8) {\n            //Assunzione di Maria\n            return true\n        } else if (day == 1 && month == 11) {\n            //Ognissanti\n            return true\n        } else if (day == 8 && month == 12) {\n            //Immacolata Concezione\n            return true\n        } else if (day == 25 && month == 12) {\n            //Natale del Signore\n            return true\n        } else if (day == 26 && month == 12) {\n            //Santo Stefano\n            return true\n        } else if (date.getDay() == 0) {\n            //Domenica\n            return true\n        }\n\n        return false\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    // DATE - HOLIDAY AND WORKDAY\n\n    /**\n     * Verifica se la data indicata è prefestivo, sabato (Local Time)\n     * @param {string | number | Date} date Data UTC di riferimento, se Null restituisce la data attuale\n     */\n    IsPreHoliday(date = null) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n        if (this.IsHoliday(date)) return false\n        //0 Domenica - 6 Sabato\n        return (date.getDay() == 6)\n    }\n\n    // DATE - HOLIDAY AND WORKDAY\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE - PART OF DAY\n\n    /**\n     * Restituisce il saluto per le conversazioni (Local Time)\n     * @param {string | number | Date} date Data UTC di riferimento, se Null restituisce la data attuale\n     * @param {boolean} greeting_end Saluto di fine conversazione\n     */\n    GetGreeting(date = null, greeting_end = false) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n        let hour = date.getHours()\n\n        if (hour >= 0 && hour <= 5) {\n            return greeting_end ? 'Buona notte' : 'Ciao'\n        } else if (hour >= 6 && hour <= 12) {\n            return greeting_end ? 'Buona giornata' : 'Buongiorno'\n        } else if (hour >= 13 && hour <= 18) {\n            return \"Buon pomeriggio\"\n        } else if (hour >= 19 && hour <= 21) {\n            return greeting_end ? 'Buona serata' : 'Buonasera'\n        } else if (hour >= 22 && hour <= 23) {\n            return greeting_end ? 'Buona notte' : 'Buonasera'\n        } else {\n            return greeting_end ? 'Arrivederci' : 'Ciao'\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //DATE - PART OF DAY\n\n    /**\n     * Restituisce la parte del giorno (Local Time)\n     * @param {string | number | Date} date Data UTC di riferimento, se Null restituisce la data attuale\n     */\n    GetPartOfDay(date = null) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n\n        let hour = date.getHours()\n\n        if (hour == 0) {\n            return \"Mezzanotte\"\n        } else if (hour >= 1 && hour <= 5) {\n            return \"Notte\"\n        } else if (hour >= 6 && hour <= 11) {\n            return \"Mattina\"\n        } else if (hour == 12) {\n            return \"Mezzogiorno\"\n        } else if (hour >= 13 && hour <= 17) {\n            return \"Pomeriggio\"\n        } else if (hour >= 18 && hour <= 23) {\n            return \"Sera\"\n        } else {\n            return \"Sconosciuto\"\n        }\n    }\n\n    //DATE - PART OF DAY\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //GEO FUNCTIONS\n\n    /**\n     * Calcola la distanza tra due punti in base alle coordinate\n     * @param {Array} point1 Coordinate punto 1 ['lat', 'lon']\n     * @param {Array} point2 Coordinate punto 2 ['lat', 'lon']\n     * @param {number} plus Percentuale incremento della distanza tra i due punti, default 39% in più\n     */\n    GetDistance(point1 = [0, 0], point2 = [0, 0], plus = 39) {\n        if (!Array.isArray(point1) || !Array.isArray(point2)) {\n            return {\n                distance: 0,\n                meters: 0,\n                kilometers: 0,\n                minutes: 0,\n                speed: 0\n            }\n        }\n\n        var deltaLat = (point2[0] - point1[0]) * Math.PI / 180\n        var deltaLon = (point2[1] - point1[1]) * Math.PI / 180\n\n        point1[0] = point1[0] * Math.PI / 180\n        point2[0] = point2[0] * Math.PI / 180\n\n        var a = Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) + Math.cos(point1[0]) * Math.cos(point2[0]) * Math.sin(deltaLon / 2) * Math.sin(deltaLon / 2)\n        var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))\n        var ds = Math.round(c * 6371000)\n        var mt = Math.round(ds + (ds / 100 * plus))\n        var km = Math.round((ds + (ds / 100 * plus)) / 1000)\n        var speed = 1.25\n\n        if (km <= 20) {\n            speed = 0.7\n        } else if (km > 20 && km <= 40) {\n            speed = 0.8\n        } else if (km > 40 && km <= 60) {\n            speed = 0.9\n        } else if (km > 60 && km <= 80) {\n            speed = 1.0\n        }\n\n        var min = Math.round(km / speed)\n\n        if (min < 5) {\n            min = 0\n            speed = 0\n        } else {\n            min = ((min % 15) === 0) ? min : Math.abs(min - (min % 15)) + 15\n            speed = Math.floor((mt * 3600 / (min * 60)) / 1000) || 0\n            speed = Math.abs(speed)\n        }\n\n        return {\n            distance: ds,\n            meters: mt,\n            kilometers: km,\n            minutes: min,\n            speed: (speed < 0 || speed > 10000 || speed === NaN || speed === Infinity || isNaN(speed)) ? 0 : speed\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //GEO FUNCTIONS\n\n    /**\n     * Restituisce la velocità media di percorrenza\n     * @param {number} minutes Minuti di viaggio impiegati\n     * @param {number} meters Metri percorsi\n     */\n    GetAverageSpeed(minutes, meters) {\n        if (minutes < 1 || meters < 1) { return 0 }\n        let speed = Math.floor((meters * 3600 / (minutes * 60)) / 1000)\n        speed = Math.abs(speed)\n        return (speed < 0 || speed > 10000 || speed === NaN || speed === Infinity || isNaN(speed)) ? 0 : speed\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //GEO FUNCTIONS\n\n    /**\n     * Restituisce il link di Google Maps con il segnaposto\n     * @param {string} geocode Coordinate GPS nel formato latitudine,longitudine\n     * @param {boolean} encode Codifica URI\n     */\n    GetGoogleMapsPlaceholder(geocode = null, encode = true) {\n        //https://developers.google.com/maps/documentation/urls/get-started\n        if (geocode === null || geocode === undefined) {\n            if (encode) {\n                encodeURIComponent('https://www.google.com/maps')\n            } else {\n                return 'https://www.google.com/maps'\n            }\n        } else {\n            if (encode) {\n                return encodeURIComponent(`https://www.google.com/maps/search/?api=1&query=${geocode}`)\n            } else {\n                return `https://www.google.com/maps/search/?api=1&query=${geocode}`\n            }\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //ASTRO FUNCTIONS\n\n    /**\n     * Restituisce le informazioni sulla fase lunare (Local Time)\n     * @param {string | number | Date} date Data UTC di riferimento, se Null restituisce la data attuale\n    */\n    MoonPhase(date = null) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n\n        let year = date.getFullYear()\n        let month = date.getMonth() + 1\n        let day = date.getDate()\n\n        var icon = [\n            '🌑',\n            '🌒',\n            '🌓',\n            '🌔',\n            '🌕',\n            '🌖',\n            '🌗',\n            '🌘'\n        ]\n\n        var name = [\n            'Nuova',\n            'Crescente',\n            'Primo quarto',\n            'Gibbosa crescente',\n            'Piena',\n            'Gibbosa calante',\n            'Ultimo quarto',\n            'Calante'\n        ]\n\n        var description = [\n            'La Luna ed il Sole sono congiunti e nello stesso segno. Un ottimo periodo per nuove opportunità e nuovi inizi. Si incomincia! La nascita. Rappresenta l’inizio, il seme germoglia sottoterra. Questo è il momento di sperimentare, anche se non sai se il progetto avrà buon fine. Tendi ad essere soggettivo ed egocentrico.Le regole degli altri non fanno per te.',\n            'Metà strada tra Luna nuova e Primo quarto. Ottimo per le nuove idee e nuove energie, per coltivare le attività prescelte. Devi fare i conti con l’ambiente circostante, che può sembrare difficile e ostile. Ma vai avanti incontro al nuovo, supera le resistenze.',\n            'La Luna è a 90° dal Sole. La creazione. È il momento di accettare la responsabilità di quanto abbiamo avviato. Metti le foglie e rami, un periodo di grande crescita. Esercita il massimo sforzo per raggiungere i tuoi obiettivi.',\n            'A metà strada tra il primo quarto e luna piena. Ottimo per pianificare, individuare strategie e ridefinire i concetti. Il germoglio comincia a formarsi, portando in sé la promessa del fiore. Avanti con il nuovo, senti che deve essere perfezionato per raggiungere il suo vero potenziale.',\n            'La Luna e Sole sono in opposizione, su lati opposti della Terra. Periodo di padronanza e completamento.Viva i risultati! È ora di cominciare a chiudere e tirare le somme. Il fiore emerge. Sei consapevole degli effetti del tuo lavoro sugli altri.quindi la parola d’ordine è: obiettività. Sei aperto all’influenza di coloro che ti circondano, e consapevole dell’influenza che puoi avere su di loro.',\n            'A metà strada tra la Luna Piena e l’ultimo quarto. Valuta e riconosci i risultati.Osserva, rivedi, ottimizza e scarta quello che non funziona. Inizia a consolidare. Compare il frutto della pianta. Sai cosa hai realizzato, condividilo con gli altri.',\n            'La Luna è calante e a 90° dal Sole. Periodo di riflessione e ristrutturazione.Viva l’introspezione. È il raccolto, le parti restanti appassiscono e muoiono. Abbatti la vecchia struttura e prepara la via al nuovo. È il tempo per le “crisi di coscienza” e far nascere un nuovo desiderio di cambiare.',\n            'A metà strada tra l’Ultimo Quarto e la Luna Nuova. Butta via quello che non serve più.Consolida e chiudi. È il momento della maturazione del seme. Tutta l’energia si concentra nel diventare seme per il ciclo successivo. La realtà diventa lontana, e sei un po’ alienato dalla struttura della società. Contribuisci a preparare la strada per qualcosa di nuovo, scrollarti di dosso i resti del passato.'\n        ]\n\n        var c = 0\n        var e = 0\n        var jd = 0\n        var b = 0\n\n        if (month < 3) {\n            year--\n            month += 12\n        }\n\n        ++month\n        c = 365.25 * year\n        e = 30.6 * month\n        jd = c + e + day - 694039.09\n        jd /= 29.5305882\n        b = parseInt(jd)\n        jd -= b\n        b = Math.round(jd * 8)\n        if (b >= 8) { b = 0 }\n\n        return {\n            phase: b + 1,\n            icon: icon[b],\n            name: name[b],\n            description: description[b]\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //ASTRO FUNCTIONS\n\n    /**\n     * Restituisce il segno zodiacale (Local Time)\n     * @param {string | number | Date} date Data UTC di riferimento, se Null restituisce la data attuale\n    */\n    ZodiacSign(date = null) {\n        date = this.GetUnix(date)\n        date = new Date(date)\n        var month = date.getMonth() + 1\n        var day = date.getDate()\n\n        if (month == 1 && day <= 19) { return { icon: \"♑️\", sign: \"Capricorno\", element: \"Terra\", season: \"Inverno\", type: \"Cardinale\", description: \"Segno di iniziativa e creatività\" } }\n        if (month == 1 && day >= 20) { return { icon: \"♒️\", sign: \"Acquario\", element: \"Aria\", season: \"Inverno\", type: \"Fisso\", description: \"Segno di stabilità e determinazione\" } }\n        if (month == 2 && day <= 18) { return { icon: \"♒️\", sign: \"Acquario\", element: \"Aria\", season: \"Inverno\", type: \"Fisso\", description: \"Segno di stabilità e determinazione\" } }\n        if (month == 2 && day >= 19) { return { icon: \"♓️\", sign: \"Pesci\", element: \"Acqua\", season: \"Inverno\", type: \"Mobile\", description: \"Segno di ingegno e adattamento\" } }\n        if (month == 3 && day <= 20) { return { icon: \"♓️\", sign: \"Pesci\", element: \"Acqua\", season: \"Inverno\", type: \"Mobile\", description: \"Segno di ingegno e adattamento\" } }\n        if (month == 3 && day >= 21) { return { icon: \"♈️\", sign: \"Ariete\", element: \"Fuoco\", season: \"Primavera\", type: \"Cardinale\", description: \"Segno di iniziativa e creatività\" } }\n        if (month == 4 && day <= 20) { return { icon: \"♈️\", sign: \"Ariete\", element: \"Fuoco\", season: \"Primavera\", type: \"Cardinale\", description: \"Segno di iniziativa e creatività\" } }\n        if (month == 4 && day >= 21) { return { icon: \"♉️\", sign: \"Toro\", element: \"Terra\", season: \"Primavera\", type: \"Fisso\", description: \"Segno di stabilità e determinazione\" } }\n        if (month == 5 && day <= 20) { return { icon: \"♉️\", sign: \"Toro\", element: \"Terra\", season: \"Primavera\", type: \"Fisso\", description: \"Segno di stabilità e determinazione\" } }\n        if (month == 5 && day >= 21) { return { icon: \"♊️\", sign: \"Gemelli\", element: \"Aria\", season: \"Primavera\", type: \"Mobile\", description: \"Segno di ingegno e adattamento\" } }\n        if (month == 6 && day <= 20) { return { icon: \"♊️\", sign: \"Gemelli\", element: \"Aria\", season: \"Primavera\", type: \"Mobile\", description: \"Segno di ingegno e adattamento\" } }\n        if (month == 6 && day >= 21) { return { icon: \"♋️\", sign: \"Cancro\", element: \"Acqua\", season: \"Estate\", type: \"Cardinale\", description: \"Segno di iniziativa e creatività\" } }\n        if (month == 7 && day <= 21) { return { icon: \"♋️\", sign: \"Cancro\", element: \"Acqua\", season: \"Estate\", type: \"Cardinale\", description: \"Segno di iniziativa e creatività\" } }\n        if (month == 7 && day >= 22) { return { icon: \"♌️\", sign: \"Leone\", element: \"Fuoco\", season: \"Estate\", type: \"Fisso\", description: \"Segno di stabilità e determinazione\" } }\n        if (month == 8 && day <= 21) { return { icon: \"♌️\", sign: \"Leone\", element: \"Fuoco\", season: \"Estate\", type: \"Fisso\", description: \"Segno di stabilità e determinazione\" } }\n        if (month == 8 && day >= 22) { return { icon: \"♍️\", sign: \"Vergine\", element: \"Terra\", season: \"Estate\", type: \"Mobile\", description: \"Segno di ingegno e adattamento\" } }\n        if (month == 9 && day <= 21) { return { icon: \"♍️\", sign: \"Vergine\", element: \"Terra\", season: \"Estate\", type: \"Mobile\", description: \"Segno di ingegno e adattamento\" } }\n        if (month == 9 && day >= 22) { return { icon: \"♎️\", sign: \"Bilancia\", element: \"Aria\", season: \"Autunno\", type: \"Cardinale\", description: \"Segno di iniziativa e creatività\" } }\n        if (month == 10 && day <= 21) { return { icon: \"♎️\", sign: \"Bilancia\", element: \"Aria\", season: \"Autunno\", type: \"Cardinale\", description: \"Segno di iniziativa e creatività\" } }\n        if (month == 10 && day >= 22) { return { icon: \"♏️\", sign: \"Scorpione\", element: \"Acqua\", season: \"Autunno\", type: \"Fisso\", description: \"Segno di stabilità e determinazione\" } }\n        if (month == 11 && day <= 21) { return { icon: \"♏️\", sign: \"Scorpione\", element: \"Acqua\", season: \"Autunno\", type: \"Fisso\", description: \"Segno di stabilità e determinazione\" } }\n        if (month == 11 && day >= 22) { return { icon: \"♐️\", sign: \"Sagittario\", element: \"Fuoco\", season: \"Autunno\", type: \"Mobile\", description: \"Segno di ingegno e adattamento\" } }\n        if (month == 12 && day <= 20) { return { icon: \"♐️\", sign: \"Sagittario\", element: \"Fuoco\", season: \"Autunno\", type: \"Mobile\", description: \"Segno di ingegno e adattamento\" } }\n        if (month == 12 && day >= 21) { return { icon: \"♑️\", sign: \"Capricorno\", element: \"Terra\", season: \"Inverno\", type: \"Cardinale\", description: \"Segno di iniziativa e creatività\" } }\n\n        return { icon: null, sign: null, element: null, season: null, type: null, description: null }\n    }\n\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////////////////////////////////\n    //ASTRO FUNCTIONS\n\n}\n\n////////////////////////////////////////////////////////////////////\nvar version_tools = '3.6.5 del 02/01/2023'\n////////////////////////////////////////////////////////////////////\nglobal.set('Tools', { class: Tools, version: version_tools, date_start: Date.now() })\n////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////\n//Tools Class Collections Javascript for Node-RED///////////////////",
        "finalize": "",
        "libs": [],
        "x": 200,
        "y": 380,
        "wires": []
    },
    {
        "id": "e5df7a9578d68238",
        "type": "function",
        "z": "799d902a165e50be",
        "name": "Original message",
        "func": "return msg.original_message || msg",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 905,
        "y": 160,
        "wires": [
            []
        ],
        "l": false
    },
    {
        "id": "4bebee7279e15eae",
        "type": "delay",
        "z": "799d902a165e50be",
        "name": "",
        "pauseType": "delay",
        "timeout": "500",
        "timeoutUnits": "milliseconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "250",
        "randomLast": "500",
        "randomUnits": "milliseconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 695,
        "y": 220,
        "wires": [
            []
        ],
        "l": false
    },
    {
        "id": "8a32a3bce6dbb797",
        "type": "delay",
        "z": "799d902a165e50be",
        "name": "",
        "pauseType": "rate",
        "timeout": "500",
        "timeoutUnits": "milliseconds",
        "rate": "2",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "250",
        "randomLast": "500",
        "randomUnits": "milliseconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 695,
        "y": 160,
        "wires": [
            [
                "f2185d81a99762d2"
            ]
        ],
        "l": false
    },
    {
        "id": "f4e02ac3663daad1",
        "type": "subflow:799d902a165e50be",
        "z": "b47fd0e48cfbee58",
        "name": "",
        "x": 120,
        "y": 60,
        "wires": [
            [],
            [],
            []
        ]
    }
]